/**
 * Design System Generator Tools
 *
 * Generates design system JSX and style guides from brand identity.
 */
import { createTool } from "@decocms/runtime/tools";
import { z } from "zod";
import type { Env } from "../types/env.ts";
import { type BrandIdentity, BrandIdentitySchema } from "./research.ts";

/**
 * Generate CSS variables from brand colors
 */
function generateCSSVariables(identity: BrandIdentity): string {
  const colors = identity.colors || { primary: "#8B5CF6" };
  const typography = identity.typography || {};

  return `/**
 * ${identity.name} Design System
 * Generated by Brand MCP
 */

:root {
  /* Primary Colors */
  --brand-primary: ${colors.primary};
  --brand-primary-light: ${lightenColor(colors.primary, 20)};
  --brand-primary-dark: ${darkenColor(colors.primary, 20)};
  
  /* Secondary Colors */
  --brand-secondary: ${colors.secondary || colors.primary};
  --brand-accent: ${colors.accent || colors.primary};
  
  /* Background Colors */
  --bg-dark: ${colors.background || "#1a1a1a"};
  --bg-light: #FFFFFF;
  --bg-gray: #F5F5F5;
  
  /* Text Colors */
  --text-primary: ${colors.text || "#1A1A1A"};
  --text-secondary: #6B7280;
  --text-light: #FFFFFF;
  --text-muted: #9CA3AF;
  
  /* Typography */
  --font-heading: ${typography.headingFont || "'Inter', system-ui, sans-serif"};
  --font-body: ${typography.bodyFont || "'Inter', system-ui, sans-serif"};
  --font-mono: ${typography.monoFont || "'JetBrains Mono', monospace"};
  
  /* Spacing */
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;
  --spacing-2xl: 3rem;
  
  /* Border Radius */
  --radius-sm: 0.25rem;
  --radius-md: 0.5rem;
  --radius-lg: 1rem;
  --radius-full: 9999px;
  
  /* Shadows */
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
}

/* Dark Mode */
[data-theme="dark"] {
  --bg-dark: #0f0f0f;
  --bg-light: #1a1a1a;
  --bg-gray: #2a2a2a;
  --text-primary: #FFFFFF;
  --text-secondary: #9CA3AF;
}
`;
}

/**
 * Generate JSX design system components
 */
function generateDesignSystemJSX(identity: BrandIdentity): string {
  const colors = identity.colors || { primary: "#8B5CF6" };
  const logos = identity.logos || {};
  const typography = identity.typography || {};

  return `/**
 * ${identity.name} Design System
 * 
 * Auto-generated design system with brand components.
 * Use with Babel Standalone for browser transpilation.
 */

// Brand configuration
const BRAND = {
  name: "${identity.name}",
  tagline: "${identity.tagline || ""}",
  
  colors: {
    primary: "${colors.primary}",
    primaryLight: "${lightenColor(colors.primary, 20)}",
    primaryDark: "${darkenColor(colors.primary, 20)}",
    secondary: "${colors.secondary || colors.primary}",
    accent: "${colors.accent || colors.primary}",
    background: "${colors.background || "#1a1a1a"}",
    text: "${colors.text || "#1A1A1A"}",
    textLight: "#FFFFFF",
    textMuted: "#6B7280",
  },
  
  logos: {
    primary: ${logos.primary ? `"${logos.primary}"` : "null"},
    light: ${logos.light ? `"${logos.light}"` : "null"},
    dark: ${logos.dark ? `"${logos.dark}"` : "null"},
    icon: ${logos.icon ? `"${logos.icon}"` : "null"},
  },
  
  typography: {
    heading: "${typography.headingFont || "Inter, system-ui, sans-serif"}",
    body: "${typography.bodyFont || "Inter, system-ui, sans-serif"}",
    mono: "${typography.monoFont || "JetBrains Mono, monospace"}",
  },
  
  hasImageLogo: ${Boolean(logos.primary)},
};

/**
 * Brand Logo Component
 * Renders image logo if available, falls back to text
 */
function BrandLogo({ variant = "primary", className = "", height = 40 }) {
  const logoUrl = variant === "light" ? BRAND.logos.light :
                  variant === "dark" ? BRAND.logos.dark :
                  BRAND.logos.primary;
  
  if (logoUrl) {
    return (
      <img 
        src={logoUrl} 
        alt={BRAND.name}
        className={\`brand-logo \${className}\`}
        style={{ height: \`\${height}px\`, width: "auto", objectFit: "contain" }}
      />
    );
  }
  
  // Text fallback
  return (
    <span 
      className={\`brand-logo brand-logo--text \${className}\`}
      style={{ 
        fontSize: \`\${height * 0.6}px\`,
        fontWeight: 700,
        fontFamily: BRAND.typography.heading,
        color: variant === "light" ? BRAND.colors.textLight : BRAND.colors.primary,
      }}
    >
      {BRAND.name}
    </span>
  );
}

/**
 * Brand Icon Component
 */
function BrandIcon({ size = 32, className = "" }) {
  if (BRAND.logos.icon) {
    return (
      <img 
        src={BRAND.logos.icon}
        alt={BRAND.name}
        className={\`brand-icon \${className}\`}
        style={{ width: \`\${size}px\`, height: \`\${size}px\`, objectFit: "contain" }}
      />
    );
  }
  
  // Fallback to first letter
  return (
    <div 
      className={\`brand-icon brand-icon--text \${className}\`}
      style={{
        width: \`\${size}px\`,
        height: \`\${size}px\`,
        backgroundColor: BRAND.colors.primary,
        color: BRAND.colors.textLight,
        borderRadius: "8px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        fontSize: \`\${size * 0.5}px\`,
        fontWeight: 700,
        fontFamily: BRAND.typography.heading,
      }}
    >
      {BRAND.name[0]}
    </div>
  );
}

/**
 * Heading Component
 */
function Heading({ level = 1, children, className = "", color = "primary" }) {
  const Tag = \`h\${level}\`;
  const sizes = {
    1: "3rem",
    2: "2.25rem",
    3: "1.875rem",
    4: "1.5rem",
    5: "1.25rem",
    6: "1rem",
  };
  
  const colors = {
    primary: BRAND.colors.text,
    brand: BRAND.colors.primary,
    light: BRAND.colors.textLight,
    muted: BRAND.colors.textMuted,
  };
  
  return (
    <Tag 
      className={\`heading heading--\${level} \${className}\`}
      style={{
        fontFamily: BRAND.typography.heading,
        fontSize: sizes[level],
        fontWeight: level <= 2 ? 700 : 600,
        color: colors[color] || color,
        margin: 0,
        lineHeight: 1.2,
      }}
    >
      {children}
    </Tag>
  );
}

/**
 * Text Component
 */
function Text({ size = "base", children, className = "", color = "primary", weight = "normal" }) {
  const sizes = {
    xs: "0.75rem",
    sm: "0.875rem",
    base: "1rem",
    lg: "1.125rem",
    xl: "1.25rem",
  };
  
  const colors = {
    primary: BRAND.colors.text,
    secondary: BRAND.colors.textMuted,
    brand: BRAND.colors.primary,
    light: BRAND.colors.textLight,
  };
  
  return (
    <p 
      className={\`text text--\${size} \${className}\`}
      style={{
        fontFamily: BRAND.typography.body,
        fontSize: sizes[size],
        fontWeight: weight === "bold" ? 600 : 400,
        color: colors[color] || color,
        margin: 0,
        lineHeight: 1.6,
      }}
    >
      {children}
    </p>
  );
}

/**
 * Button Component
 */
function Button({ variant = "primary", size = "md", children, className = "", ...props }) {
  const variants = {
    primary: {
      backgroundColor: BRAND.colors.primary,
      color: BRAND.colors.textLight,
      border: "none",
    },
    secondary: {
      backgroundColor: "transparent",
      color: BRAND.colors.primary,
      border: \`2px solid \${BRAND.colors.primary}\`,
    },
    ghost: {
      backgroundColor: "transparent",
      color: BRAND.colors.text,
      border: "none",
    },
  };
  
  const sizes = {
    sm: { padding: "0.5rem 1rem", fontSize: "0.875rem" },
    md: { padding: "0.75rem 1.5rem", fontSize: "1rem" },
    lg: { padding: "1rem 2rem", fontSize: "1.125rem" },
  };
  
  return (
    <button 
      className={\`button button--\${variant} button--\${size} \${className}\`}
      style={{
        ...variants[variant],
        ...sizes[size],
        fontFamily: BRAND.typography.body,
        fontWeight: 600,
        borderRadius: "0.5rem",
        cursor: "pointer",
        transition: "all 0.2s ease",
      }}
      {...props}
    >
      {children}
    </button>
  );
}

/**
 * Card Component
 */
function Card({ children, className = "", variant = "default" }) {
  const variants = {
    default: {
      backgroundColor: "#FFFFFF",
      border: "1px solid #E5E7EB",
    },
    elevated: {
      backgroundColor: "#FFFFFF",
      boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)",
    },
    brand: {
      backgroundColor: BRAND.colors.primary,
      color: BRAND.colors.textLight,
    },
  };
  
  return (
    <div 
      className={\`card card--\${variant} \${className}\`}
      style={{
        ...variants[variant],
        borderRadius: "1rem",
        padding: "1.5rem",
      }}
    >
      {children}
    </div>
  );
}

/**
 * Color Swatch Component
 */
function ColorSwatch({ color, name, className = "" }) {
  return (
    <div className={\`color-swatch \${className}\`} style={{ textAlign: "center" }}>
      <div 
        style={{
          width: "80px",
          height: "80px",
          backgroundColor: color,
          borderRadius: "0.5rem",
          margin: "0 auto 0.5rem",
          boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
        }}
      />
      <Text size="sm" weight="bold">{name}</Text>
      <Text size="xs" color="secondary">{color}</Text>
    </div>
  );
}

// Export components
if (typeof window !== "undefined") {
  window.BRAND = BRAND;
  window.BrandLogo = BrandLogo;
  window.BrandIcon = BrandIcon;
  window.Heading = Heading;
  window.Text = Text;
  window.Button = Button;
  window.Card = Card;
  window.ColorSwatch = ColorSwatch;
}
`;
}

/**
 * Generate style guide markdown
 */
function generateStyleGuide(identity: BrandIdentity): string {
  const colors = identity.colors || { primary: "#8B5CF6" };
  const typography = identity.typography || {};
  const style = identity.style || {};
  const voice = identity.voice || {};

  return `# ${identity.name} Brand Style Guide

${identity.description ? `> ${identity.description}` : ""}

${identity.tagline ? `**Tagline:** "${identity.tagline}"` : ""}

---

## Brand Identity

**Name:** ${identity.name}
${identity.industry ? `**Industry:** ${identity.industry}` : ""}
${identity.founded ? `**Founded:** ${identity.founded}` : ""}

---

## Color Palette

### Primary Colors

| Color | Hex | Usage |
|-------|-----|-------|
| Primary | \`${colors.primary}\` | Main brand color, CTAs, links |
| Primary Light | \`${lightenColor(colors.primary, 20)}\` | Hover states, backgrounds |
| Primary Dark | \`${darkenColor(colors.primary, 20)}\` | Active states, emphasis |

${
  colors.secondary
    ? `### Secondary Colors

| Color | Hex | Usage |
|-------|-----|-------|
| Secondary | \`${colors.secondary}\` | Supporting elements |
${colors.accent ? `| Accent | \`${colors.accent}\` | Highlights, notifications |` : ""}`
    : ""
}

### Background & Text

| Color | Hex | Usage |
|-------|-----|-------|
| Background | \`${colors.background || "#1a1a1a"}\` | Dark backgrounds |
| Text | \`${colors.text || "#1A1A1A"}\` | Primary text |
| Text Muted | \`#6B7280\` | Secondary text |

${
  colors.palette?.length
    ? `### Full Palette

${colors.palette.map((c) => `- \`${c}\``).join("\n")}`
    : ""
}

---

## Typography

### Font Families

- **Headings:** ${typography.headingFont || "Inter, system-ui, sans-serif"}
- **Body:** ${typography.bodyFont || "Inter, system-ui, sans-serif"}
${typography.monoFont ? `- **Monospace:** ${typography.monoFont}` : ""}

### Type Scale

| Element | Size | Weight |
|---------|------|--------|
| H1 | 3rem (48px) | Bold (700) |
| H2 | 2.25rem (36px) | Bold (700) |
| H3 | 1.875rem (30px) | Semibold (600) |
| H4 | 1.5rem (24px) | Semibold (600) |
| Body | 1rem (16px) | Regular (400) |
| Small | 0.875rem (14px) | Regular (400) |

---

## Logo Usage

${
  identity.logos?.primary
    ? `### Primary Logo

![${identity.name} Logo](${identity.logos.primary})

- Use on light backgrounds
- Maintain clear space equal to the height of the logo
- Minimum size: 100px width`
    : `### Logo

*Logo URL not available. Please provide logo assets.*`
}

${
  identity.logos?.light
    ? `### Light Logo (for dark backgrounds)

![${identity.name} Light Logo](${identity.logos.light})`
    : ""
}

${
  identity.logos?.dark
    ? `### Dark Logo (for light backgrounds)

![${identity.name} Dark Logo](${identity.logos.dark})`
    : ""
}

${
  identity.logos?.icon
    ? `### Icon/Favicon

![${identity.name} Icon](${identity.logos.icon})

- Use for favicons, app icons, social media
- Square format (1:1 ratio)`
    : ""
}

---

## Visual Style

${style.aesthetic ? `**Aesthetic:** ${style.aesthetic}` : ""}
${style.mood ? `**Mood:** ${style.mood}` : ""}
${style.keywords?.length ? `**Keywords:** ${style.keywords.join(", ")}` : ""}

### UI Elements

- **Border Radius:** ${style.borderRadius || "0.5rem (8px)"}
- **Shadows:** ${style.shadows || "Subtle, layered shadows"}

---

${
  voice.tone || voice.personality?.length || voice.values?.length
    ? `## Brand Voice

${voice.tone ? `**Tone:** ${voice.tone}` : ""}

${
  voice.personality?.length
    ? `### Personality
${voice.personality.map((p) => `- ${p}`).join("\n")}`
    : ""
}

${
  voice.values?.length
    ? `### Core Values
${voice.values.map((v) => `- ${v}`).join("\n")}`
    : ""
}

---`
    : ""
}

## Usage Guidelines

1. **Consistency:** Always use the exact hex values specified
2. **Contrast:** Ensure sufficient contrast for accessibility (WCAG 2.1 AA)
3. **Spacing:** Use the spacing scale (0.25rem increments)
4. **Typography:** Maintain the type hierarchy
5. **Logo:** Never stretch, distort, or recolor the logo

---

*Generated by Brand MCP*
`;
}

// Helper functions
function lightenColor(hex: string, percent: number): string {
  const num = parseInt(hex.replace("#", ""), 16);
  const amt = Math.round(2.55 * percent);
  const R = Math.min(255, (num >> 16) + amt);
  const G = Math.min(255, ((num >> 8) & 0x00ff) + amt);
  const B = Math.min(255, (num & 0x0000ff) + amt);
  return `#${((1 << 24) + (R << 16) + (G << 8) + B).toString(16).slice(1)}`;
}

function darkenColor(hex: string, percent: number): string {
  const num = parseInt(hex.replace("#", ""), 16);
  const amt = Math.round(2.55 * percent);
  const R = Math.max(0, (num >> 16) - amt);
  const G = Math.max(0, ((num >> 8) & 0x00ff) - amt);
  const B = Math.max(0, (num & 0x0000ff) - amt);
  return `#${((1 << 24) + (R << 16) + (G << 8) + B).toString(16).slice(1)}`;
}

/**
 * BRAND_GENERATE - Generate complete design system from brand identity
 */
export const createBrandGenerateTool = (_env: Env) =>
  createTool({
    id: "BRAND_GENERATE",
    _meta: { "ui/resourceUri": "ui://brand-preview" },
    description: `Generate a complete design system from brand identity.

Creates:
- CSS variables file
- JSX component library
- Markdown style guide

**Input:** Brand identity object (from BRAND_DISCOVER or manual)
**Output:** Complete design system files ready to use`,
    inputSchema: z.object({
      identity: BrandIdentitySchema.describe("Brand identity to generate from"),
      outputFormat: z
        .enum(["all", "css", "jsx", "styleguide"])
        .optional()
        .describe("Which outputs to generate (default: all)"),
    }),
    outputSchema: z.object({
      brandName: z.string(),
      css: z.string().optional().describe("CSS variables file content"),
      jsx: z.string().optional().describe("JSX design system content"),
      styleGuide: z.string().optional().describe("Markdown style guide"),
    }),
    execute: async ({ context }) => {
      const { identity, outputFormat = "all" } = context;

      const result: {
        brandName: string;
        css?: string;
        jsx?: string;
        styleGuide?: string;
      } = {
        brandName: identity.name,
      };

      if (outputFormat === "all" || outputFormat === "css") {
        result.css = generateCSSVariables(identity);
      }

      if (outputFormat === "all" || outputFormat === "jsx") {
        result.jsx = generateDesignSystemJSX(identity);
      }

      if (outputFormat === "all" || outputFormat === "styleguide") {
        result.styleGuide = generateStyleGuide(identity);
      }

      return result;
    },
  });

/**
 * BRAND_CREATE - Full workflow: discover + generate
 */
export const createBrandCreateTool = (env: Env) =>
  createTool({
    id: "BRAND_CREATE",
    _meta: { "ui/resourceUri": "ui://brand-preview" },
    description: `Complete brand creation workflow.

This is the main tool - it:
1. Discovers brand identity from website + research
2. Generates complete design system
3. Returns everything ready to use

**Best for:** One-step brand creation from a website URL.`,
    inputSchema: z.object({
      brandName: z.string().describe("Brand or company name"),
      websiteUrl: z.string().url().describe("Brand website URL"),
    }),
    outputSchema: z.object({
      success: z.boolean(),
      identity: BrandIdentitySchema.optional(),
      css: z.string().optional(),
      jsx: z.string().optional(),
      styleGuide: z.string().optional(),
      error: z.string().optional(),
    }),
    execute: async ({ context }) => {
      const { brandName, websiteUrl } = context;

      const scraper = env.MESH_REQUEST_CONTEXT?.state?.SCRAPER;
      const perplexity = env.MESH_REQUEST_CONTEXT?.state?.PERPLEXITY;

      if (!scraper && !perplexity) {
        return {
          success: false,
          error:
            "No research bindings available. Configure SCRAPER and/or PERPLEXITY bindings.",
        };
      }

      // Step 1: Discover brand identity (reuse logic from research.ts)
      const identity: BrandIdentity = {
        name: brandName,
        colors: { primary: "#8B5CF6" },
        sources: [],
        confidence: "low",
      };

      // Scrape website
      if (scraper) {
        try {
          const result = (await scraper.scrape_content({
            url: websiteUrl,
            formats: ["branding", "links"],
          })) as { branding?: Record<string, unknown> };

          if (result?.branding) {
            const branding = result.branding;

            if (branding.colors && typeof branding.colors === "object") {
              const colors = branding.colors as Record<string, string>;
              identity.colors = {
                primary: colors.primary || colors.main || "#8B5CF6",
                secondary: colors.secondary,
                accent: colors.accent,
                background: colors.background,
                text: colors.text,
                palette: Object.values(colors).filter(
                  (c) => typeof c === "string" && c.startsWith("#"),
                ),
              };
            }

            if (branding.logos) {
              if (Array.isArray(branding.logos)) {
                identity.logos = {
                  primary: branding.logos[0] as string,
                  alternates: branding.logos.slice(1) as string[],
                };
              } else if (typeof branding.logos === "object") {
                const logos = branding.logos as Record<string, string>;
                identity.logos = {
                  primary: logos.primary || logos.main,
                  light: logos.light,
                  dark: logos.dark,
                  icon: logos.icon,
                };
              }
            }

            if (branding.fonts && typeof branding.fonts === "object") {
              const fonts = branding.fonts as Record<string, string>;
              identity.typography = {
                headingFont: fonts.heading || fonts.title,
                bodyFont: fonts.body || fonts.text,
                monoFont: fonts.mono,
              };
            }

            identity.sources?.push(websiteUrl);
          }
        } catch (error) {
          console.error("Scraping error:", error);
        }
      }

      // Research with Perplexity
      if (perplexity) {
        try {
          const result = (await perplexity.perplexity_research({
            messages: [
              {
                role: "user",
                content: `Brief info on ${brandName} (${websiteUrl}): tagline, primary color hex, and brand personality in 2-3 sentences.`,
              },
            ],
            strip_thinking: true,
          })) as { response?: string };

          if (result?.response) {
            const response = result.response;

            // Extract tagline
            const taglineMatch = response.match(
              /(?:tagline|slogan)[:\s]+["']?([^"'\n.]+)["']?/i,
            );
            if (taglineMatch) {
              identity.tagline = taglineMatch[1].trim();
            }

            // Extract colors if we don't have good ones
            if (identity.colors.primary === "#8B5CF6") {
              const hexColors = response.match(/#[0-9A-Fa-f]{6}/g);
              if (hexColors?.length) {
                identity.colors.primary = hexColors[0];
              }
            }

            identity.sources?.push("perplexity-research");
          }
        } catch (error) {
          console.error("Research error:", error);
        }
      }

      // Determine confidence
      const hasLogo = Boolean(identity.logos?.primary);
      const hasColors = identity.colors.primary !== "#8B5CF6";
      identity.confidence =
        hasLogo && hasColors ? "high" : hasLogo || hasColors ? "medium" : "low";

      // Step 2: Generate design system
      const css = generateCSSVariables(identity);
      const jsx = generateDesignSystemJSX(identity);
      const styleGuide = generateStyleGuide(identity);

      return {
        success: true,
        identity,
        css,
        jsx,
        styleGuide,
      };
    },
  });

export const generatorTools = [createBrandGenerateTool, createBrandCreateTool];

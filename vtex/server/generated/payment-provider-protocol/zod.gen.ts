// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod';

/**
 * Payment methods information.
 */
export const zSuccess = z.object({
    paymentMethods: z.array(z.string().register(z.globalRegistry, {
        description: 'Payment methods information.'
    })).register(z.globalRegistry, {
        description: 'List of each payment method implemented.'
    })
}).register(z.globalRegistry, {
    description: 'Payment methods information.'
});

/**
 * Payment provider manifest response body information.
 */
export const zSuccessManifest = z.object({
    paymentMethods: z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'Payment method name.'
        }),
        allowsSplit: z.enum([
            'onAuthorize',
            'onCapture',
            'disabled'
        ]).register(z.globalRegistry, {
            description: 'Describes which transaction flow stage the connector should receive payment split data. Check more details on the [Split Payouts on the Payment Provider Protocol](https://developers.vtex.com/vtex-rest-api/docs/split-payouts-on-payment-provider-protocol) article.'
        })
    }).register(z.globalRegistry, {
        description: 'Payment methods information.'
    })).register(z.globalRegistry, {
        description: 'Describes each payment method supported by payment provider and exposed its respective metadata.'
    }),
    customFields: z.optional(z.array(z.object({
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Custom field name.'
        })),
        type: z.optional(z.enum([
            'text',
            'password',
            'select'
        ]).register(z.globalRegistry, {
            description: 'Custom field type.'
        })),
        options: z.optional(z.array(z.object({
            text: z.optional(z.string().register(z.globalRegistry, {
                description: 'Custom field description.'
            })),
            value: z.optional(z.string().register(z.globalRegistry, {
                description: 'Custom field value.'
            }))
        }).register(z.globalRegistry, {
            description: 'Custom field information.'
        })).register(z.globalRegistry, {
            description: 'In case of `select` type, the possible params are `text` and `value`.'
        }))
    }).register(z.globalRegistry, {
        description: 'Custom fields information.'
    })).register(z.globalRegistry, {
        description: 'Describes the customized fields supported by the connector. Except for `appKey` or `appToken` values, which must be defined in homonymous fields, any other security data should be sent or stored as `password` type fields.'
    })),
    autoSettleDelay: z.optional(z.object({
        minimum: z.string().register(z.globalRegistry, {
            description: 'Minimum amount of time to auto settle in hours.'
        }),
        maximum: z.string().register(z.globalRegistry, {
            description: 'Maximum amount of time to auto settle in hours.'
        })
    }).register(z.globalRegistry, {
        description: 'Describes the allowed delay value for the auto settle capture. Accepted values: `minimum` and `maximum` in whole hours (decimals are not allowed). Check more details on the [Custom Auto Capture Feature](https://developers.vtex.com/vtex-rest-api/docs/custom-auto-capture-feature) article.'
    })),
    metadataFields: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Metadata fields information.'
    })).register(z.globalRegistry, {
        description: 'Array containing the names of the metadata fields sent from the provider to the payment gateway. Limitations: the array must contain a maximum of 3 strings, and each of them, a maximum of 20 characters.'
    }))
}).register(z.globalRegistry, {
    description: 'Payment provider manifest response body information.'
});

/**
 * Create payment response body information.
 */
export const zSuccessApproved = z.object({
    paymentId: z.string().register(z.globalRegistry, {
        description: 'VTEX identifier for this payment. The same sent in the request.'
    }),
    status: z.string().register(z.globalRegistry, {
        description: 'The Provider\'s status for this payment. Must be one of three values:\r\n\r\n- `approved`\r\n- `denied`\r\n- `undefined`.'
    }),
    authorizationId: z.string().register(z.globalRegistry, {
        description: 'Provider\'s unique identifier for the authorization. Should be sent when the payment is authorized. In other statuses, it should be absent or `null`.'
    }),
    bankIssueInvoiceId: z.optional(z.string().register(z.globalRegistry, {
        description: 'This field is deprecated, please use `paymentUrl` instead. The bank invoice URL to be presented to the end user.'
    })),
    paymentUrl: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    paymentAppData: z.optional(z.object({
        appName: z.string().register(z.globalRegistry, {
            description: 'Indicates which VTEX IO app that will handle the payment flow at Checkout.'
        }),
        payload: z.string().register(z.globalRegistry, {
            description: 'The payload that will be sent to your app, like a serialized JSON, for example.'
        })
    }).register(z.globalRegistry, {
        description: 'Object which indicates that a [Payment App](https://developers.vtex.com/docs/guides/payments-integration-payment-app) is needed to finish the payment. This object contains the data to be used by the Payment App.'
    })),
    identificationNumber: z.optional(z.string().register(z.globalRegistry, {
        description: 'The bank invoice unformatted identification number. Should only be present when the payment is made via bank invoice.'
    })),
    identificationNumberFormatted: z.optional(z.string().register(z.globalRegistry, {
        description: 'The bank invoice formatted identification number that will be presented to the end user.'
    })),
    barCodeImageType: z.optional(z.string().register(z.globalRegistry, {
        description: 'The bank invoice barcode image type. For instance, "i25" for Brazilian *Boleto Banc√°rio*. Should only be present when the payment is made via bank invoice.'
    })),
    barCodeImageNumber: z.optional(z.string().register(z.globalRegistry, {
        description: 'The bank invoice number to generate a barcode (must follow any regulations/specifications for targeted countries). Should only be present when the payment is made via bank invoice.'
    })),
    tid: z.string().register(z.globalRegistry, {
        description: 'Provider\'s unique identifier for the transaction.'
    }),
    nsu: z.union([
        z.string(),
        z.null()
    ]),
    acquirer: z.union([
        z.string(),
        z.null()
    ]),
    redirectUrl: z.optional(z.string().register(z.globalRegistry, {
        description: 'This field is deprecated, please use `paymentUrl` instead. The URL the end user needs to be redirected to (external authentication, 3DS, etc).'
    })),
    code: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    message: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    delayToAutoSettle: z.int().register(z.globalRegistry, {
        description: 'Total time (in seconds) before we make an automatic call to `/settlements`, regardless of whether the payment was approved by the merchant\'s anti-fraud provider or not. The maximum time allowed to wait for an auto capture is 604800 seconds (7 days).'
    }),
    delayToAutoSettleAfterAntifraud: z.int().register(z.globalRegistry, {
        description: 'Total time (in seconds) before we make an automatic call to `/settlements` after merchant\'s antifraud approval.'
    }),
    delayToCancel: z.int().register(z.globalRegistry, {
        description: 'Total time (in seconds) to wait for an authorization and make an automatic call to `/cancellations` to cancel the payment. The minimum value is 10 minutes (600 seconds).\r\n\r\n**NOTE 1**: If you set this field to a time period of less than 24 hours (86399 seconds or less), the gateway will retry processing the payment every 1 hour. If you use a value of 24 hours (86400 seconds) or more in this field, the gateway will retry processing the payment every 4 hours.\r\n\r\n**NOTE 2**: For `delayToCancel` values between 5 minutes and 1 hour (300 and 3600 seconds), or when payment is made by [PIX](https://developers.vtex.com/docs/guides/payments-integration-pix-instant-payments-in-brazil) (Brazilian instant payment method), retry calls will occur every 5 minutes.\r\n\r\n**NOTE 3**: The maximum value allowed for the `delayToCancel` field is 30 days (2592000 seconds). However, when payment is made by [PIX](https://developers.vtex.com/docs/guides/payments-integration-pix-instant-payments-in-brazil) (Brazilian instant payment method), the values must be set between 15 and 1 hour (900 seconds and 3600 seconds).'
    }),
    maxValue: z.optional(z.int().register(z.globalRegistry, {
        description: 'The maximum value for this payment. This field allows changes to be made to transactions to settle larger amounts as a result of order changes.'
    })),
    connectorMetadata: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The name of the metadata to be stored in the gateway (limited to 20 characters).'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The value of the metadata stored (limited to 200 characters).'
        })
    }).register(z.globalRegistry, {
        description: 'Metadata fields information.'
    })).register(z.globalRegistry, {
        description: 'Array containing metadata fields sent from the provider to the payment gateway.'
    }))
}).register(z.globalRegistry, {
    description: 'Create payment response body information.'
});

/**
 * Bad request information.
 */
export const zFailBadRequest = z.object({
    status: z.string().register(z.globalRegistry, {
        description: 'The Provider\'s status for this payment.'
    }),
    code: z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error code to be logged.'
    }),
    message: z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error message to be logged.'
    })
}).register(z.globalRegistry, {
    description: 'Bad request information.'
});

/**
 * Cancel payment request body information.
 */
export const zCancelPaymentRequest = z.object({
    paymentId: z.string().register(z.globalRegistry, {
        description: 'VTEX payment identifier.'
    }),
    requestId: z.string().register(z.globalRegistry, {
        description: 'VTEX request identifier.'
    }),
    authorizationId: z.string().register(z.globalRegistry, {
        description: 'Payment authorization identifier (in case it was authorized previous to the cancellation request).'
    }),
    tid: z.optional(z.string().register(z.globalRegistry, {
        description: 'Provider\'s unique identifier for the transaction.'
    })),
    transactionId: z.optional(z.string().register(z.globalRegistry, {
        description: 'VTEX transaction ID related to this payment.'
    })),
    value: z.optional(z.number().register(z.globalRegistry, {
        description: 'Value in cents of the purchase that will be cancelled.'
    })),
    nsu: z.optional(z.string().register(z.globalRegistry, {
        description: 'Provider\'s unique sequential number for the transaction.'
    })),
    sandboxMode: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether or not this request is being sent from a sandbox environment.'
    })),
    merchantSettings: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The custom field name.'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The custom field value.'
        })
    }).register(z.globalRegistry, {
        description: 'Merchant settings information.'
    })).register(z.globalRegistry, {
        description: 'Custom fields (for the given provider) which the merchant must fill. Each element of this array is a key-value pair.'
    })),
    connectorMetadata: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The name of the metadata to be stored in the gateway (limited to 20 characters).'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The value of the metadata stored (limited to 200 characters).'
        })
    }).register(z.globalRegistry, {
        description: 'Metadata fields information.'
    })).register(z.globalRegistry, {
        description: 'Array containing metadata fields sent from the provider to the payment gateway.'
    }))
}).register(z.globalRegistry, {
    description: 'Cancel payment request body information.'
});

/**
 * Cancel payment response body information.
 */
export const zSuccess1 = z.object({
    paymentId: z.string().register(z.globalRegistry, {
        description: 'The same `paymentId` sent in the request.'
    }),
    cancellationId: z.string().register(z.globalRegistry, {
        description: 'Provider\'s cancellation identifier. If the operation has failed you **MUST** return `null`.'
    }),
    code: z.union([
        z.string(),
        z.null()
    ]),
    message: z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error message to be logged.'
    }),
    requestId: z.string().register(z.globalRegistry, {
        description: 'The same `requestId` sent in the request.'
    }),
    connectorMetadata: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The name of the metadata to be stored in the gateway (limited to 20 characters).'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The value of the metadata stored (limited to 200 characters).'
        })
    }).register(z.globalRegistry, {
        description: 'Metadata fields information.'
    })).register(z.globalRegistry, {
        description: 'Array containing metadata fields sent from the provider to the payment gateway.'
    }))
}).register(z.globalRegistry, {
    description: 'Cancel payment response body information.'
});

/**
 * Cancellation failure information.
 */
export const zFailGenericError1 = z.object({
    paymentId: z.string().register(z.globalRegistry, {
        description: 'The same `paymentId` sent in the request.'
    }),
    cancellationId: z.union([
        z.string(),
        z.null()
    ]),
    code: z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error code to be logged. Return `cancel-manually` if you do not support this operation, so we can send a notification to the merchant.'
    }),
    message: z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error message to be logged.'
    }),
    requestId: z.string().register(z.globalRegistry, {
        description: 'The same `requestId` sent in the request.'
    })
}).register(z.globalRegistry, {
    description: 'Cancellation failure information.'
});

/**
 * Settle payment response body information.
 */
export const zSuccess2 = z.object({
    paymentId: z.string().register(z.globalRegistry, {
        description: 'The same `paymentId` sent in the request.'
    }),
    settleId: z.string().register(z.globalRegistry, {
        description: 'VTEX identifier for this settlement.'
    }),
    value: z.number().register(z.globalRegistry, {
        description: 'The amount to be settled.'
    }),
    code: z.union([
        z.string(),
        z.null()
    ]),
    message: z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error message to be logged.'
    }),
    requestId: z.string().register(z.globalRegistry, {
        description: 'The same `requestId` sent in the request.'
    }),
    connectorMetadata: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The name of the metadata to be stored in the gateway (limited to 20 characters).'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The value of the metadata stored (limited to 200 characters).'
        })
    }).register(z.globalRegistry, {
        description: 'Metadata fields information.'
    })).register(z.globalRegistry, {
        description: 'Array containing metadata fields sent from the provider to the payment gateway.'
    }))
}).register(z.globalRegistry, {
    description: 'Settle payment response body information.'
});

/**
 * Internal server error information.
 */
export const zFailGenericError2 = z.object({
    paymentId: z.string().register(z.globalRegistry, {
        description: 'The same `paymentId` sent in the request.'
    }),
    settleId: z.union([
        z.string(),
        z.null()
    ]),
    value: z.number().register(z.globalRegistry, {
        description: 'The amount to be settled.'
    }),
    code: z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error code to be logged.'
    }),
    message: z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error message to be logged.'
    }),
    requestId: z.string().register(z.globalRegistry, {
        description: 'The same `requestId` sent in the request.'
    })
}).register(z.globalRegistry, {
    description: 'Internal server error information.'
});

/**
 * Refund payment response body information.
 */
export const zSuccess3 = z.object({
    paymentId: z.string().register(z.globalRegistry, {
        description: 'The same `paymentId` sent in the request.'
    }),
    refundId: z.string().register(z.globalRegistry, {
        description: 'Provider\'s refund identifier. If the operation has failed you **MUST** return `null`.'
    }),
    value: z.number().register(z.globalRegistry, {
        description: 'The amount that was refunded. If the operation has failed you **MUST** return `0`.'
    }),
    code: z.union([
        z.string(),
        z.null()
    ]),
    message: z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error message to be logged.'
    }),
    requestId: z.string().register(z.globalRegistry, {
        description: 'The same `requestId` sent in the request.'
    }),
    connectorMetadata: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The name of the metadata to be stored in the gateway (limited to 20 characters).'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The value of the metadata stored (limited to 200 characters).'
        })
    }).register(z.globalRegistry, {
        description: 'Metadata fields information.'
    })).register(z.globalRegistry, {
        description: 'Array containing metadata fields sent from the provider to the payment gateway.'
    }))
}).register(z.globalRegistry, {
    description: 'Refund payment response body information.'
});

/**
 * Internal server error information.
 */
export const zFailGenericError3 = z.object({
    paymentId: z.string().register(z.globalRegistry, {
        description: 'The same `paymentId` sent in the request.'
    }),
    refundId: z.union([
        z.string(),
        z.null()
    ]),
    value: z.number().register(z.globalRegistry, {
        description: 'The amount to be settled.'
    }),
    code: z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error code to be logged. Return `refund-manually` if you do not support this operation, so we can send a notification to the merchant.'
    }),
    message: z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error message to be logged.'
    }),
    requestId: z.string().register(z.globalRegistry, {
        description: 'The same `requestId` sent in the request.'
    })
}).register(z.globalRegistry, {
    description: 'Internal server error information.'
});

/**
 * Settle payment request body information.
 */
export const zSettlePayment = z.object({
    transactionId: z.string().register(z.globalRegistry, {
        description: 'VTEX identifier for the transaction related to this payment.'
    }),
    requestId: z.string().register(z.globalRegistry, {
        description: 'The unique identifier for this request to ensure its idempotency.'
    }),
    paymentId: z.string().register(z.globalRegistry, {
        description: 'VTEX identifier for this payment.'
    }),
    value: z.number().register(z.globalRegistry, {
        description: 'The amount to be settled.'
    }),
    authorizationId: z.string().register(z.globalRegistry, {
        description: 'The authorization identifier for this payment.'
    }),
    tid: z.optional(z.string().register(z.globalRegistry, {
        description: 'Provider\'s unique identifier for the transaction.'
    })),
    nsu: z.optional(z.string().register(z.globalRegistry, {
        description: 'Provider\'s unique sequential number for the transaction.'
    })),
    recipients: z.optional(z.array(z.object({
        id: z.string().register(z.globalRegistry, {
            description: 'Recipient identifier.'
        }),
        name: z.string().register(z.globalRegistry, {
            description: 'Recipient name.'
        }),
        documentType: z.string().register(z.globalRegistry, {
            description: 'Recipient document type.'
        }),
        document: z.string().register(z.globalRegistry, {
            description: 'Recipient document number.'
        }),
        role: z.string().register(z.globalRegistry, {
            description: 'Indicates if the recipient is the seller or the marketplace.'
        }),
        chargeProcessingFee: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether or not this recipient is charged for processing fees.'
        })),
        chargebackLiable: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether or not this recipient is liable to chargebacks.'
        })),
        amount: z.number().register(z.globalRegistry, {
            description: 'Amount due to this recipient.'
        }),
        commissionAmount: z.optional(z.number().register(z.globalRegistry, {
            description: 'Amount of commission due to the marketplace.'
        }))
    }).register(z.globalRegistry, {
        description: 'Recipients information.'
    })).register(z.globalRegistry, {
        description: 'Array containing the information for the recipients of this payment in case the Payment Provider is configured to allow the split of payments.'
    })),
    sandboxMode: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether or not this request is being sent from a sandbox environment.'
    })),
    merchantSettings: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The custom field name.'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The custom field value.'
        })
    }).register(z.globalRegistry, {
        description: 'Merchant settings information.'
    })).register(z.globalRegistry, {
        description: 'Custom fields (for the given provider) which the merchant must fill. Each element of this array is a key-value pair.'
    })),
    connectorMetadata: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The name of the metadata to be stored in the gateway (limited to 20 characters).'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The value of the metadata stored (limited to 200 characters).'
        })
    }).register(z.globalRegistry, {
        description: 'Metadata fields information.'
    })).register(z.globalRegistry, {
        description: 'Array containing metadata fields sent from the provider to the payment gateway.'
    }))
}).register(z.globalRegistry, {
    description: 'Settle payment request body information.'
});

/**
 * Refund payment request body information.
 */
export const zRefundPayment = z.object({
    requestId: z.string().register(z.globalRegistry, {
        description: 'The unique identifier for this request to ensure its idempotency.'
    }),
    settleId: z.string().register(z.globalRegistry, {
        description: 'Provider\'s settlement identifier.'
    }),
    paymentId: z.string().register(z.globalRegistry, {
        description: 'VTEX identifier for this payment.'
    }),
    tid: z.string().register(z.globalRegistry, {
        description: 'Provider\'s unique identifier for the transaction.'
    }),
    value: z.number().register(z.globalRegistry, {
        description: 'The amount to be refunded.'
    }),
    transactionId: z.string().register(z.globalRegistry, {
        description: 'VTEX identifier for this transaction.'
    }),
    authorizationId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The authorization identifier for this payment.'
    })),
    nsu: z.optional(z.string().register(z.globalRegistry, {
        description: 'Provider\'s unique sequential number for the transaction.'
    })),
    recipients: z.optional(z.array(z.object({
        id: z.string().register(z.globalRegistry, {
            description: 'Recipient identifier.'
        }),
        name: z.string().register(z.globalRegistry, {
            description: 'Recipient name.'
        }),
        documentType: z.string().register(z.globalRegistry, {
            description: 'Recipient document type.'
        }),
        document: z.string().register(z.globalRegistry, {
            description: 'Recipient document number.'
        }),
        role: z.string().register(z.globalRegistry, {
            description: 'Indicates if the recipient is the seller or the marketplace.'
        }),
        chargeProcessingFee: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether or not this recipient is charged for processing fees.'
        })),
        chargebackLiable: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether or not this recipient is liable to chargebacks.'
        })),
        amount: z.number().register(z.globalRegistry, {
            description: 'Amount due to this recipient.'
        }),
        comissionAmount: z.optional(z.number().register(z.globalRegistry, {
            description: 'Amount received by the Marketplace.'
        }))
    }).register(z.globalRegistry, {
        description: 'Recipients information.'
    })).register(z.globalRegistry, {
        description: 'Array containing the information for the recipients of this payment in case the Payment Provider is configured to allow the split of payments.'
    })),
    sandboxMode: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether or not this request is being sent from a sandbox environment.'
    })),
    merchantSettings: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The custom field name.'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The custom field value.'
        })
    }).register(z.globalRegistry, {
        description: 'Merchant settings information.'
    })).register(z.globalRegistry, {
        description: 'Custom fields (for the given provider) which the merchant must fill. Each element of this array is a key-value pair.'
    })),
    connectorMetadata: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The name of the metadata to be stored in the gateway (limited to 20 characters).'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The value of the metadata stored (limited to 200 characters).'
        })
    }).register(z.globalRegistry, {
        description: 'Metadata fields information.'
    })).register(z.globalRegistry, {
        description: 'Array containing metadata fields sent from the provider to the payment gateway.'
    }))
}).register(z.globalRegistry, {
    description: 'Refund payment request body information.'
});

/**
 * Request data information.
 */
export const zRequestData = z.object({
    body: z.string().register(z.globalRegistry, {
        description: 'Original request body information.'
    })
}).register(z.globalRegistry, {
    description: 'Request data information.'
});

/**
 * Inbound request information.
 */
export const zInboundRequestBetaRequest = z.object({
    requestId: z.string().register(z.globalRegistry, {
        description: 'The unique identifier for this request to ensure its idempotency.'
    }),
    transactionId: z.string().register(z.globalRegistry, {
        description: 'VTEX transaction ID related to this payment.'
    }),
    paymentId: z.string().register(z.globalRegistry, {
        description: 'VTEX payment ID from this payment.'
    }),
    authorizationId: z.string().register(z.globalRegistry, {
        description: 'Provider\'s unique identifier for the authorization.'
    }),
    nsu: z.string().register(z.globalRegistry, {
        description: 'Provider\'s unique sequential number for the transaction.'
    }),
    tid: z.string().register(z.globalRegistry, {
        description: 'Provider\'s unique identifier for the transaction.'
    }),
    requestData: zRequestData,
    merchantSettings: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The custom field name.'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The custom field value.'
        })
    }).register(z.globalRegistry, {
        description: 'Merchant settings information.'
    })).register(z.globalRegistry, {
        description: 'Custom fields (for the given provider) which the merchant must fill. Each element of this array is a key-value pair.'
    })),
    connectorMetadata: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The name of the metadata to be stored in the gateway (limited to 20 characters).'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The value of the metadata stored (limited to 200 characters).'
        })
    }).register(z.globalRegistry, {
        description: 'Metadata fields information.'
    })).register(z.globalRegistry, {
        description: 'Array containing metadata fields sent from the provider to the payment gateway.'
    }))
}).register(z.globalRegistry, {
    description: 'Inbound request information.'
});

/**
 * Response data information.
 */
export const zResponseData = z.object({
    statusCode: z.int().register(z.globalRegistry, {
        description: 'Your desired status code.'
    }),
    contentType: z.string().register(z.globalRegistry, {
        description: 'Your desired content-type.'
    }),
    content: z.string().register(z.globalRegistry, {
        description: 'Your desired content body.'
    })
}).register(z.globalRegistry, {
    description: 'Response data information.'
});

/**
 * Inbound Request response body information.
 */
export const zSuccess4 = z.object({
    requestId: z.string().register(z.globalRegistry, {
        description: 'The same `requestId` sent in the request.'
    }),
    paymentId: z.string().register(z.globalRegistry, {
        description: 'The same `paymentId` sent in the request.'
    }),
    code: z.optional(z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error code to be logged.'
    })),
    message: z.optional(z.string().register(z.globalRegistry, {
        description: 'Provider\'s operation/error message to be logged.'
    })),
    responseData: zResponseData,
    connectorMetadata: z.optional(z.array(z.object({
        name: z.string().register(z.globalRegistry, {
            description: 'The name of the metadata to be stored in the gateway (limited to 20 characters).'
        }),
        value: z.string().register(z.globalRegistry, {
            description: 'The value of the metadata stored (limited to 200 characters).'
        })
    }).register(z.globalRegistry, {
        description: 'Metadata fields information.'
    })).register(z.globalRegistry, {
        description: 'Array containing metadata fields sent from the provider to the payment gateway.'
    }))
}).register(z.globalRegistry, {
    description: 'Inbound Request response body information.'
});

/**
 * Create authorization token request body information.
 */
export const zCreateAuthorizationTokenRequest = z.object({
    applicationId: z.string().register(z.globalRegistry, {
        description: 'VTEX application identifier.'
    }),
    returnUrl: z.string().register(z.globalRegistry, {
        description: 'The base URL you need to use to form the final URL when redirecting the merchant back to VTEX.'
    })
}).register(z.globalRegistry, {
    description: 'Create authorization token request body information.'
});

/**
 * Create authorization token response body information.
 */
export const zSuccess5 = z.object({
    applicationId: z.string().register(z.globalRegistry, {
        description: 'The same `applicationId` sent in the request.'
    }),
    token: z.string().register(z.globalRegistry, {
        description: 'You must generate a token that will be used to identify the same context when we redirect the merchant to your application.'
    })
}).register(z.globalRegistry, {
    description: 'Create authorization token response body information.'
});

/**
 * Get credentials response body information.
 */
export const zSuccess6 = z.object({
    applicationId: z.string().register(z.globalRegistry, {
        description: 'The same `applicationId` sent in the request.'
    }),
    appKey: z.string().register(z.globalRegistry, {
        description: 'The value we will send in the header `X-VTEX-API-AppKey` for the payment flow.'
    }),
    appToken: z.string().register(z.globalRegistry, {
        description: 'The value we will send in the header `X-VTEX-API-AppToken` for the payment flow.'
    })
}).register(z.globalRegistry, {
    description: 'Get credentials response body information.'
});

/**
 * Unique identifier created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider's `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json.
 */
export const zXProviderApiAppKey = z.string().register(z.globalRegistry, {
    description: 'Unique identifier created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json.'
});

/**
 * Unique token created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider's `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json
 */
export const zXProviderApiAppToken = z.string().register(z.globalRegistry, {
    description: 'Unique token created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json'
});

/**
 * Type of the content being sent.
 */
export const zContentType = z.string().register(z.globalRegistry, {
    description: 'Type of the content being sent.'
});

/**
 * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
 */
export const zAccept = z.string().register(z.globalRegistry, {
    description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
});

/**
 * VTEX payment identifier.
 */
export const zPaymentId = z.string().register(z.globalRegistry, {
    description: 'VTEX payment identifier.'
});

/**
 * VTEX application identifier.
 */
export const zApplicationId = z.string().register(z.globalRegistry, {
    description: 'VTEX application identifier.'
});

export const zManifestData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zCreatePaymentData = z.object({
    body: z.object({
        reference: z.string().register(z.globalRegistry, {
            description: 'Merchant\'s order reference provided by VTEX Checkout.'
        }),
        orderId: z.string().register(z.globalRegistry, {
            description: 'Merchant\'s order identifier provided by VTEX Checkout (also called order group).'
        }),
        shopperInteraction: z.string().register(z.globalRegistry, {
            description: 'Indicates which system the buyer interacted with (examples: ecommerce, instore, subscription).'
        }),
        verificationOnly: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether this payment is just to validate the buyer\'s payment method information (for instance, validate the credit card information).'
        })),
        transactionId: z.string().register(z.globalRegistry, {
            description: 'VTEX transaction ID related to this payment.'
        }),
        paymentId: z.string().register(z.globalRegistry, {
            description: 'VTEX payment ID that can be used as unique identifier.'
        }),
        paymentMethod: z.string().register(z.globalRegistry, {
            description: 'The payment method chosen for this payment. It must be one of the available payment methods offered by the provider, which can be obtained from the [List Payment Provider Manifest endpoint](https://developers.vtex.com/docs/api-reference/payment-provider-protocol#get-/manifest).'
        }),
        paymentMethodCustomCode: z.union([
            z.string(),
            z.null()
        ]),
        merchantName: z.string().register(z.globalRegistry, {
            description: 'VTEX merchant name that will receive the payment.'
        }),
        value: z.number().register(z.globalRegistry, {
            description: 'Value amount of the payment.'
        }),
        referenceValue: z.optional(z.number().register(z.globalRegistry, {
            description: 'Value amount of the payment without interest applied. This value is the same as the "value" field when "installmentsInterestRate" is 0.0.'
        })),
        currency: z.string().register(z.globalRegistry, {
            description: 'Currency code (ISO 4217 alpha-3).'
        }),
        installments: z.number().register(z.globalRegistry, {
            description: 'Number of installments.'
        }),
        installmentsInterestRate: z.optional(z.number().register(z.globalRegistry, {
            description: 'The interest rate.'
        })),
        installmentsValue: z.optional(z.number().register(z.globalRegistry, {
            description: 'The value of each installment.'
        })),
        deviceFingerprint: z.string().register(z.globalRegistry, {
            description: 'A hash that represents the device used to initiate the payment.'
        }),
        ipAddress: z.optional(z.string().register(z.globalRegistry, {
            description: 'The IP Address of the buyer.'
        })),
        card: z.optional(z.object({
            holder: z.union([
                z.string(),
                z.null()
            ]),
            holderToken: z.optional(z.string().register(z.globalRegistry, {
                description: 'A token representing the card holder (this field is absent in case the provider does not use the [Secure Proxy](https://developers.vtex.com/docs/guides/payments-integration-secure-proxy)).'
            })),
            number: z.union([
                z.string(),
                z.null()
            ]),
            csc: z.union([
                z.string(),
                z.null()
            ]),
            bin: z.optional(z.string().register(z.globalRegistry, {
                description: 'First six digits of the card number (this field is absent in case the provider does not use the [Secure Proxy](https://developers.vtex.com/docs/guides/payments-integration-secure-proxy)).'
            })),
            numberToken: z.optional(z.string().register(z.globalRegistry, {
                description: 'A token representing the card number (this field is absent in case the provider does not use the [Secure Proxy](https://developers.vtex.com/docs/guides/payments-integration-secure-proxy)).'
            })),
            numberLength: z.optional(z.number().register(z.globalRegistry, {
                description: 'The number of characters in the card number (this field is absent in case the provider does not use the [Secure Proxy](https://developers.vtex.com/docs/guides/payments-integration-secure-proxy)).'
            })),
            cscToken: z.optional(z.string().register(z.globalRegistry, {
                description: 'A token representing the card security code (this field is absent in case the provider does not use the [Secure Proxy](https://developers.vtex.com/docs/guides/payments-integration-secure-proxy)).'
            })),
            cscLength: z.optional(z.number().register(z.globalRegistry, {
                description: 'The number of characters in the Card Security Code (this field is absent in case the provider does not use the [Secure Proxy](https://developers.vtex.com/docs/guides/payments-integration-secure-proxy)).'
            })),
            expiration: z.object({
                month: z.union([
                    z.string(),
                    z.null()
                ]),
                year: z.union([
                    z.string(),
                    z.null()
                ])
            }).register(z.globalRegistry, {
                description: 'Information about card expiration.'
            }),
            document: z.optional(z.string().register(z.globalRegistry, {
                description: 'Card holder\'s document.'
            })),
            paymentOrigin: z.optional(z.string().register(z.globalRegistry, {
                description: 'Identifies the type of wallet used in the payment. Please contact our [VTEX Support](https://help.vtex.com/support) to enable this field in your account.'
            })),
            cryptogram: z.optional(z.string().register(z.globalRegistry, {
                description: '3DS cryptogram information (available only for payments transactions with DPAN cards). Please contact our [VTEX Support](https://help.vtex.com/support) to enable this field in your account.'
            })),
            eci: z.optional(z.string().register(z.globalRegistry, {
                description: '[Electronic Commerce Indicator](https://support.midtrans.com/hc/en-us/articles/204161150-What-is-ECI-on-3DS-protocol-). This value indicates the result of the authentication attempt on transactions enforced by the 3DS (available only for payments transactions with DPAN cards). Please contact our [VTEX Support](https://help.vtex.com/support) to enable this field in your account.'
            }))
        }).register(z.globalRegistry, {
            description: 'Card information used for payment. This parameter is required only with card payment methods (credit, debit or co-branded).'
        })),
        miniCart: z.object({
            shippingValue: z.number().register(z.globalRegistry, {
                description: 'Total shipping value.'
            }),
            taxValue: z.number().register(z.globalRegistry, {
                description: 'Total tax value.'
            }),
            buyer: z.object({
                id: z.optional(z.string().register(z.globalRegistry, {
                    description: 'Buyer\'s unique identifier.'
                })),
                firstName: z.string().register(z.globalRegistry, {
                    description: 'Buyer\'s first name.'
                }),
                lastName: z.string().register(z.globalRegistry, {
                    description: 'Buyer\'s last name.'
                }),
                document: z.union([
                    z.string(),
                    z.null()
                ]),
                documentType: z.union([
                    z.string(),
                    z.null()
                ]),
                email: z.string().register(z.globalRegistry, {
                    description: 'Buyer\'s email.'
                }),
                phone: z.string().register(z.globalRegistry, {
                    description: 'Buyer\'s phone number.'
                }),
                isCorporate: z.optional(z.boolean().register(z.globalRegistry, {
                    description: 'Indicates whether or not the buyer is corporate. If `true`, the fields `corporateName`, `tradeName` and `corporateDocument` are required.'
                })),
                corporateName: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                tradeName: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                corporateDocument: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                createdDate: z.optional(z.string().register(z.globalRegistry, {
                    description: 'Date when the buyer\'s profile was created in yyyy-MM-ddTHH:mm:ss format.'
                }))
            }).register(z.globalRegistry, {
                description: 'Buyer information.'
            }),
            shippingAddress: z.object({
                country: z.string().register(z.globalRegistry, {
                    description: 'Shipping address country code (ISO 3166 alpha-3).'
                }),
                street: z.string().register(z.globalRegistry, {
                    description: 'Shipping address street.'
                }),
                number: z.string().register(z.globalRegistry, {
                    description: 'Shipping address number.'
                }),
                complement: z.optional(z.string().register(z.globalRegistry, {
                    description: 'Shipping address complement.'
                })),
                neighborhood: z.string().register(z.globalRegistry, {
                    description: 'Shipping address neighborhood.'
                }),
                postalCode: z.string().register(z.globalRegistry, {
                    description: 'Shipping address postal code.'
                }),
                city: z.string().register(z.globalRegistry, {
                    description: 'Shipping address city.'
                }),
                state: z.string().register(z.globalRegistry, {
                    description: 'Shipping address state/province.'
                })
            }).register(z.globalRegistry, {
                description: 'Information about the address where the purchase will be delivered.'
            }),
            billingAddress: z.object({
                country: z.string().register(z.globalRegistry, {
                    description: 'Billing address country code (ISO 3166 alpha-3).'
                }),
                street: z.string().register(z.globalRegistry, {
                    description: 'Billing address street.'
                }),
                number: z.string().register(z.globalRegistry, {
                    description: 'Billing address number.'
                }),
                complement: z.optional(z.string().register(z.globalRegistry, {
                    description: 'Billing address complement.'
                })),
                neighborhood: z.string().register(z.globalRegistry, {
                    description: 'Billing address neighborhood.'
                }),
                postalCode: z.string().register(z.globalRegistry, {
                    description: 'Billing address postal code.'
                }),
                city: z.string().register(z.globalRegistry, {
                    description: 'Billing address city.'
                }),
                state: z.string().register(z.globalRegistry, {
                    description: 'Billing address state/province.'
                })
            }).register(z.globalRegistry, {
                description: 'Buyer\'s billing address information.'
            }),
            items: z.array(z.object({
                id: z.string().register(z.globalRegistry, {
                    description: 'Item identifier.'
                }),
                name: z.string().register(z.globalRegistry, {
                    description: 'Item name.'
                }),
                price: z.number().register(z.globalRegistry, {
                    description: 'Item price per unity.'
                }),
                quantity: z.int().register(z.globalRegistry, {
                    description: 'Item quantity.'
                }),
                discount: z.int().register(z.globalRegistry, {
                    description: 'Discount received for the item.'
                }),
                deliveryType: z.optional(z.string().register(z.globalRegistry, {
                    description: 'The delivery SLA selected for this item. Possible values in Brazil, for instance, are PAC, SEDEX.'
                })),
                categoryId: z.optional(z.string().register(z.globalRegistry, {
                    description: 'The item category Id.'
                })),
                sellerId: z.optional(z.string().register(z.globalRegistry, {
                    description: 'In case of a marketplace transaction, this is the Id of the seller for this specific item. Otherwise, this is filled with a \'1\'.'
                })),
                taxRate: z.optional(z.number().register(z.globalRegistry, {
                    description: 'Value of the sum of all Taxes applied to each item. Rates are in percentage, so 5% is represented as 0.05.'
                })),
                taxValue: z.optional(z.number().register(z.globalRegistry, {
                    description: 'Total Tax value of the item (taxRate times value).'
                }))
            }).register(z.globalRegistry, {
                description: 'Cart items information.'
            })).register(z.globalRegistry, {
                description: 'Items of the cart of the purchase.'
            })
        }).register(z.globalRegistry, {
            description: 'Minicart information.'
        }),
        recipients: z.optional(z.array(z.object({
            id: z.string().register(z.globalRegistry, {
                description: 'Recipient identifier.'
            }),
            name: z.string().register(z.globalRegistry, {
                description: 'Recipient name.'
            }),
            documentType: z.string().register(z.globalRegistry, {
                description: 'Recipient document type.'
            }),
            document: z.string().register(z.globalRegistry, {
                description: 'Recipient document number.'
            }),
            role: z.string().register(z.globalRegistry, {
                description: 'Indicates if the recipient is the seller or the marketplace.'
            }),
            chargeProcessingFee: z.optional(z.boolean().register(z.globalRegistry, {
                description: 'Indicates whether or not this recipient is charged for processing fees.'
            })),
            chargebackLiable: z.optional(z.boolean().register(z.globalRegistry, {
                description: 'Indicates whether or not this recipient is liable to chargebacks.'
            })),
            amount: z.number().register(z.globalRegistry, {
                description: 'Amount due to this recipient.'
            }),
            comissionAmount: z.optional(z.number().register(z.globalRegistry, {
                description: 'Amount received by the Marketplace.'
            }))
        }).register(z.globalRegistry, {
            description: 'Recipients information.'
        })).register(z.globalRegistry, {
            description: 'Array containing the information for the recipients of this payment in case the Payment Provider is configured to allow the split of payments.'
        })),
        merchantSettings: z.optional(z.array(z.object({
            name: z.string().register(z.globalRegistry, {
                description: 'Custom field name.'
            }),
            value: z.string().register(z.globalRegistry, {
                description: 'Custom field value.'
            })
        }).register(z.globalRegistry, {
            description: 'Merchant settings information.'
        })).register(z.globalRegistry, {
            description: 'Custom fields (for the given Provider) which the merchant must fill. Each element of this array is a key-value pair.'
        })),
        url: z.string().register(z.globalRegistry, {
            description: 'The order URL from merchant\'s backoffice.'
        }),
        inboundRequestUrl: z.optional(z.string().register(z.globalRegistry, {
            description: 'The URL to call for the Inbound Request (BETA).'
        })),
        secureProxyUrl: z.optional(z.string().register(z.globalRegistry, {
            description: 'The URL for the [Secure Proxy](https://developers.vtex.com/docs/guides/payments-integration-secure-proxy) to authorize the Payment (this field is absent in case the provider does not use the Secure Proxy).'
        })),
        sandBoxMode: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether or not this request is being sent from a sandbox environment.'
        })),
        totalCartValue: z.optional(z.number().register(z.globalRegistry, {
            description: 'Total amount of the shopping cart that this payment is part of. It can be used together with the value to calculate the percentage that this payment represents of the total.'
        })),
        callbackUrl: z.string().register(z.globalRegistry, {
            description: 'The URL you need to call to send the callbacks (notification or retry) of payment status changes.'
        }),
        returnUrl: z.string().register(z.globalRegistry, {
            description: 'The URL you need to redirect the end user back to merchant\'s store when using the redirect flow.'
        }),
        connectorMetadata: z.optional(z.array(z.object({
            name: z.string().register(z.globalRegistry, {
                description: 'The name of the metadata to be stored in the gateway (limited to 20 characters).'
            }),
            value: z.string().register(z.globalRegistry, {
                description: 'The value of the metadata stored (limited to 200 characters).'
            })
        }).register(z.globalRegistry, {
            description: 'Metadata field information.'
        })).register(z.globalRegistry, {
            description: 'Array containing metadata fields sent from the provider to the payment gateway.'
        }))
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'X-PROVIDER-API-AppKey': z.string().register(z.globalRegistry, {
            description: 'Unique identifier created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json.'
        }),
        'X-PROVIDER-API-AppToken': z.string().register(z.globalRegistry, {
            description: 'Unique token created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zCancelPaymentData = z.object({
    body: zCancelPaymentRequest,
    path: z.object({
        paymentId: z.string().register(z.globalRegistry, {
            description: 'VTEX payment identifier.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'X-PROVIDER-API-AppKey': z.string().register(z.globalRegistry, {
            description: 'Unique identifier created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json.'
        }),
        'X-PROVIDER-API-AppToken': z.string().register(z.globalRegistry, {
            description: 'Unique token created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zSettlePaymentData = z.object({
    body: zSettlePayment,
    path: z.object({
        paymentId: z.string().register(z.globalRegistry, {
            description: 'VTEX payment identifier.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'X-PROVIDER-API-AppKey': z.string().register(z.globalRegistry, {
            description: 'Unique identifier created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json.'
        }),
        'X-PROVIDER-API-AppToken': z.string().register(z.globalRegistry, {
            description: 'Unique token created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zRefundPaymentData = z.object({
    body: zRefundPayment,
    path: z.object({
        paymentId: z.string().register(z.globalRegistry, {
            description: 'VTEX payment identifier.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'X-PROVIDER-API-AppKey': z.string().register(z.globalRegistry, {
            description: 'Unique identifier created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json.'
        }),
        'X-PROVIDER-API-AppToken': z.string().register(z.globalRegistry, {
            description: 'Unique token created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zInboundRequestBetaData = z.object({
    body: zInboundRequestBetaRequest,
    path: z.object({
        paymentId: z.string().register(z.globalRegistry, {
            description: 'VTEX payment identifier.'
        }),
        action: z.string().register(z.globalRegistry, {
            description: 'Describes the type of action that will be performed on the route (e.g. hook, enrollment, among others). It is the same `:action` information used in the `inboundRequestsUrl` provided in the [Create Payment](https://developers.vtex.com/docs/api-reference/payment-provider-protocol#post-/payments?endpoint=post-/payments) endpoint payload.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'X-PROVIDER-API-AppKey': z.string().register(z.globalRegistry, {
            description: 'Unique identifier created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json.'
        }),
        'X-PROVIDER-API-AppToken': z.string().register(z.globalRegistry, {
            description: 'Unique token created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zCreateAuthorizationTokenData = z.object({
    body: zCreateAuthorizationTokenRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'X-PROVIDER-API-AppKey': z.string().register(z.globalRegistry, {
            description: 'Unique identifier created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json.'
        }),
        'X-PROVIDER-API-AppToken': z.string().register(z.globalRegistry, {
            description: 'Unique token created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zProviderAuthenticationData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        applicationId: z.string().register(z.globalRegistry, {
            description: 'VTEX application identifier.'
        }),
        token: z.string().register(z.globalRegistry, {
            description: 'You must generate a token that will be used to identify the same context when we redirect the merchant to your application.'
        })
    }),
    headers: z.object({
        'X-PROVIDER-API-AppKey': z.string().register(z.globalRegistry, {
            description: 'Unique identifier created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json.'
        }),
        'X-PROVIDER-API-AppToken': z.string().register(z.globalRegistry, {
            description: 'Unique token created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zGetCredentialsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        applicationId: z.string().register(z.globalRegistry, {
            description: 'VTEX application identifier.'
        }),
        authorizationCode: z.string().register(z.globalRegistry, {
            description: 'Code generate by affiliation that will be used to identify the merchant authorization.'
        })
    }),
    headers: z.object({
        'X-PROVIDER-API-AppKey': z.string().register(z.globalRegistry, {
            description: 'Unique identifier created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json.'
        }),
        'X-PROVIDER-API-AppToken': z.string().register(z.globalRegistry, {
            description: 'Unique token created by the provider and configured on the provider configuration page (Admin VTEX). To use this header as authorization, check that the `usesProviderHeadersName` field is set to `true` in the payment provider\'s `configuration.json`. To check the `configuration.json` file, access the route {{connector}}/paymentProvider/configuration.json'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        })
    })
});

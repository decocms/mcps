// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod';

/**
 * Object representing licenses.
 */
export const zLicenseItems = z.object({
    expiration: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    id: z.optional(z.number().register(z.globalRegistry, {
        description: 'ID of the category of the license.'
    })),
    isPurchased: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines if the license is purchased (`true`) or not (`false`).'
    })),
    products: z.optional(z.array(z.object({
        id: z.optional(z.number().register(z.globalRegistry, {
            description: 'ID of the product.'
        })),
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Name of the product.'
        })),
        domains: z.optional(z.array(z.string().register(z.globalRegistry, {
            description: 'Domain of the product.'
        })).register(z.globalRegistry, {
            description: 'List of domains of the product.'
        })),
        endpoints: z.optional(z.object({
            webApiUrl: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            consoleUrl: z.optional(z.union([
                z.string(),
                z.null()
            ]))
        }).register(z.globalRegistry, {
            description: 'Endpoints.'
        }))
    }).register(z.globalRegistry, {
        description: 'Object representing products of licenses.'
    })).register(z.globalRegistry, {
        description: 'Array of products.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the category of the license.'
    }))
}).register(z.globalRegistry, {
    description: 'Object representing licenses.'
});

/**
 * Object containing complete information from a store.
 */
export const zSiteItems = z.object({
    id: z.optional(z.number().register(z.globalRegistry, {
        description: 'ID of the store.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Store name.'
    })),
    tradingName: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trading name of the store.'
    })),
    LV: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    logo: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    monetaryUnitId: z.optional(z.number().register(z.globalRegistry, {
        description: 'Monetary unit ID.'
    })),
    domains: z.optional(z.union([
        z.array(z.string().register(z.globalRegistry, {
            description: 'Domain.'
        })),
        z.null()
    ])),
    hosts: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Host address.'
    })).register(z.globalRegistry, {
        description: 'Hosts associated to the store.'
    })),
    aliases: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Alias.'
    })).register(z.globalRegistry, {
        description: 'Aliases.'
    }))
}).register(z.globalRegistry, {
    description: 'Object containing complete information from a store.'
});

/**
 * Object representing application keys.
 */
export const zAppKeyItems = z.object({
    id: z.optional(z.string().register(z.globalRegistry, {
        description: 'ID of the API key.'
    })),
    appKey: z.optional(z.string().register(z.globalRegistry, {
        description: 'API key.'
    })),
    appToken: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    label: z.optional(z.string().register(z.globalRegistry, {
        description: 'Label of the API key.'
    })),
    createdIn: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'Creation date of the API key.'
    })),
    isActive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines if the API key is active (`true`) or not (`false`).'
    })),
    isBlocked: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines if the API key is blocked (`true`) or not (`false`).'
    }))
}).register(z.globalRegistry, {
    description: 'Object representing application keys.'
});

/**
 * Successful response for `/api/vlm/account`.
 */
export const zAccountResponse = z.object({
    isActive: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines if the account is active (`true`) or not (`false`).'
    })),
    id: z.optional(z.string().register(z.globalRegistry, {
        description: 'ID of the account.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trading name.'
    })),
    accountName: z.optional(z.string().register(z.globalRegistry, {
        description: 'Account name.'
    })),
    lv: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    isOperating: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines if the account is in production (`true`) or not (`false`).'
    })),
    defaultUrl: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    district: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    country: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    complement: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    companyName: z.optional(z.string().register(z.globalRegistry, {
        description: 'Company name.'
    })),
    cnpj: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    haveParentAccount: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines if the account has a parent account (`true`) or not (`false`).'
    })),
    parentAccountId: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    parentAccountName: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    city: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    address: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    logo: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    hasLogo: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines if the store\'s logotype has been uploaded (`true`) or not (`false`).'
    })),
    number: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    postalCode: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    state: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    telephone: z.optional(z.string().register(z.globalRegistry, {
        description: 'Telephone number of the person assigned as main contact of the store.'
    })),
    tradingName: z.optional(z.string().register(z.globalRegistry, {
        description: 'Trading name.'
    })),
    licenses: z.optional(z.array(zLicenseItems).register(z.globalRegistry, {
        description: 'Licenses of the account.'
    })),
    sponsor: z.optional(z.object({
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Name of the sponsor user.'
        })),
        email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Email of the sponsor user.'
        })),
        phone: z.optional(z.string().register(z.globalRegistry, {
            description: 'Phone of the sponsor user.'
        }))
    }).register(z.globalRegistry, {
        description: 'Object with information about the sponsor user.'
    })),
    contact: z.optional(z.object({
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Name of the person assigned as main contact of the store.'
        })),
        email: z.optional(z.string().register(z.globalRegistry, {
            description: 'Email of the person assigned as main contact of the store.'
        })),
        phone: z.optional(z.string().register(z.globalRegistry, {
            description: 'Telephone number of the person assigned as main contact of the store.'
        }))
    }).register(z.globalRegistry, {
        description: 'Information about the person assigned as main contact of the store.'
    })),
    operationDate: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    inactivationDate: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    creationDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'Date when the account was created.'
    })),
    hosts: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Host address.'
    })).register(z.globalRegistry, {
        description: 'Hosts of all stores.'
    })),
    sites: z.optional(z.array(zSiteItems).register(z.globalRegistry, {
        description: 'Array of objects representing each store.'
    })),
    appKey: z.optional(z.object({
        token: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        name: z.optional(z.union([
            z.string(),
            z.null()
        ]))
    }).register(z.globalRegistry, {
        description: 'Deprecated. Check the `appKeys` object for all API keys.'
    })),
    appKeys: z.optional(z.array(zAppKeyItems).register(z.globalRegistry, {
        description: 'Array of application keys.'
    }))
}).register(z.globalRegistry, {
    description: 'Successful response for `/api/vlm/account`.'
});

/**
 * Request body for creating users.
 */
export const zCreateUserRequest = z.object({
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the user.'
    })),
    email: z.string().register(z.globalRegistry, {
        description: 'Email of the user.'
    })
}).register(z.globalRegistry, {
    description: 'Request body for creating users.'
});

/**
 * Request body for creating new API key (/api/vlm/appkeys)
 */
export const zCreatenewappkeyRequest = z.object({
    label: z.string().register(z.globalRegistry, {
        description: 'Label of the API key.'
    })
}).register(z.globalRegistry, {
    description: 'Request body for creating new API key (/api/vlm/appkeys)'
});

/**
 * Response body of sucessful call to /api/vlm/appkeys.
 */
export const zCreatenewappkeyResponse = z.object({
    id: z.string().register(z.globalRegistry, {
        description: 'ID of the API key.'
    }),
    appKey: z.string().register(z.globalRegistry, {
        description: 'AppKey.'
    }),
    appToken: z.union([
        z.string(),
        z.null()
    ]),
    label: z.string().register(z.globalRegistry, {
        description: 'Label of the API key.'
    }),
    createdIn: z.iso.datetime().register(z.globalRegistry, {
        description: 'Creation date of the API key.'
    }),
    isActive: z.boolean().register(z.globalRegistry, {
        description: 'Defines if the API key is active (`true`) or not (`false`).'
    })
}).register(z.globalRegistry, {
    description: 'Response body of sucessful call to /api/vlm/appkeys.'
});

/**
 * Request body for activating or deactivating application keys.
 */
export const zUpdateappkeyRequest = z.object({
    isActive: z.boolean().register(z.globalRegistry, {
        description: 'Defines if the API key is active (`true`) or not (`false`).'
    })
}).register(z.globalRegistry, {
    description: 'Request body for activating or deactivating application keys.'
});

/**
 * Response body for getting all application keys from the account.
 */
export const zGetappkeysfromaccount = z.object({
    id: z.string().register(z.globalRegistry, {
        description: 'ID of the API key.'
    }),
    appKey: z.string().register(z.globalRegistry, {
        description: 'API key.'
    }),
    label: z.string().register(z.globalRegistry, {
        description: 'Label of the API key.'
    }),
    createdIn: z.iso.datetime().register(z.globalRegistry, {
        description: 'Creation date of the API key.'
    }),
    isActive: z.boolean().register(z.globalRegistry, {
        description: 'Defines if the API key is active (`true`) or not (`false`).'
    })
}).register(z.globalRegistry, {
    description: 'Response body for getting all application keys from the account.'
});

/**
 * Paging object.
 */
export const zPaging = z.object({
    page: z.int().register(z.globalRegistry, {
        description: 'Current page number.'
    }),
    perPage: z.int().register(z.globalRegistry, {
        description: 'Items per page.'
    }),
    total: z.int().register(z.globalRegistry, {
        description: 'Total of items.'
    }),
    pages: z.int().register(z.globalRegistry, {
        description: 'Total of pages.'
    })
}).register(z.globalRegistry, {
    description: 'Paging object.'
});

/**
 * Object with information about an user.
 */
export const zUserItems = z.object({
    id: z.optional(z.string().register(z.globalRegistry, {
        description: 'ID of the user.'
    })),
    email: z.optional(z.string().register(z.globalRegistry, {
        description: 'Email of the user.'
    })),
    isAdmin: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines if the user has administrative access (`true`) or not (`false`).'
    })),
    isReliable: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'For internal use only.'
    })),
    isBlocked: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines if the user is blocked (`true`) or not (`false`).'
    })),
    roles: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Role ID.'
    })).register(z.globalRegistry, {
        description: 'Array of user roles. This field is deprecated and should always be empty.'
    })),
    accountNames: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Account names.'
    })).register(z.globalRegistry, {
        description: 'Array of account names.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the user.'
    }))
}).register(z.globalRegistry, {
    description: 'Object with information about an user.'
});

/**
 * Response body for listing all users.
 */
export const zListUsersResponse = z.object({
    items: z.optional(z.array(zUserItems).register(z.globalRegistry, {
        description: 'Array of user objects.'
    })),
    paging: z.optional(zPaging)
}).register(z.globalRegistry, {
    description: 'Response body for listing all users.'
});

/**
 * Object representing License Manager products.
 */
export const zProductItems = z.object({
    id: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    categoryId: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    categoryName: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    description: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    consoleUrlMask: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    urlConfiguration: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    webApiUrlMask: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    url: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    productResources: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the License Manager product.'
    }))
}).register(z.globalRegistry, {
    description: 'Object representing License Manager products.'
});

/**
 * Object with information about a role.
 */
export const zRoleItems = z.object({
    id: z.optional(z.int().register(z.globalRegistry, {
        description: 'ID of the role.'
    })),
    isAdmin: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Defines if the role has administrative access (`true`) or not (`false`).'
    })),
    roleType: z.optional(z.int().register(z.globalRegistry, {
        description: 'Returns `1` for custom roles, and `0` for predefined roles.'
    })),
    products: z.optional(z.array(zProductItems).register(z.globalRegistry, {
        description: 'Array of License Manager product objects.'
    })),
    resources: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    logins: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the role.'
    }))
}).register(z.globalRegistry, {
    description: 'Object with information about a role.'
});

/**
 * Response body for listing all roles.
 */
export const zListRolesResponse = z.object({
    items: z.optional(z.array(zRoleItems).register(z.globalRegistry, {
        description: 'Array of role objects.'
    })),
    paging: z.optional(zPaging)
}).register(z.globalRegistry, {
    description: 'Response body for listing all roles.'
});

/**
 * Object containing summarized information from a store.
 */
export const zStoreItems = z.object({
    id: z.optional(z.number().register(z.globalRegistry, {
        description: 'ID of the store.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the store.'
    })),
    hosts: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Host address.'
    })).register(z.globalRegistry, {
        description: 'Array of hosts corresponding to the store.'
    }))
}).register(z.globalRegistry, {
    description: 'Object containing summarized information from a store.'
});

/**
 * Object representing VLMError.
 */
export const zVlmError = z.object({
    Details: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    HttpStatusCode: z.optional(z.int().register(z.globalRegistry, {
        description: 'Status code of HTTP response.'
    })),
    VLMErrorCode: z.optional(z.int().register(z.globalRegistry, {
        description: 'Error code for License Manager.'
    })),
    Message: z.optional(z.string().register(z.globalRegistry, {
        description: 'Error message.'
    }))
}).register(z.globalRegistry, {
    description: 'Object representing VLMError.'
});

/**
 * Type of the content being sent.
 */
export const zContentType = z.string().register(z.globalRegistry, {
    description: 'Type of the content being sent.'
}).default('application/json');

/**
 * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
 */
export const zAccept = z.string().register(z.globalRegistry, {
    description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
}).default('application/json');

export const zDeleteApiLicenseManagerUsersByUserIdData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        userId: z.string().register(z.globalRegistry, {
            description: 'ID from queried user.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zGetUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        userId: z.string().register(z.globalRegistry, {
            description: 'ID from queried user.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zCreateUserData = z.object({
    body: zCreateUserRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGetListUsersData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        numItems: z.optional(z.int().register(z.globalRegistry, {
            description: 'Number of items in the returned page.'
        })),
        pageNumber: z.optional(z.int().register(z.globalRegistry, {
            description: 'Which page from the whole list will be returned.'
        })),
        sort: z.optional(z.string().register(z.globalRegistry, {
            description: 'Chooses the field that the list will be sorted by.'
        })),
        sortType: z.optional(z.string().register(z.globalRegistry, {
            description: 'Defines the sorting order. `ASC` is used for ascendant order. `DSC` is used for descendant order.'
        }))
    })),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zGetRolesbyUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        userId: z.string().register(z.globalRegistry, {
            description: 'ID of the user.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zPutRolesinUserData = z.object({
    body: z.array(z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'Role ID, which can be obtained from the [Get List of Roles](https://developers.vtex.com/docs/api-reference/license-manager-api#get-/api/license-manager/site/pvt/roles/list/paged) endpoint.'
    })).register(z.globalRegistry, {
        description: 'Array containing role IDs.'
    }),
    path: z.object({
        userId: z.string().register(z.globalRegistry, {
            description: 'ID of the user.'
        })
    }),
    query: z.optional(z.never())
});

export const zGetRolesbyUser2Data = z.object({
    body: z.optional(z.never()),
    path: z.object({
        userEmail: z.string().register(z.globalRegistry, {
            description: 'Email of the user.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zRemoveRolefromUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        userId: z.string().register(z.globalRegistry, {
            description: 'ID of the user.'
        }),
        roleId: z.string().register(z.globalRegistry, {
            description: 'ID of the role which will be removed from the user.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zGetListRolesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        numItems: z.optional(z.int().register(z.globalRegistry, {
            description: 'Number of items in the returned page.'
        })),
        pageNumber: z.optional(z.int().register(z.globalRegistry, {
            description: 'Which page from the whole list will be returned.'
        })),
        sort: z.optional(z.string().register(z.globalRegistry, {
            description: 'Chooses the field that the list will be sorted by.'
        })),
        sortType: z.optional(z.string().register(z.globalRegistry, {
            description: 'Defines the sorting order. `ASC` is used for ascendant order. `DSC` is used for descendant order.'
        }))
    })),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zGetappkeysfromaccountData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zCreatenewappkeyData = z.object({
    body: zCreatenewappkeyRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zUpdateappkeyData = z.object({
    body: zUpdateappkeyRequest,
    path: z.object({
        id: z.string().register(z.globalRegistry, {
            description: 'ID from the API Key which will be updated'
        })
    }),
    query: z.optional(z.never())
});

export const zGetByAccountData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGetAccountData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

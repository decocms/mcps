// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod';

/**
 * Object that represents the capacity information for a fulfillment location, including its identifier, account details, and availability window.
 */
export const zLocationCapacity = z.object({
    locationId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Unique identifier for the location.'
    })),
    accountName: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the account associated with the location.'
    })),
    accountId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Identifier for the VTEX account.'
    })),
    availability: z.optional(z.object({
        amountUsagePercentage: z.optional(z.number().register(z.globalRegistry, {
            description: 'Percentage of capacity currently in use.'
        })),
        startAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
            description: 'Start time of the availability period.'
        })),
        endAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
            description: 'End time of the availability period.'
        }))
    }).register(z.globalRegistry, {
        description: 'Availability details including usage percentage and time window.'
    })),
    firstShiftAhead: z.optional(z.object({
        amountPercentage: z.optional(z.number().register(z.globalRegistry, {
            description: 'Percentage of capacity used.'
        })),
        capacityLimitAmount: z.optional(z.int().register(z.globalRegistry, {
            description: 'Maximum capacity amount for the day.'
        })),
        capacityUsageAmount: z.optional(z.int().register(z.globalRegistry, {
            description: 'Capacity amount used for the day.'
        })),
        startAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
            description: 'Start time for the capacity period.'
        })),
        endAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
            description: 'End time for the capacity period.'
        }))
    }).register(z.globalRegistry, {
        description: 'First shift ahead.'
    })),
    secondShiftAhead: z.optional(z.object({
        amountPercentage: z.optional(z.number().register(z.globalRegistry, {
            description: 'Percentage of capacity used.'
        })),
        capacityLimitAmount: z.optional(z.int().register(z.globalRegistry, {
            description: 'Maximum capacity amount for the day.'
        })),
        capacityUsageAmount: z.optional(z.int().register(z.globalRegistry, {
            description: 'Capacity amount used for the day.'
        })),
        startAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
            description: 'Start time for the capacity period.'
        })),
        endAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
            description: 'End time for the capacity period.'
        }))
    }).register(z.globalRegistry, {
        description: 'Second shift ahead.'
    })),
    thirdShiftAhead: z.optional(z.object({
        amountPercentage: z.optional(z.number().register(z.globalRegistry, {
            description: 'Percentage of capacity used.'
        })),
        capacityLimitAmount: z.optional(z.int().register(z.globalRegistry, {
            description: 'Maximum capacity amount for the day.'
        })),
        capacityUsageAmount: z.optional(z.int().register(z.globalRegistry, {
            description: 'Capacity amount used for the day.'
        })),
        startAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
            description: 'Start time for the capacity period.'
        })),
        endAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
            description: 'End time for the capacity period.'
        }))
    }).register(z.globalRegistry, {
        description: 'Third shift ahead.'
    }))
}).register(z.globalRegistry, {
    description: 'Object that represents the capacity information for a fulfillment location, including its identifier, account details, and availability window.'
});

/**
 * Configuration settings for a location's operational capacity including type, unit, full capacity action, maximum allowed increase promise, and daily capacity settings.
 */
export const zCapacityConfigurationRequest = z.object({
    capacityType: z.optional(z.enum(['FIXED', 'UNLIMITED']).register(z.globalRegistry, {
        description: 'Type of capacity.'
    })),
    capacityUnit: z.optional(z.enum(['ORDERS', 'ORDER_ITEMS']).register(z.globalRegistry, {
        description: 'Unit of capacity.'
    })),
    fullCapacityAction: z.optional(z.enum(['PAUSE', 'MOVE_TO_NEXT_SHIFT']).register(z.globalRegistry, {
        description: 'Action to take when full capacity is reached.'
    })),
    maxIncreasePromise: z.optional(z.object({
        amount: z.optional(z.int().lte(18).register(z.globalRegistry, {
            description: 'Maximum number of additional capacity units allowed.'
        }))
    }).register(z.globalRegistry, {
        description: 'Defines the maximum allowed increase in the delivery promise.'
    })),
    dayCapacity: z.optional(z.object({
        MONDAY: z.optional(z.int().register(z.globalRegistry, {
            description: 'Capacity setting for Monday.'
        })),
        TUESDAY: z.optional(z.int().register(z.globalRegistry, {
            description: 'Capacity setting for Tuesday.'
        })),
        WEDNESDAY: z.optional(z.int().register(z.globalRegistry, {
            description: 'Capacity setting for Wednesday.'
        })),
        THURSDAY: z.optional(z.int().register(z.globalRegistry, {
            description: 'Capacity setting for Thursday.'
        })),
        FRIDAY: z.optional(z.int().register(z.globalRegistry, {
            description: 'Capacity setting for Friday.'
        })),
        SATURDAY: z.optional(z.int().register(z.globalRegistry, {
            description: 'Capacity setting for Saturday.'
        })),
        SUNDAY: z.optional(z.int().register(z.globalRegistry, {
            description: 'Capacity setting for Sunday.'
        })),
        HOLIDAYS_AND_EXCEPTIONS: z.optional(z.int().register(z.globalRegistry, {
            description: 'Capacity setting for holidays and exceptions.'
        }))
    }).register(z.globalRegistry, {
        description: 'Capacity settings for each day of the week and exceptions.'
    }))
}).register(z.globalRegistry, {
    description: 'Configuration settings for a location\'s operational capacity including type, unit, full capacity action, maximum allowed increase promise, and daily capacity settings.'
});

export const zCapacityConfigurationResponse = z.object({
    id: z.optional(z.int().register(z.globalRegistry, {
        description: 'Unique identifier of the capacity rule.'
    })),
    capacityType: z.optional(z.enum(['FIXED', 'UNLIMITED']).register(z.globalRegistry, {
        description: 'Type of capacity.'
    })),
    capacityUnit: z.optional(z.enum(['ORDERS', 'ORDER_ITEMS']).register(z.globalRegistry, {
        description: 'Unit of capacity.'
    })),
    fullCapacityAction: z.optional(z.enum(['PAUSE', 'MOVE_TO_NEXT_SHIFT']).register(z.globalRegistry, {
        description: 'Action to take when full capacity is reached.'
    })),
    taskId: z.optional(z.int().register(z.globalRegistry, {
        description: 'Unique identifier of the task.'
    })),
    locationTask: z.optional(z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ])),
    capacityShifts: z.optional(z.array(z.object({
        id: z.optional(z.int().register(z.globalRegistry, {
            description: 'Unique identifier of the capacity shift.'
        })),
        capacityAmount: z.optional(z.int().register(z.globalRegistry, {
            description: 'Amount of product avaiable in the capacity shift.'
        })),
        capacityRuleId: z.optional(z.int().register(z.globalRegistry, {
            description: 'Unique identifier of the capacity rule. This is the same ID value in `id` field.'
        })),
        timeStart: z.optional(z.string().register(z.globalRegistry, {
            description: 'Start time for the capacity period in the format `HH:MM:SS`.'
        })),
        timeEnd: z.optional(z.string().register(z.globalRegistry, {
            description: 'time for the capacity period in the format `HH:MM:SS`.'
        })),
        weekDay: z.optional(z.enum([
            'MONDAY',
            'TUESDAY',
            'WEDNESDAY',
            'THURSDAY',
            'FRIDAY',
            'SATURDAY',
            'SUNDAY',
            'HOLIDAYS_AND_EXCEPTIONS'
        ]).register(z.globalRegistry, {
            description: 'Day of the week.'
        }))
    }).register(z.globalRegistry, {
        description: 'Object cointaing capacity shift information.'
    })).register(z.globalRegistry, {
        description: 'List of capacity shifts of the location.'
    })),
    additionalInfo: z.optional(z.object({
        maxIncreasePromise: z.optional(z.object({
            amount: z.optional(z.int().lte(18).register(z.globalRegistry, {
                description: 'Maximum number of additional capacity units allowed.'
            })),
            unit: z.optional(z.enum(['DAYS', 'WEEKS']).register(z.globalRegistry, {
                description: 'Unit of the amount.'
            }))
        }).register(z.globalRegistry, {
            description: 'Defines the maximum allowed increase in the delivery promise.'
        }))
    }).register(z.globalRegistry, {
        description: 'Additional information of the capacity shifts.'
    }))
});

/**
 * Details for a specific day's capacity including usage percentage, limit, usage amount, and the active time window.
 */
export const zCapacityDetail = z.object({
    amountPercentage: z.optional(z.number().register(z.globalRegistry, {
        description: 'Percentage of capacity used.'
    })),
    capacityLimitAmount: z.optional(z.int().register(z.globalRegistry, {
        description: 'Maximum capacity amount for the day.'
    })),
    capacityUsageAmount: z.optional(z.int().register(z.globalRegistry, {
        description: 'Capacity amount used for the day.'
    })),
    startAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'Start time for the capacity period.'
    })),
    endAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'End time for the capacity period.'
    }))
}).register(z.globalRegistry, {
    description: 'Details for a specific day\'s capacity including usage percentage, limit, usage amount, and the active time window.'
});

export const zLocation = z.object({
    id: z.optional(z.string().register(z.globalRegistry, {
        description: 'Unique identifier of the location.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the location.'
    })),
    status: z.optional(z.enum([
        'ACTIVE',
        'MANUALLY_PAUSED',
        'PAUSED'
    ]).register(z.globalRegistry, {
        description: 'Current status of the location.'
    })),
    timeZone: z.optional(z.string().register(z.globalRegistry, {
        description: 'Time zone of the location.'
    })),
    vtexAccountName: z.optional(z.string().register(z.globalRegistry, {
        description: 'VTEX account name associated with the location.'
    })),
    vtexAccount: z.optional(z.object({
        id: z.optional(z.string().register(z.globalRegistry, {
            description: 'VTEX account unique identifier.'
        })),
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account.'
        })),
        companyName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Company name associated with the VTEX account.'
        })),
        ownerAccountName: z.optional(z.string().register(z.globalRegistry, {
            description: 'Owner account name.'
        }))
    }).register(z.globalRegistry, {
        description: 'Detailed VTEX account information.'
    })),
    locationTasks: z.optional(z.array(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Represents a task associated with the location.'
    })).register(z.globalRegistry, {
        description: 'List of tasks associated with the location.'
    })),
    address: z.optional(z.object({
        formattedAddress: z.optional(z.string().register(z.globalRegistry, {
            description: 'The full formatted address.'
        })),
        country: z.optional(z.string().register(z.globalRegistry, {
            description: 'Country where the location is situated.'
        })),
        administrativeAreaLevel1: z.optional(z.string().register(z.globalRegistry, {
            description: 'First administrative division (e.g., state).'
        })),
        administrativeAreaLevel2: z.optional(z.string().register(z.globalRegistry, {
            description: 'Second administrative division (e.g., city).'
        })),
        postalCode: z.optional(z.string().register(z.globalRegistry, {
            description: 'Postal code of the location.'
        })),
        geoLocation: z.optional(z.object({
            latitude: z.optional(z.number().register(z.globalRegistry, {
                description: 'Latitude coordinate.'
            })),
            longitude: z.optional(z.number().register(z.globalRegistry, {
                description: 'Longitude coordinate.'
            }))
        }).register(z.globalRegistry, {
            description: 'Geographic coordinates of the location.'
        }))
    }).register(z.globalRegistry, {
        description: 'Address details of the location.'
    }))
});

export const zLocationsList = z.object({
    hasNextPage: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates if there is another page of results.'
    })),
    data: z.optional(z.array(z.object({
        id: z.optional(z.string().register(z.globalRegistry, {
            description: 'Unique identifier of the location.'
        })),
        name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Name of the location.'
        })),
        status: z.optional(z.enum([
            'ACTIVE',
            'MANUALLY_PAUSED',
            'PAUSED'
        ]).register(z.globalRegistry, {
            description: 'Current status of the location.'
        })),
        timeZone: z.optional(z.string().register(z.globalRegistry, {
            description: 'Time zone of the location.'
        })),
        vtexAccountName: z.optional(z.string().register(z.globalRegistry, {
            description: 'VTEX account name associated with the location.'
        })),
        segmentationType: z.optional(z.nullable(z.enum(['SALES_CHANNEL'])).register(z.globalRegistry, {
            description: 'Type of segmentation.'
        })),
        vtexAccount: z.optional(z.object({
            id: z.optional(z.string().register(z.globalRegistry, {
                description: 'VTEX account unique identifier.'
            })),
            name: z.optional(z.string().register(z.globalRegistry, {
                description: 'Name of the VTEX account.'
            })),
            companyName: z.optional(z.string().register(z.globalRegistry, {
                description: 'Company name associated with the VTEX account.'
            })),
            ownerAccountName: z.optional(z.string().register(z.globalRegistry, {
                description: 'Owner account name.'
            }))
        }).register(z.globalRegistry, {
            description: 'Detailed VTEX account information.'
        })),
        locationTasks: z.optional(z.array(z.object({
            id: z.optional(z.int().register(z.globalRegistry, {
                description: 'Unique identifier of the task.'
            })),
            locationId: z.optional(z.string().register(z.globalRegistry, {
                description: 'Unique identifier of the location.'
            })),
            segmentationGroupId: z.optional(z.string().register(z.globalRegistry, {
                description: 'Unique identifier of the segmentation group.'
            })),
            location: z.optional(zLocation),
            capacityRule: z.optional(zCapacityConfigurationResponse),
            locationCapacity: z.optional(zLocationCapacity)
        }).register(z.globalRegistry, {
            description: 'Represents a task associated with the location.'
        })).register(z.globalRegistry, {
            description: 'List of tasks associated with the location.'
        })),
        segmentationGroups: z.optional(z.array(z.object({
            id: z.optional(z.string().register(z.globalRegistry, {
                description: 'Unique identifier of the segmentation group.'
            })),
            name: z.optional(z.string().register(z.globalRegistry, {
                description: 'Name of the segmentation group.'
            }))
        }).register(z.globalRegistry, {
            description: 'Represents a segmentation group.'
        })).register(z.globalRegistry, {
            description: 'List of segmentation groups.'
        })),
        address: z.optional(z.object({
            id: z.optional(z.int().register(z.globalRegistry, {
                description: 'Unique identifier of the address.'
            })),
            locationId: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            formattedAddress: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            route: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            streetNumber: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            premise: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            subPremise: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            locality: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            subLocalityLevel1: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            subLocalityLevel2: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            subLocalityLevel3: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            country: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            administrativeAreaLevel1: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            administrativeAreaLevel2: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            administrativeAreaLevel3: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            postalCode: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            geoLocationLatitude: z.optional(z.number().register(z.globalRegistry, {
                description: 'Geographic latitude coordinate.'
            })),
            geoLocationLongitude: z.optional(z.number().register(z.globalRegistry, {
                description: 'Geographic longitude coordinate.'
            })),
            geoLocation: z.optional(z.object({
                latitude: z.optional(z.number().register(z.globalRegistry, {
                    description: 'Geographic latitude coordinate.'
                })),
                longitude: z.optional(z.number().register(z.globalRegistry, {
                    description: 'Geographic longitude coordinate.'
                }))
            }).register(z.globalRegistry, {
                description: 'Geographic coordinates of the location.'
            }))
        }).register(z.globalRegistry, {
            description: 'Address details of the location.'
        })),
        isSegmented: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates if the location is segmented (`true`) or not (`false`).'
        }))
    }).register(z.globalRegistry, {
        description: 'Represents a fulfillment location with its details, including identifier, name, status, time zone, account information, associated tasks, and address.'
    })).register(z.globalRegistry, {
        description: 'List of fulfillment locations.'
    }))
});

export const zUpdateLocationStatusRequest = z.object({
    status: z.enum(['ACTIVE', 'MANUALLY_PAUSED']).register(z.globalRegistry, {
        description: 'New status of the location.'
    })
});

/**
 * Unique identifier of the location.
 */
export const zLocationIdPath = z.string().register(z.globalRegistry, {
    description: 'Unique identifier of the location.'
});

/**
 * Type of the content being sent.
 */
export const zContentType = z.string().register(z.globalRegistry, {
    description: 'Type of the content being sent.'
});

/**
 * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
 */
export const zAccept = z.string().register(z.globalRegistry, {
    description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
});

export const zGetApiFulfillmentLocationsCapacityByParentAccountNameData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        })
    })
});

export const zPutApiFulfillmentLocationsLocationByLocationIdCapacitiesByCodeData = z.object({
    body: z.optional(zCapacityConfigurationRequest),
    path: z.object({
        locationId: z.string().register(z.globalRegistry, {
            description: 'Unique identifier of the location.'
        }),
        code: z.string().register(z.globalRegistry, {
            description: 'The type of task to update. Currently, the only supported value is `fulfill_orders`.'
        }).default('fulfill_orders')
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        })
    })
});

export const zGetApiFulfillmentLocationsLocationsByLocationIdCapacitiesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        locationId: z.string().register(z.globalRegistry, {
            description: 'Unique identifier of the location.'
        })
    }),
    query: z.optional(z.object({
        daysRequested: z.optional(z.int().register(z.globalRegistry, {
            description: 'Number of days to be displayed. Defaults to `3` if not provided.'
        })).default(3)
    })),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        })
    })
});

export const zGetApiFulfillmentLocationsLocationData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().register(z.globalRegistry, {
            description: 'Page number, starting from `0`. Defaults to `0` if not provided.'
        })).default(0),
        pageSize: z.optional(z.int().lte(30).register(z.globalRegistry, {
            description: 'Number of results per page (maximum: `30`). Defaults to `30` if not provided.'
        })).default(30),
        status: z.optional(z.enum([
            'ACTIVE',
            'MANUALLY_PAUSED',
            'PAUSED'
        ]).register(z.globalRegistry, {
            description: 'Filter by location status. Multiple statuses can be separated by commas.'
        })),
        search: z.optional(z.string().register(z.globalRegistry, {
            description: 'Search for locations by name.'
        }))
    })),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        })
    })
});

export const zPutApiFulfillmentLocationsLocationsByLocationIdStatusData = z.object({
    body: z.optional(zUpdateLocationStatusRequest),
    path: z.object({
        locationId: z.string().register(z.globalRegistry, {
            description: 'Unique identifier of the location.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        })
    })
});

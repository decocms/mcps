// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod';

/**
 * Request to upsert a mapping between a marketplace's sales channel and a seller's affiliate.
 */
export const zUpsertMappingRequest = z.object({
    marketplaceSalesChannel: z.int().register(z.globalRegistry, {
        description: 'The sales channel of the marketplace to be associated with the seller\'s affiliate. It is linked to the seller\'s affiliate.'
    }),
    sellerChannel: z.string().register(z.globalRegistry, {
        description: 'The affiliate of the seller that will be associated with the marketplace\'s sales channel. Through the affiliate, the seller determines which of his sales channels will be used for the mapping.'
    })
}).register(z.globalRegistry, {
    description: 'Request to upsert a mapping between a marketplace\'s sales channel and a seller\'s affiliate.'
});

/**
 * Object with the category properties and the commission percentage applied to it.
 */
export const zResponseSellerCommissionsId = z.object({
    categoryId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Marketplace\'s category ID that the product belongs to, configured in the Catalog.'
    })),
    categoryName: z.optional(z.string().register(z.globalRegistry, {
        description: 'Category name with applied commission.'
    })),
    categoryFullPath: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Category level name.'
    })).register(z.globalRegistry, {
        description: 'Full path to the SKU\'s category.'
    })),
    productCommissionPercentage: z.optional(z.number().register(z.globalRegistry, {
        description: 'Percentage of the comission applied to the product in decimals.'
    })),
    freightCommissionPercentage: z.optional(z.number().register(z.globalRegistry, {
        description: 'Percentage of the comission applied to the freight in decimals.'
    }))
}).register(z.globalRegistry, {
    description: 'Object with the category properties and the commission percentage applied to it.'
});

/**
 * Request to bulk upsert (update or insert) seller commission configurations for multiple categories. This includes details such as the category ID, full path of the category, product commission percentage, and freight commission percentage.
 */
export const zBulkUpsertSellerCommissionsRequest = z.object({
    categoryId: z.string().register(z.globalRegistry, {
        description: 'Marketplace\'s Category ID that the product belongs to, configured in the Catalog.'
    }),
    categoryFullPath: z.union([
        z.string(),
        z.null()
    ]),
    productCommissionPercentage: z.number().register(z.globalRegistry, {
        description: 'Percentage of the comission applied to the product in decimals.'
    }),
    freightCommissionPercentage: z.number().register(z.globalRegistry, {
        description: 'Percentage of the comission applied to the freight in decimals.'
    })
}).register(z.globalRegistry, {
    description: 'Request to bulk upsert (update or insert) seller commission configurations for multiple categories. This includes details such as the category ID, full path of the category, product commission percentage, and freight commission percentage.'
});

/**
 * Request to upsert seller commission configurations. This includes details such as the category ID, full path of the category, product commission percentage, and freight commission percentage.
 */
export const zUpsertSellerCommissionsRequest = z.object({
    categoryId: z.string().register(z.globalRegistry, {
        description: 'Marketplace\'s Category ID that the product belongs to, configured in the Catalog.'
    }).default('6'),
    categoryFullPath: z.union([
        z.string(),
        z.null()
    ]),
    productCommissionPercentage: z.number().register(z.globalRegistry, {
        description: 'Percentage of the comission applied to the product in decimals.'
    }).default(9.85),
    freightCommissionPercentage: z.number().register(z.globalRegistry, {
        description: 'Percentage of the comission applied to the freight in decimals.'
    }).default(2.43)
}).register(z.globalRegistry, {
    description: 'Request to upsert seller commission configurations. This includes details such as the category ID, full path of the category, product commission percentage, and freight commission percentage.'
});

/**
 * Response object for creating a seller lead. It includes details about the created seller, such as their ID, the creation date, and the date of the last update.
 */
export const zResponseCreateSellerLead = z.object({
    sellerId: z.optional(z.string().register(z.globalRegistry, {
        description: 'ID of the created seller.'
    })),
    createdAt: z.optional(z.string().register(z.globalRegistry, {
        description: 'Creation date of the seller.'
    })),
    updatedAt: z.optional(z.string().register(z.globalRegistry, {
        description: 'Date of the last update of the seller.'
    }))
}).register(z.globalRegistry, {
    description: 'Response object for creating a seller lead. It includes details about the created seller, such as their ID, the creation date, and the date of the last update.'
});

/**
 * Details of the person accountable for the seller's account. This includes their name, email address, and phone number.
 */
export const zAccountable = z.object({
    name: z.string().register(z.globalRegistry, {
        description: 'Name of the person responsible for the seller.'
    }),
    email: z.string().register(z.globalRegistry, {
        description: 'Email address of the person responsible for the seller.'
    }),
    phone: z.string().register(z.globalRegistry, {
        description: 'Phone number of the person responsible for the seller.'
    })
}).register(z.globalRegistry, {
    description: 'Details of the person accountable for the seller\'s account. This includes their name, email address, and phone number.'
});

/**
 * Details of the address associated with the seller. This includes postal code, complement, street, number, neighborhood, state, and city.
 */
export const zAddress = z.object({
    postalcode: z.string().register(z.globalRegistry, {
        description: 'Postal code from the seller\'s address.'
    }),
    complement: z.string().register(z.globalRegistry, {
        description: 'Seller\'s address complement.'
    }),
    street: z.string().register(z.globalRegistry, {
        description: 'Street information, from the seller\'s address.'
    }),
    number: z.string().register(z.globalRegistry, {
        description: 'Street\'s number, from the seller\'s address.'
    }),
    neighborhood: z.string().register(z.globalRegistry, {
        description: 'Seller\'s address neighborhood.'
    }),
    state: z.string().register(z.globalRegistry, {
        description: 'State, from the seller\'s address.'
    }),
    city: z.string().register(z.globalRegistry, {
        description: 'City name, from the seller\'s address.'
    })
}).register(z.globalRegistry, {
    description: 'Details of the address associated with the seller. This includes postal code, complement, street, number, neighborhood, state, and city.'
});

/**
 * Request to create a seller lead. This includes detailed information about the seller, such as their email, name, account name, trade policy, contact email, seller type, account ID, accountable person, acceptance of legal terms, address, and document details.
 */
export const zCreateSellerLeadRequest = z.object({
    sellerEmail: z.string().register(z.globalRegistry, {
        description: 'Seller\'s contact email.'
    }),
    sellerName: z.string().register(z.globalRegistry, {
        description: 'Seller\'s store\'s name.'
    }),
    sellerAccountName: z.string().register(z.globalRegistry, {
        description: 'Name of the seller\'s account, part of the url of their VTEX Admin.'
    }),
    salesChannel: z.string().register(z.globalRegistry, {
        description: 'Sales channel ([trade policy](https://help.vtex.com/en/tutorial/how-trade-policies-work--6Xef8PZiFm40kg2STrMkMV)) associated to the seller account created.'
    }),
    email: z.string().register(z.globalRegistry, {
        description: 'The email address associated with the seller. It should be in a valid email format.'
    }),
    sellerType: z.int().register(z.globalRegistry, {
        description: 'Type of seller, which can be: \n\n`1`: Regular seller \n\n`2`: White label seller.'
    }),
    accountId: z.string().register(z.globalRegistry, {
        description: 'Marketplace\'s account ID.'
    }),
    document: z.string().register(z.globalRegistry, {
        description: 'Company\'s legal document number.'
    }),
    hasAcceptedLegalTerms: z.boolean().register(z.globalRegistry, {
        description: 'Indicates if the seller has accepted the platform\'s legal terms and conditions.'
    }),
    address: zAddress,
    accountable: zAccountable
}).register(z.globalRegistry, {
    description: 'Request to create a seller lead. This includes detailed information about the seller, such as their email, name, account name, trade policy, contact email, seller type, account ID, accountable person, acceptance of legal terms, address, and document details.'
});

/**
 * Request to accept a seller lead. This includes detailed information about the seller, such as their email, name, account name, trade policy, contact email, seller type, account ID, document details, acceptance of legal terms, address, and accountable party.
 */
export const zAcceptSellerLeadRequest = z.object({
    sellerEmail: z.string().register(z.globalRegistry, {
        description: 'Seller\'s contact email.'
    }),
    sellerName: z.string().register(z.globalRegistry, {
        description: 'Seller\'s store\'s name.'
    }),
    sellerAccountName: z.string().register(z.globalRegistry, {
        description: 'Name of the seller\'s account, part of the url of their VTEX Admin.'
    }),
    salesChannel: z.string().register(z.globalRegistry, {
        description: 'Sales channel ([trade policy](https://help.vtex.com/en/tutorial/how-trade-policies-work--6Xef8PZiFm40kg2STrMkMV)) associated to the seller account created.'
    }),
    email: z.string().register(z.globalRegistry, {
        description: 'email of the admin responsible for the seller.'
    }),
    sellerType: z.int().register(z.globalRegistry, {
        description: 'Type of seller, including: \n\n`1`: Regular seller \n\n`2`: White label seller.'
    }),
    accountId: z.string().register(z.globalRegistry, {
        description: 'Marketplace\'s account ID.'
    }),
    document: z.string().register(z.globalRegistry, {
        description: 'Company\'s legal document code.'
    }),
    hasAcceptedLegalTerms: z.boolean().register(z.globalRegistry, {
        description: 'Indicates if the seller has accepted the platform\'s legal terms and conditions.'
    }),
    address: zAddress,
    accountable: zAccountable
}).register(z.globalRegistry, {
    description: 'Request to accept a seller lead. This includes detailed information about the seller, such as their email, name, account name, trade policy, contact email, seller type, account ID, document details, acceptance of legal terms, address, and accountable party.'
});

/**
 * Request to resend a seller lead. This includes the status of the lead that determines the action to be taken.
 */
export const zResendSellerLeadRequestRequest = z.object({
    status: z.string().register(z.globalRegistry, {
        description: 'Seller lead\'s status, which can be: `accepted`, `connected` or `invited`.'
    })
}).register(z.globalRegistry, {
    description: 'Request to resend a seller lead. This includes the status of the lead that determines the action to be taken.'
});

/**
 * Configuration details for seller commissions. This includes the product commission percentage, freight commission percentage, and categories commission configuration.
 *
 * @deprecated
 */
export const zSellerCommissionConfiguration = z.object({
    productCommissionPercentage: z.number().register(z.globalRegistry, {
        description: 'Percentage of the comission applied to the product in decimals.'
    }),
    freightCommissionPercentage: z.number().register(z.globalRegistry, {
        description: 'Percentage of the comission applied to the freight in decimals.'
    }),
    categoriesCommissionConfiguration: z.array(z.object({
        category: z.string().register(z.globalRegistry, {
            description: 'Category identifier or name.'
        }),
        commission: z.number().register(z.globalRegistry, {
            description: 'Percentage of the commission applied to the category in decimal format.'
        })
    }).register(z.globalRegistry, {
        description: 'Object representing the commission configuration for a specific category. This includes the category identifier or name and the commission percentage applied to it.'
    })).register(z.globalRegistry, {
        description: 'Array containing the commission configurations for different categories. Each item in the array specifies the category and the commission percentage applied to it.'
    }).default([])
}).register(z.globalRegistry, {
    description: 'Configuration details for seller commissions. This includes the product commission percentage, freight commission percentage, and categories commission configuration.'
});

/**
 * Details of a trade policy available for the product. This includes whether the sales channel is selected, its ID, and its name.
 */
export const zAvailableSalesChannel = z.object({
    isSelected: z.boolean().register(z.globalRegistry, {
        description: 'Defines if the sales channel ([trade policy](https://help.vtex.com/en/tutorial/how-trade-policies-work--6Xef8PZiFm40kg2STrMkMV)) is selected or not.'
    }),
    id: z.int().register(z.globalRegistry, {
        description: 'Trade policy ID.'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'Name of the trade policy.'
    })
}).register(z.globalRegistry, {
    description: 'Details of a trade policy available for the product. This includes whether the sales channel is selected, its ID, and its name.'
});

/**
 * groups
 *
 * Array of groups attached to the seller. Groups are defined by key-words that group sellers into categories defined by the marketplace when adding a new seller through the [Configure Seller Account](https://developers.vtex.com/vtex-rest-api/reference/sellers#putupsertseller) endpoint. It is possible to filter sellers by group in the Seller Management page in your VTEX Admin. Know more about groups through our [Seller Management](https://help.vtex.com/en/tutorial/gerenciamento-de-sellers-beta--6eEiOISwxuAWJ8w6MtK7iv#groups) documentation.
 */
export const zGroups = z.object({
    id: z.optional(z.string().register(z.globalRegistry, {
        description: 'Group\'s unique identifier code.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the tag chosen to identify the group.'
    }))
}).register(z.globalRegistry, {
    description: 'Array of groups attached to the seller. Groups are defined by key-words that group sellers into categories defined by the marketplace when adding a new seller through the [Configure Seller Account](https://developers.vtex.com/vtex-rest-api/reference/sellers#putupsertseller) endpoint. It is possible to filter sellers by group in the Seller Management page in your VTEX Admin. Know more about groups through our [Seller Management](https://help.vtex.com/en/tutorial/gerenciamento-de-sellers-beta--6eEiOISwxuAWJ8w6MtK7iv#groups) documentation.'
});

/**
 * Configure Seller Account
 *
 * Request to configure or update a seller account. This includes all necessary details for setting up the seller's account, such as ID, name, status, fulfillment settings, payment options, tax information, contact details, commission configuration, policies, and authentication information.
 */
export const zUpsertSellerRequest = z.object({
    id: z.string().register(z.globalRegistry, {
        description: 'Seller ID assigned by the marketplace. We recommend filling it in with the seller\'s account name.'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'Name of the seller\'s store, configured in the seller\'s environment.'
    }),
    isActive: z.boolean().register(z.globalRegistry, {
        description: 'Whether the seller is active on the marketplace or not.'
    }),
    fulfillmentEndpoint: z.string().register(z.globalRegistry, {
        description: 'URL of the endpoint for fulfillment of seller\'s orders, which the marketplace will use to communicate with the seller. \n\nFor **external sellers**, please include the URL of the seller\'s endpoint. External sellers have different endpoint standards. The seller must inform this endpoint to the marketplace so that the marketplace can complete the configuration process. \n\nFor **VTEX Stores**, the field format will be as follows: `https://{SellerName}.vtexcommercestable.com.br/api/fulfillment?&sc={TradePolicyID}`. \n\nThe value `SellerName` corresponds to the store name if the seller is a VTEX store. \n\nThe value `TradePolicyID` corresponds to the [trade policy](https://help.vtex.com/en/tutorial/how-trade-policies-work--6Xef8PZiFm40kg2STrMkMV#master-data) created by the seller in their own VTEX environment. The seller must inform this ID to the marketplace so that the marketplace can complete the configuration process. \n\nThe value `AffiliateID` corresponds to the 3-digit affiliate identification code created by the seller. The seller must inform this ID to the marketplace so that the marketplace can complete the configuration process. \n\nTo configure the [Multilevel Omnichannel Inventory](https://developers.vtex.com/vtex-rest-api/docs/multilevel-omnichannel-inventory) feature, fill in this field with the checkout endpoint following this example: `https://{{sellerAccount}}.vtexcommercestable.com.br/api/checkout?affiliateid={{affiliateId}}&sc={{salesChannel}}`.'
    }),
    allowHybridPayments: z.boolean().register(z.globalRegistry, {
        description: 'Indicates if customers can use gift cards from the seller to buy their products on the marketplace (`true`) or not (`false`). If true, it identifies purchases made with a gift card so that only the final price (with discounts applied) is paid to the seller.'
    }),
    taxCode: z.string().register(z.globalRegistry, {
        description: 'Identity number of the legal entity, which is linked to information in its base country.'
    }),
    email: z.string().register(z.globalRegistry, {
        description: 'Email of the administrative user responsible for the seller.'
    }),
    description: z.string().register(z.globalRegistry, {
        description: 'Description of the seller.'
    }),
    sellerCommissionConfiguration: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Details of the seller\'s commission configuration, including the product commission percentage, freight commission percentage, and categories commission configuration.'
    }),
    isBetterScope: z.boolean().register(z.globalRegistry, {
        description: 'Flag used by the VTEX Checkout to simmulate shopping carts, products and shipping only in sellers with the boolean set as `true`, avoiding performance issues.'
    }),
    sellerType: z.int().register(z.globalRegistry, {
        description: 'Type of seller, including: \n\n`1`: Regular seller \n\n`2`: White label seller.'
    }),
    availableSalesChannels: z.array(zAvailableSalesChannel).register(z.globalRegistry, {
        description: 'Sales channel (or [trade policy](https://help.vtex.com/en/tutorial/how-trade-policies-work--6Xef8PZiFm40kg2STrMkMV)) available.'
    }),
    CSCIdentification: z.string().register(z.globalRegistry, {
        description: 'SKU Seller Identification.'
    }),
    account: z.string().register(z.globalRegistry, {
        description: 'Seller\'s account name.'
    }),
    channel: z.string().register(z.globalRegistry, {
        description: 'Channel\'s name.'
    }),
    salesChannel: z.string().register(z.globalRegistry, {
        description: 'Sales channel (or [trade policy](https://help.vtex.com/en/tutorial/how-trade-policies-work--6Xef8PZiFm40kg2STrMkMV)) associated to the seller account created. If no value is specified, the system will automatically use the sales channel configured in the seller\'s [affiliate](https://help.vtex.com/en/tutorial/configuring-affiliates--tutorials_187) ID.'
    }),
    isVtex: z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether the seller configured is a VTEX store or not.'
    }),
    exchangeReturnPolicy: z.string().register(z.globalRegistry, {
        description: 'Text describing the exchange and return policy previously agreed between the marketplace and the seller.'
    }),
    deliveryPolicy: z.string().register(z.globalRegistry, {
        description: 'Text describing the delivery policy previously agreed between the marketplace and the seller.'
    }),
    securityPrivacyPolicy: z.union([
        z.string(),
        z.null()
    ]),
    fulfillmentSellerId: z.union([
        z.string(),
        z.null()
    ]),
    groups: z.optional(z.array(zGroups).register(z.globalRegistry, {
        description: 'Array of groups attached to the seller. Groups are defined by keywords that group sellers into categories defined by the marketplace when adding a new seller through the [Configure Seller Account](https://developers.vtex.com/docs/api-reference/marketplace-apis?endpoint=post-/seller-register/pvt/sellers) endpoint. It is possible to filter sellers by group in the Seller Management page in your VTEX Admin. Learn more about groups through our [Seller Management](https://help.vtex.com/en/tutorial/seller-management--6eEiOISwxuAWJ8w6MtK7iv#groups) documentation.'
    })),
    user: z.union([
        z.string(),
        z.null()
    ]),
    password: z.union([
        z.string(),
        z.null()
    ]),
    catalogSystemEndpoint: z.string().register(z.globalRegistry, {
        description: 'URL of the endpoint of the seller\'s catalog. This field will only be displayed if the seller type is VTEX Store. The field format will be as follows: `https://{sellerName}.vtexcommercestable.com.br/api/catalog_system/`.'
    }),
    trustPolicy: z.string().register(z.globalRegistry, {
        description: 'Specifies the trust policy agreed between the marketplace and the seller, such as permissions related to data sharing.'
    }),
    score: z.number().register(z.globalRegistry, {
        description: 'Score attributed to this seller.'
    })
}).register(z.globalRegistry, {
    description: 'Request to configure or update a seller account. This includes all necessary details for setting up the seller\'s account, such as ID, name, status, fulfillment settings, payment options, tax information, contact details, commission configuration, policies, and authentication information.'
});

/**
 * Details of the main image associated with the product. This includes the image's ID, label, tag, path, and other attributes indicating its main and zoom size status, as well as additional text and last modification date.
 */
export const zMainImage = z.object({
    ImageId: z.string().register(z.globalRegistry, {
        description: 'Code identifying the image\'s file.'
    }),
    ImageLabel: z.union([
        z.string(),
        z.null()
    ]),
    ImageTag: z.string().register(z.globalRegistry, {
        description: 'HTML tag for the selected image.'
    }),
    ImagePath: z.string().register(z.globalRegistry, {
        description: 'Path for the image\'s file.'
    }),
    IsMain: z.boolean().register(z.globalRegistry, {
        description: 'Whether the image is the main one or not.'
    }).default(true),
    IsZoomSize: z.boolean().register(z.globalRegistry, {
        description: 'If zoom can be applied to the image.'
    }).default(true),
    ImageText: z.string().register(z.globalRegistry, {
        description: 'Alt text for the image.'
    }),
    LastModified: z.string().register(z.globalRegistry, {
        description: 'Date of the last change made to the image.'
    })
}).register(z.globalRegistry, {
    description: 'Details of the main image associated with the product. This includes the image\'s ID, label, tag, path, and other attributes indicating its main and zoom size status, as well as additional text and last modification date.'
});

/**
 * OffersPerSalesChannel
 *
 * Details of offers available per trade policy. This includes pricing information and available quantity specific to each trade policy.
 */
export const zOffersPerSalesChannel = z.object({
    SaleChannel: z.int().register(z.globalRegistry, {
        description: 'Sales channel ([trade policy](https://help.vtex.com/en/tutorial/how-trade-policies-work--6Xef8PZiFm40kg2STrMkMV)) of the SKU.'
    }),
    Price: z.int().register(z.globalRegistry, {
        description: 'SKU\'s price.'
    }),
    ListPrice: z.int().register(z.globalRegistry, {
        description: 'SKU\'s suggested selling price.'
    }),
    PriceWithoutDiscount: z.int().register(z.globalRegistry, {
        description: 'SKU\'s price without discount applied.'
    }),
    AvailableQuantity: z.int().register(z.globalRegistry, {
        description: 'Available SKU stock quantity.'
    })
}).register(z.globalRegistry, {
    description: 'Details of offers available per trade policy. This includes pricing information and available quantity specific to each trade policy.'
});

/**
 * Details of an offer provided by a seller. This includes the seller's identification, SKU, offers per sales channel, and available trade policies.
 */
export const zOffer = z.object({
    SellerId: z.string().register(z.globalRegistry, {
        description: 'ID of the seller in the marketplace. This ID must be created by the marketplace.'
    }),
    SellerSkuId: z.string().register(z.globalRegistry, {
        description: 'Unique identifier of the SKU in the seller. This is the ID that the marketplace will use for future references to this SKU, such as price and inventory notifications.'
    }),
    OffersPerSalesChannel: z.array(zOffersPerSalesChannel).register(z.globalRegistry, {
        description: 'Each element in the array corresponds to an offer in a specific trade policy.'
    }),
    AvailableSalesChannels: z.union([
        z.string(),
        z.null()
    ])
}).register(z.globalRegistry, {
    description: 'Details of an offer provided by a seller. This includes the seller\'s identification, SKU, offers per sales channel, and available trade policies.'
});

/**
 * Details of the SKU (Stock Keeping Unit) associated with the product. This includes the SKU ID, EAN ID, reference ID, complete name, short name, active status, main image, and offers.
 */
export const zSku2 = z.object({
    SkuId: z.string().register(z.globalRegistry, {
        description: 'SKU\'s unique identifier number.'
    }),
    EanId: z.union([
        z.string(),
        z.null()
    ]),
    RefId: z.union([
        z.string(),
        z.null()
    ]),
    NameComplete: z.string().register(z.globalRegistry, {
        description: 'Complete name of the SKU.'
    }),
    Name: z.string().register(z.globalRegistry, {
        description: 'Summarized name of the SKU.'
    }),
    IsActive: z.boolean().register(z.globalRegistry, {
        description: 'Whether the SKU is active in the trade policy (true), or not (false).'
    }).default(true),
    MainImage: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Main image\'s information.'
    }),
    Offers: z.array(zOffer).register(z.globalRegistry, {
        description: 'Array with offers.'
    })
}).register(z.globalRegistry, {
    description: 'Details of the SKU (Stock Keeping Unit) associated with the product. This includes the SKU ID, EAN ID, reference ID, complete name, short name, active status, main image, and offers.'
});

/**
 * Response with the list of offers available on the Marketplace.
 */
export const zResponseGetMatchedOffersList = z.array(z.object({
    LastModified: z.optional(z.string().register(z.globalRegistry, {
        description: 'Last date when the offer was modified.'
    })),
    ProductId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Unique identifier of the seller\'s product. This is the ID that the marketplace will use for all references to this product.'
    })),
    CategoryId: z.optional(z.int().register(z.globalRegistry, {
        description: 'Offer\'s Category ID that the product belongs to, configured in the Catalog. It should be the marketplace\'s category chosen for the offer to be matched with.'
    })),
    BrandId: z.optional(z.int().register(z.globalRegistry, {
        description: 'Offer\'s brand ID that the product belongs to, configured in the Catalog. It should be the marketplace\'s brand chosen for the offer to be matched with.'
    })),
    ProductName: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the offer\'s product.'
    })),
    Skus: z.optional(z.array(zSku2).register(z.globalRegistry, {
        description: 'A list of SKUs (Stock Keeping Units) associated with the product. Each SKU contains detailed information about specific variants of the product, such as color, size, and other specifications.'
    }))
}).register(z.globalRegistry, {
    description: 'Array of SKUs in the offer.'
})).register(z.globalRegistry, {
    description: 'Response with the list of offers available on the Marketplace.'
});

/**
 * Array of matched offers data by SKU.
 */
export const zResponseGetMatchedOffersDataBySku = z.array(z.object({
    productId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Unique identifier for the product.'
    })),
    skuId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Unique identifier for the product SKU.'
    })),
    nameComplete: z.optional(z.string().register(z.globalRegistry, {
        description: 'Complete name of the product.'
    })),
    mainImage: z.optional(z.object({
        imagePath: z.string().register(z.globalRegistry, {
            description: 'File path of the main product image.'
        })
    }).register(z.globalRegistry, {
        description: 'Schema for the main product image.'
    })),
    sellersOffers: z.optional(z.array(z.object({
        sellerId: z.optional(z.string().register(z.globalRegistry, {
            description: 'Unique identifier for the seller.'
        })),
        sellerSkuId: z.optional(z.string().register(z.globalRegistry, {
            description: 'Unique identifier for the seller\'s SKU.'
        })),
        salesChannelOffer: z.optional(z.array(z.object({
            salesChannelId: z.optional(z.string().register(z.globalRegistry, {
                description: 'Unique identifier for the trade policy.'
            })),
            salesChannelName: z.optional(z.string().register(z.globalRegistry, {
                description: 'Name of the trade policy.'
            })),
            price: z.optional(z.number().register(z.globalRegistry, {
                description: 'Offer price.'
            })),
            listPrice: z.optional(z.number().register(z.globalRegistry, {
                description: 'List price of the product.'
            })),
            priceWithoutDiscount: z.optional(z.number().register(z.globalRegistry, {
                description: 'Offer price without any discount.'
            })),
            availableQuantity: z.optional(z.int().register(z.globalRegistry, {
                description: 'Available quantity of the product.'
            }))
        }).register(z.globalRegistry, {
            description: 'Schema for individual trade policy offer data.'
        })).register(z.globalRegistry, {
            description: 'Array of offers on different trade policies from the same seller.'
        }))
    }).register(z.globalRegistry, {
        description: 'Schema for individual seller offer data.'
    })).register(z.globalRegistry, {
        description: 'Array of offers from different sellers.'
    }))
}).register(z.globalRegistry, {
    description: 'Schema for individual offer data.'
})).register(z.globalRegistry, {
    description: 'Array of matched offers data by SKU.'
});

/**
 * Array of matched offers data by product ID.
 */
export const zResponseGetMatchedOffersDataByProductId = z.array(z.object({
    productId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Unique identifier for the product.'
    })),
    skuId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Unique identifier for the product SKU.'
    })),
    nameComplete: z.optional(z.string().register(z.globalRegistry, {
        description: 'Complete name of the product.'
    })),
    mainImage: z.optional(z.object({
        imagePath: z.string().register(z.globalRegistry, {
            description: 'File path of the main product image.'
        })
    }).register(z.globalRegistry, {
        description: 'Schema for the main product image.'
    })),
    sellersOffers: z.optional(z.array(z.object({
        sellerId: z.optional(z.string().register(z.globalRegistry, {
            description: 'Unique identifier for the seller.'
        })),
        sellerSkuId: z.optional(z.string().register(z.globalRegistry, {
            description: 'Unique identifier for the seller\'s SKU.'
        })),
        salesChannelOffer: z.optional(z.object({
            salesChannelId: z.optional(z.string().register(z.globalRegistry, {
                description: 'Unique identifier for the sales channel (trade policy).'
            })),
            salesChannelName: z.optional(z.string().register(z.globalRegistry, {
                description: 'Name of the trade policy.'
            })),
            price: z.optional(z.number().register(z.globalRegistry, {
                description: 'Offer price.'
            })),
            listPrice: z.optional(z.number().register(z.globalRegistry, {
                description: 'List price of the product.'
            })),
            priceWithoutDiscount: z.optional(z.number().register(z.globalRegistry, {
                description: 'Offer price without any discount.'
            })),
            availableQuantity: z.optional(z.int().register(z.globalRegistry, {
                description: 'Available quantity of the product.'
            }))
        }).register(z.globalRegistry, {
            description: 'Schema for the offer data on a specific sales channel (trade policy).'
        }))
    }).register(z.globalRegistry, {
        description: 'Schema for individual seller offer data.'
    })).register(z.globalRegistry, {
        description: 'Array of offers from different sellers.'
    }))
}).register(z.globalRegistry, {
    description: 'Schema for individual offer data.'
})).register(z.globalRegistry, {
    description: 'Array of matched offers data by product ID.'
});

/**
 * Array containing all configured affiliates in the store.
 */
export const zResponseListAffiliates = z.array(z.object({
    id: z.optional(z.string().register(z.globalRegistry, {
        description: 'Three-letter identifier defined during the affiliate configuration creation. Vowels are not allowed.'
    })),
    followUpEmail: z.optional(z.string().register(z.globalRegistry, {
        description: 'Email address in which the user will receive notifications about the integration.'
    })),
    useSellerPaymentMethod: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates if the store uses the payment split, seller payment method, (`true`) or not (`false`). Recommended for use only in VTEX-with-VTEX integrations because of compatibility of payment methods.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Affiliate name.'
    })),
    salesChannel: z.optional(z.string().register(z.globalRegistry, {
        description: 'Number of the sales channel that will define the catalog assortment, prices, and the shipping strategy of items sent to the marketplace.'
    })),
    searchURIEndpoint: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    searchURIEndpointVersion: z.optional(z.string().register(z.globalRegistry, {
        description: 'Search URI endpoint version. The default option is the only one available.'
    })).default('1.x.x.'),
    searchURIEndpointAvailableVersions: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Search URI endpoint available version. The default option is the only one available.'
    }).default('1.x.x.')).register(z.globalRegistry, {
        description: 'Search URI endpoint available versions.'
    })),
    minimumValueAccumulated: z.optional(z.union([
        z.int(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: '[Affiliate](https://help.vtex.com/en/tutorial/configuring-affiliates--tutorials_187) information.'
})).register(z.globalRegistry, {
    description: 'Array containing all configured affiliates in the store.'
});

/**
 * Object containing detailed information about a specific affiliate.
 */
export const zResponseGetAffiliates = z.object({
    id: z.optional(z.string().register(z.globalRegistry, {
        description: 'Three-letter identifier defined during the affiliate configuration creation. Vowels are not allowed.'
    })),
    followUpEmail: z.optional(z.string().register(z.globalRegistry, {
        description: 'Email address in which the user will receive notifications about the integration.'
    })),
    useSellerPaymentMethod: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates if the store uses the payment split, seller payment method, (`true`) or not (`false`). Recommended for use only in VTEX-with-VTEX integrations because of compatibility of payment methods.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Affiliate name.'
    })),
    salesChannel: z.optional(z.string().register(z.globalRegistry, {
        description: 'Number of the sales channel that will define the catalog assortment, prices, and the shipping strategy of items sent to the marketplace.'
    })),
    searchURIEndpoint: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    searchURIEndpointVersion: z.optional(z.string().register(z.globalRegistry, {
        description: 'Search URI endpoint version. The default option is the only one available.'
    })).default('1.x.x.'),
    searchURIEndpointAvailableVersions: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Search URI endpoint available version. The default option is the only one available.'
    }).default('1.x.x.')).register(z.globalRegistry, {
        description: 'Search URI endpoint available versions.'
    })),
    minimumValueAccumulated: z.optional(z.union([
        z.int(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Object containing detailed information about a specific affiliate.'
});

/**
 * Object containing the data structure required to update an affiliate configuration.
 */
export const zRequestUpdateAffiliate = z.object({
    followUpEmail: z.optional(z.string().register(z.globalRegistry, {
        description: 'Email address in which the user will receive notifications about the integration.'
    })),
    useSellerPaymentMethod: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates if the store uses the payment split, seller payment method, (`true`) or not (`false`). Recommended for use only in VTEX-with-VTEX integrations because of compatibility of payment methods.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Affiliate name.'
    })),
    salesChannel: z.optional(z.string().register(z.globalRegistry, {
        description: 'Number of the sales channel that will define the catalog assortment, prices, and the shipping strategy of items sent to the marketplace.'
    })),
    searchURIEndpoint: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    searchURIEndpointVersion: z.optional(z.string().register(z.globalRegistry, {
        description: 'Search URI endpoint version. The default option is the only one available.'
    })).default('1.x.x.'),
    searchURIEndpointAvailableVersions: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Search URI endpoint available version. The default option is the only one available.'
    }).default('1.x.x.')).register(z.globalRegistry, {
        description: 'Search URI endpoint available versions.'
    })),
    minimumValueAccumulated: z.optional(z.union([
        z.int(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Object containing the data structure required to update an affiliate configuration.'
});

/**
 * The flag `isBetterScope` is used by the VTEX Checkout to simulate shopping carts, products, and shipping only in sellers with the field set as `true`, avoiding performance issues. When used as a query param, `isBetterScope` filters sellers that have the flag set as `true` or `false`.
 */
export const zIsBetterScope = z.boolean().register(z.globalRegistry, {
    description: 'The flag `isBetterScope` is used by the VTEX Checkout to simulate shopping carts, products, and shipping only in sellers with the field set as `true`, avoiding performance issues. When used as a query param, `isBetterScope` filters sellers that have the flag set as `true` or `false`.'
}).default(false);

/**
 * Query param that enables results to be filter by whether the seller lead is already connected to the marketplace or not.
 */
export const zIsConnected = z.string().register(z.globalRegistry, {
    description: 'Query param that enables results to be filter by whether the seller lead is already connected to the marketplace or not.'
}).default('');

/**
 * Custom search field, that filters sellers invited by specific marketplace operator's  email.
 */
export const zSearch = z.string().register(z.globalRegistry, {
    description: 'Custom search field, that filters sellers invited by specific marketplace operator\'s  email.'
}).default('user email');

/**
 * Seller Lead's status. Includes `accepted`, `connected` or `invited`.
 */
export const zStatus = z.string().register(z.globalRegistry, {
    description: 'Seller Lead\'s status. Includes `accepted`, `connected` or `invited`.'
}).default('invited');

/**
 * Query param determining how data will be ordered in the response, ordering by name or ID in descending our ascending order. Includes the following values:
 *
 * `namesort` = desc/asc
 *
 * `idsort` = desc/asc
 */
export const zOrderBy = z.string().register(z.globalRegistry, {
    description: 'Query param determining how data will be ordered in the response, ordering by name or ID in descending our ascending order. Includes the following values: \n\n`namesort` = desc/asc \n\n`idsort` = desc/asc'
});

/**
 * This field determines the limit used to retrieve the list of sellers. The response includes objects until the value inputted here.
 */
export const zLimit = z.int().register(z.globalRegistry, {
    description: 'This field determines the limit used to retrieve the list of sellers. The response includes objects until the value inputted here.            '
}).default(15);

/**
 * This field determines the limit used to retrieve the list of sellers. The response includes objects starting `from` the value inputted here.
 */
export const zOffset = z.int().register(z.globalRegistry, {
    description: 'This field determines the limit used to retrieve the list of sellers. The response includes objects starting `from` the value inputted here.'
}).default(0);

/**
 * ID of the category in which the comission was applied
 */
export const zCategoryId = z.string().register(z.globalRegistry, {
    description: 'ID of the category in which the comission was applied'
}).default('6');

/**
 * ID of the Seller Lead invited to the marketplace.
 */
export const zSellerLeadId = z.string().register(z.globalRegistry, {
    description: 'ID of the Seller Lead invited to the marketplace.'
});

/**
 * The start number of pagination, being `0` the default value.
 */
export const zFrom = z.number().register(z.globalRegistry, {
    description: 'The start number of pagination, being `0` the default value.'
}).default(0);

/**
 * The end number of pagination, being `100` the default value.
 */
export const zTo = z.number().register(z.globalRegistry, {
    description: 'The end number of pagination, being `100` the default value.'
}).default(100);

/**
 * Search sellers by a keyword in `sellerId` or `sellerName`.
 */
export const zKeyword = z.string().register(z.globalRegistry, {
    description: 'Search sellers by a keyword in `sellerId` or `sellerName`.'
}).default('keyword');

/**
 * Filters sellers by the name of who made the integration, if VTEX or an external hub. The possible values for VTEX integrations are: `vtex-sellerportal`, `vtex-seller` and `vtex-franchise`.
 */
export const zIntegration = z.string().register(z.globalRegistry, {
    description: 'Filters sellers by the name of who made the integration, if VTEX or an external hub. The possible values for VTEX integrations are: `vtex-sellerportal`, `vtex-seller` and `vtex-franchise`.'
}).default('vtex-seller');

/**
 * Groups are defined by keywords that group sellers into categories defined by the marketplace.
 */
export const zGroup = z.string().register(z.globalRegistry, {
    description: 'Groups are defined by keywords that group sellers into categories defined by the marketplace.'
}).default('Group');

/**
 * Enables to filter sellers that are active (`true`) or unactive (`false`) in the marketplace.
 */
export const zIsActive = z.boolean().register(z.globalRegistry, {
    description: 'Enables to filter sellers that are active (`true`) or unactive (`false`) in the marketplace.'
}).default(false);

/**
 * Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.
 */
export const zAccountName = z.string().register(z.globalRegistry, {
    description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
});

/**
 * Type of the content being sent.
 */
export const zContentType = z.string().register(z.globalRegistry, {
    description: 'Type of the content being sent.'
}).default('application/json');

/**
 * Environment to use. Used as part of the URL.
 */
export const zEnvironment = z.string().register(z.globalRegistry, {
    description: 'Environment to use. Used as part of the URL.'
}).default('vtexcommercestable');

/**
 * HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.
 */
export const zAccept = z.string().register(z.globalRegistry, {
    description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
}).default('application/json');

/**
 * A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.
 */
export const zSellerId = z.string().register(z.globalRegistry, {
    description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
});

/**
 * A string that identifies the seller's SKU that suffered the change. This is the ID that the marketplace will use for all  references to this SKU, such as price and inventory notifications.
 */
export const zSkuId = z.string().register(z.globalRegistry, {
    description: 'A string that identifies the seller\'s SKU that suffered the change. This is the ID that the marketplace will use for all  references to this SKU, such as price and inventory notifications.'
});

/**
 * Criteria used to sort the list of offers. For sorting values in ascending order, use `asc`, while for descending order, use `desc`. To fill in the field, insert the sorting criteria, followed by 'asc', or 'desc', separated by a comma. You can sort by the following criteria:
 *
 * - **price:** sorts offers by price. *Ascending* goes from lowest to highest price, while *Descending* goes from highest to lowest price.
 *
 * - **name:** sorts offers by *productName*, in alphabetical order. *Ascending* goes from *A* to *Z*, while *Descending* goes from *Z* to *A*.
 *
 * - **availability:** availability in the sales channel (sc). The default value is 1.
 *
 * Ex. sort=availability,desc
 *
 * Ex. sort=name,asc
 *
 * Ex. price,desc
 */
export const zSort = z.string().register(z.globalRegistry, {
    description: 'Criteria used to sort the list of offers. For sorting values in ascending order, use `asc`, while for descending order, use `desc`. To fill in the field, insert the sorting criteria, followed by \'asc\', or \'desc\', separated by a comma. You can sort by the following criteria: \n\n- **price:** sorts offers by price. *Ascending* goes from lowest to highest price, while *Descending* goes from highest to lowest price. \n\n- **name:** sorts offers by *productName*, in alphabetical order. *Ascending* goes from *A* to *Z*, while *Descending* goes from *Z* to *A*. \n\n- **availability:** availability in the sales channel (sc). The default value is 1. \n\nEx. sort=availability,desc \n\nEx. sort=name,asc \n\nEx. price,desc'
});

/**
 * Number of rows included in the response. Each row corresponds to a single offer. The default amount of rows in the response is 1, and the maximum amount is 50. To have more than one offer listed in the response, please add the `rows` parameter with a number greater than 1.
 */
export const zRows = z.int().register(z.globalRegistry, {
    description: 'Number of rows included in the response. Each row corresponds to a single offer. The default amount of rows in the response is 1, and the maximum amount is 50. To have more than one offer listed in the response, please add the `rows` parameter with a number greater than 1.'
});

/**
 * Number corresponding to the row from which the offer list will begin, used for pagination. Filters the list of offers by retrieving the offers starting from the row defined. The default value is 0, if the param is not included in the call.
 */
export const zStart = z.int().register(z.globalRegistry, {
    description: 'Number corresponding to the row from which the offer list will begin, used for pagination. Filters the list of offers by retrieving the offers starting from the row defined. The default value is 0, if the param is not included in the call.'
}).default(0);

/**
 * This filter query can be used to filter offers by the criteria described below. It should be filled in by following the format: `fq={{criteriaName}}:{{criteriaValue}}`.
 *
 * - **productId:** integer of the product ID
 *
 * - **productName:** string of the product's name
 *
 * - **skuId:** integer of the SKU ID
 *
 * - **eanId:** string of the EAN ID
 *
 * - **refId:** string of the Ref ID
 *
 * - **categoryId:** integer of the category ID
 *
 * - **brandId:** integer of the brand ID
 *
 * - **sellerId:** string of the seller ID
 *
 * - **sc:** integer of the sales channel's ID (trade policy in VTEX)
 *
 * Ex: skuId:172
 *
 * Ex: categoryId:13
 *
 * Ex. productName:Product example-123
 */
export const zFq = z.string().register(z.globalRegistry, {
    description: 'This filter query can be used to filter offers by the criteria described below. It should be filled in by following the format: `fq={{criteriaName}}:{{criteriaValue}}`. \n\n- **productId:** integer of the product ID \n\n- **productName:** string of the product\'s name \n\n- **skuId:** integer of the SKU ID \n\n- **eanId:** string of the EAN ID \n\n- **refId:** string of the Ref ID \n\n- **categoryId:** integer of the category ID \n\n- **brandId:** integer of the brand ID \n\n- **sellerId:** string of the seller ID \n\n- **sc:** integer of the sales channel\'s ID (trade policy in VTEX) \n\nEx: skuId:172 \n\nEx: categoryId:13 \n\nEx. productName:Product example-123'
});

/**
 * A string that identifies the seller's product. This is the ID that the marketplace will use for all references to this product, such as price and inventory notifications.
 */
export const zProductId = z.string().register(z.globalRegistry, {
    description: 'A string that identifies the seller\'s product. This is the ID that the marketplace will use for all references to this product, such as price and inventory notifications.'
});

/**
 * Marketplace's account name, the same one inputted on the endpoint's path.
 */
export const zAn = z.string().register(z.globalRegistry, {
    description: 'Marketplace\'s account name, the same one inputted on the endpoint\'s path.'
}).default('apiexamples');

/**
 * Sales channel (or [trade policy](https://help.vtex.com/en/tutorial/how-trade-policies-work--6Xef8PZiFm40kg2STrMkMV)) associated to the seller account created.
 */
export const zSc = z.string().register(z.globalRegistry, {
    description: 'Sales channel (or [trade policy](https://help.vtex.com/en/tutorial/how-trade-policies-work--6Xef8PZiFm40kg2STrMkMV)) associated to the seller account created.'
}).default('1');

/**
 * Filters sellers by their type, which can be regular seller (`1`) or whitelabel seller (`2`).
 */
export const zSellerType = z.int().register(z.globalRegistry, {
    description: 'Filters sellers by their type, which can be regular seller (`1`) or whitelabel seller (`2`).'
}).default(1);

/**
 * When set as `true`, the list returned will be of sellers who have a VTEX store configured. When set as `false`, the list will be of sellers who do not have a VTEX store configured.
 */
export const zIsVtex = z.boolean().register(z.globalRegistry, {
    description: 'When set as `true`, the list returned will be of sellers who have a VTEX store configured. When set as `false`, the list will be of sellers who do not have a VTEX store configured.'
}).default(false);

export const zPriceNotificationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        }),
        skuId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller\'s SKU that suffered the change. This is the ID that the marketplace will use for all  references to this SKU, such as price and inventory notifications.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zInventoryNotificationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        }),
        skuId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller\'s SKU that suffered the change. This is the ID that the marketplace will use for all  references to this SKU, such as price and inventory notifications.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zGetofferslistData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.optional(z.object({
        sort: z.optional(z.string().register(z.globalRegistry, {
            description: 'Criteria used to sort the list of offers. For sorting values in ascending order, use `asc`, while for descending order, use `desc`. To fill in the field, insert the sorting criteria, followed by \'asc\', or \'desc\', separated by a comma. You can sort by the following criteria: \n\n- **price:** sorts offers by price. *Ascending* goes from lowest to highest price, while *Descending* goes from highest to lowest price. \n\n- **name:** sorts offers by *productName*, in alphabetical order. *Ascending* goes from *A* to *Z*, while *Descending* goes from *Z* to *A*. \n\n- **availability:** availability in the sales channel (sc). The default value is 1. \n\nEx. sort=availability,desc \n\nEx. sort=name,asc \n\nEx. price,desc'
        })),
        rows: z.optional(z.int().register(z.globalRegistry, {
            description: 'Number of rows included in the response. Each row corresponds to a single offer. The default amount of rows in the response is 1, and the maximum amount is 50. To have more than one offer listed in the response, please add the `rows` parameter with a number greater than 1.'
        })),
        start: z.optional(z.int().register(z.globalRegistry, {
            description: 'Number corresponding to the row from which the offer list will begin, used for pagination. Filters the list of offers by retrieving the offers starting from the row defined. The default value is 0, if the param is not included in the call.'
        })).default(0),
        fq: z.optional(z.string().register(z.globalRegistry, {
            description: 'This filter query can be used to filter offers by the criteria described below. It should be filled in by following the format: `fq={{criteriaName}}:{{criteriaValue}}`. \n\n- **productId:** integer of the product ID \n\n- **productName:** string of the product\'s name \n\n- **skuId:** integer of the SKU ID \n\n- **eanId:** string of the EAN ID \n\n- **refId:** string of the Ref ID \n\n- **categoryId:** integer of the category ID \n\n- **brandId:** integer of the brand ID \n\n- **sellerId:** string of the seller ID \n\n- **sc:** integer of the sales channel\'s ID (trade policy in VTEX) \n\nEx: skuId:172 \n\nEx: categoryId:13 \n\nEx. productName:Product example-123'
        }))
    })),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zGetSkUoffersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        productId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller\'s product. This is the ID that the marketplace will use for all references to this product, such as price and inventory notifications.'
        }),
        skuId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller\'s SKU that suffered the change. This is the ID that the marketplace will use for all  references to this SKU, such as price and inventory notifications.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zGetProductoffersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        productId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller\'s product. This is the ID that the marketplace will use for all references to this product, such as price and inventory notifications.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zListSellerLeadsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.object({
        offset: z.int().register(z.globalRegistry, {
            description: 'This field determines the limit used to retrieve the list of sellers. The response includes objects starting `from` the value inputted here.'
        }).default(0),
        limit: z.int().register(z.globalRegistry, {
            description: 'This field determines the limit used to retrieve the list of sellers. The response includes objects until the value inputted here.            '
        }).default(15),
        isConnected: z.string().register(z.globalRegistry, {
            description: 'Query param that enables results to be filter by whether the seller lead is already connected to the marketplace or not.'
        }).default(''),
        search: z.string().register(z.globalRegistry, {
            description: 'Custom search field, that filters sellers invited by specific marketplace operator\'s  email.'
        }).default('user email'),
        status: z.string().register(z.globalRegistry, {
            description: 'Seller Lead\'s status. Includes `accepted`, `connected` or `invited`.'
        }).default('invited'),
        orderBy: z.string().register(z.globalRegistry, {
            description: 'Query param determining how data will be ordered in the response, ordering by name or ID in descending our ascending order. Includes the following values: \n\n`namesort` = desc/asc \n\n`idsort` = desc/asc'
        })
    }),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zCreateSellerLeadData = z.object({
    body: zCreateSellerLeadRequest,
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zRemoveSellerLeadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerLeadId: z.string().register(z.globalRegistry, {
            description: 'ID of the Seller Lead invited to the marketplace.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zRetrieveSellerLeadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zAcceptSellerLeadData = z.object({
    body: zAcceptSellerLeadRequest,
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zCreateSellerFromSellerLeadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        })
    }),
    query: z.optional(z.object({
        isActive: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Enables to filter sellers that are active (`true`) or unactive (`false`) in the marketplace.'
        })).default(false)
    })),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zResendSellerLeadRequestData = z.object({
    body: zResendSellerLeadRequestRequest,
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zListSellerCommissionsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zBulkUpsertSellerCommissionsData = z.object({
    body: z.array(zBulkUpsertSellerCommissionsRequest).register(z.globalRegistry, {
        description: 'Array with objects containing information about the category, seller and commission percentage to be applied.'
    }),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zRemoveSellerCommissionsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        }),
        categoryId: z.string().register(z.globalRegistry, {
            description: 'ID of the category in which the comission was applied'
        }).default('6')
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zRetrieveSellerCommissionsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. All data extracted, and changes added will be posted into this account.'
        }).default('apiexamples'),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace.'
        }).default('seller123'),
        categoryId: z.string().register(z.globalRegistry, {
            description: 'ID of the category in which the comission was applied'
        }).default('6')
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json')
    })
});

export const zGetListSellersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.optional(z.object({
        from: z.optional(z.number().register(z.globalRegistry, {
            description: 'The start number of pagination, being `0` the default value.'
        })).default(0),
        to: z.optional(z.number().register(z.globalRegistry, {
            description: 'The end number of pagination, being `100` the default value.'
        })).default(100),
        keyword: z.optional(z.string().register(z.globalRegistry, {
            description: 'Search sellers by a keyword in `sellerId` or `sellerName`.'
        })).default('keyword'),
        integration: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filters sellers by the name of who made the integration, if VTEX or an external hub. The possible values for VTEX integrations are: `vtex-sellerportal`, `vtex-seller` and `vtex-franchise`.'
        })).default('vtex-seller'),
        'group ': z.optional(z.string().register(z.globalRegistry, {
            description: 'Groups are defined by keywords that group sellers into categories defined by the marketplace.'
        })).default('Group'),
        isActive: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Enables to filter sellers that are active (`true`) or unactive (`false`) in the marketplace.'
        })).default(false),
        isBetterScope: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'The flag `isBetterScope` is used by the VTEX Checkout to simulate shopping carts, products, and shipping only in sellers with the field set as `true`, avoiding performance issues. When used as a query param, `isBetterScope` filters sellers that have the flag set as `true` or `false`.'
        })).default(false),
        isVtex: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'When set as `true`, the list returned will be of sellers who have a VTEX store configured. When set as `false`, the list will be of sellers who do not have a VTEX store configured.'
        })).default(false),
        sc: z.optional(z.string().register(z.globalRegistry, {
            description: 'Sales channel (or [trade policy](https://help.vtex.com/en/tutorial/how-trade-policies-work--6Xef8PZiFm40kg2STrMkMV)) associated to the seller account created.'
        })).default('1'),
        sellerType: z.optional(z.int().register(z.globalRegistry, {
            description: 'Filters sellers by their type, which can be regular seller (`1`) or whitelabel seller (`2`).'
        })).default(1),
        sort: z.optional(z.string().register(z.globalRegistry, {
            description: 'Criteria used to sort the list of offers. For sorting values in ascending order, use `asc`, while for descending order, use `desc`. To fill in the field, insert the sorting criteria, followed by \'asc\', or \'desc\', separated by a comma. You can sort by the following criteria: \n\n- **price:** sorts offers by price. *Ascending* goes from lowest to highest price, while *Descending* goes from highest to lowest price. \n\n- **name:** sorts offers by *productName*, in alphabetical order. *Ascending* goes from *A* to *Z*, while *Descending* goes from *Z* to *A*. \n\n- **availability:** availability in the sales channel (sc). The default value is 1. \n\nEx. sort=availability,desc \n\nEx. sort=name,asc \n\nEx. price,desc'
        }))
    })),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zUpsertSellerRequestData = z.object({
    body: zUpsertSellerRequest,
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zGetRetrieveSellerData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        })
    }),
    query: z.optional(z.object({
        sc: z.optional(z.string().register(z.globalRegistry, {
            description: 'Sales channel (or [trade policy](https://help.vtex.com/en/tutorial/how-trade-policies-work--6Xef8PZiFm40kg2STrMkMV)) associated to the seller account created.'
        })).default('1')
    })),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zUpdateSellerData = z.object({
    body: z.optional(z.array(z.object({
        operation: z.string().register(z.globalRegistry, {
            description: 'Action being performed, which should always be `replace`.'
        }),
        path: z.string().register(z.globalRegistry, {
            description: 'Path in which the value is being updated. It follows the standardized format `/{field}`, where `{field}` is the path\'s name.'
        }),
        value: z.boolean().register(z.globalRegistry, {
            description: 'Value that is being updated. Notice that the type will depend on the path that is being updated.'
        })
    }).register(z.globalRegistry, {
        description: 'Object representing the mapping configuration between the marketplace\'s sales channel and the seller\'s affiliate channel. This configuration allows for associating a marketplace sales channel with a seller\'s affiliate channel for proper sales channel management.'
    })).register(z.globalRegistry, {
        description: 'array of objects'
    })),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zRetrieveMappingData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        })
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Marketplace\'s account name, the same one inputted on the endpoint\'s path.'
        }).default('apiexamples')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zUpsertMappingData = z.object({
    body: z.array(zUpsertMappingRequest),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        })
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Marketplace\'s account name, the same one inputted on the endpoint\'s path.'
        }).default('apiexamples')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zGetFulfillmentPvtAffiliatesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zDeleteFulfillmentPvtAffiliatesByAffiliateIdData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        affiliateId: z.string().length(3).register(z.globalRegistry, {
            description: 'Three-letter identifier defined during the affiliate configuration creation.'
        }),
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zGetFulfillmentPvtAffiliatesByAffiliateIdData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        affiliateId: z.string().length(3).register(z.globalRegistry, {
            description: 'Three-letter identifier defined during the affiliate configuration creation. Vowels are not allowed.'
        }),
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

export const zPutFulfillmentPvtAffiliatesByAffiliateIdData = z.object({
    body: zRequestUpdateAffiliate,
    path: z.object({
        affiliateId: z.string().length(3).register(z.globalRegistry, {
            description: 'Three-letter identifier defined during the affiliate configuration creation.'
        }),
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. The notification will be posted into this account.'
        }),
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.optional(z.never()),
    headers: z.object({
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json'),
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }).default('application/json')
    })
});

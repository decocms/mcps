// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod';

/**
 * CreateChannel
 */
export const zCreateChannel = z.object({
    vendor: z.string().register(z.globalRegistry, {
        description: 'Name of the connector making the integration.'
    }).default('vtex'),
    name: z.string().register(z.globalRegistry, {
        description: 'Name of the channel with which the integration is being established.'
    }).default('Amazon'),
    logo: z.string().register(z.globalRegistry, {
        description: 'URL redirecting to the image file of the graphic symbol that identifies the marketplace. The file must in PNG format, and the image\'s dimension should be 300x300 pixels.'
    }).default('https://marketplace.com/logos/logo.png')
});

/**
 * CreateFeedRequest
 */
export const zCreateFeedRequest = z.object({
    id: z.string().register(z.globalRegistry, {
        description: 'The `feedId` attribute that identifies a feed between a seller and a channel, follows a standardized pattern that will be used by connectors when calling this endpoint. It follows the pattern `vendor.channel`.'
    }).default('vtex.amazon'),
    affiliateId: z.string().register(z.globalRegistry, {
        description: 'This attribute is created by the seller, in their VTEX store configuration.'
    }).default('MKP'),
    SalesChannels: z.optional(z.string().register(z.globalRegistry, {
        description: 'This attribute is created by the seller, in their VTEX store configuration.'
    })).default('1')
});

/**
 * UpdateFeedRequest
 */
export const zUpdateFeedRequest = z.object({
    affiliateId: z.string().register(z.globalRegistry, {
        description: 'Corresponds to the 3-digit [affiliate](https://help.vtex.com/en/tutorial/configuring-affiliates--tutorials_187) identification code created by the seller.'
    }).default('MKP'),
    salesChannels: z.string().register(z.globalRegistry, {
        description: 'This attribute is created by the seller, in their VTEX store configuration.'
    }).default('1')
});

/**
 * CreateInteractionRequest
 */
export const zCreateInteractionRequest = z.object({
    startDate: z.string().default('2020-10-29'),
    source: z.string().register(z.globalRegistry, {
        description: 'This attribute defines the entity responsible for the interaction. Possible values include `seller` or `channel`.'
    }).default('seller'),
    origin: z.string().register(z.globalRegistry, {
        description: 'This attribute defines where the interaction originated from. Possible values include `catalog`, `price` or `inventory`. Interactions are usually used to deal with a single type of process at a time. However, there are situations in which data about catalog, price and inventory are added in the same interaction.'
    }).default('catalog'),
    context: z.string().register(z.globalRegistry, {
        description: 'This field informs Sent Offers about an offer\'s lifecycle. When the integration has been recently installed, and producst are being sent for the first time, the value should be `setup`. If it\'s an update log, when the interaction is already up and running, the value should be `ongoing`.'
    }).default('setup')
});

/**
 * Evidence
 *
 * cURL with the call that the connector has made for a VTEX system. It will provide the evidence needed to contextualize the entry, if the user needs to fully understand the process ocurred, or solve any errors.
 */
export const zEvidence = z.object({
    request: z.string().register(z.globalRegistry, {
        description: 'cURL with the request call that the connector has made for a VTEX system. It will provide the evidence needed to contextualize the entry, if the user needs to fully understand the process ocurred, or solve any errors.'
    }).default('GET https://www.vtex.com'),
    response: z.string().register(z.globalRegistry, {
        description: 'cURL with the response of the call that the connector has made for a VTEX system. It will provide the evidence needed to contextualize the entry, if the user needs to fully understand the process occurred, or solve any errors.'
    }).default('200 Ok')
}).register(z.globalRegistry, {
    description: 'cURL with the call that the connector has made for a VTEX system. It will provide the evidence needed to contextualize the entry, if the user needs to fully understand the process ocurred, or solve any errors.'
});

/**
 * Data
 *
 * Data related to an offer, that will be updated or sent for the first time during setup.
 */
export const zData = z.object({
    externalOfferId: z.string().register(z.globalRegistry, {
        description: 'The ID used by the channel to identify this offer. Fill in this field if there are any updates in that ID.'
    }).default('123456'),
    inventory: z.string().register(z.globalRegistry, {
        description: 'Updated inventory level of that offer. Fill in this field if there are any updates in inventory.'
    }).default('33'),
    salesPrice: z.string().register(z.globalRegistry, {
        description: 'The value the offer is being sold for, on the channel. Fill in this field if there are any updates in price.'
    }).default('79.99'),
    currency: z.string().register(z.globalRegistry, {
        description: 'The currency applied to the offer\'s `salesPrice`. The international currency code should be used as value for this field. Fill in this field if there are any updates in price.'
    }).default('BRL'),
    status: z.string().register(z.globalRegistry, {
        description: 'The offer status can have the following values: \n\n`Synced`:  when offers are successfully sent to a channel and are currently being synced between both entities.\n\n`Sending`: intermediate state, when offers are still in the process of being sent to a channel. This status involves offers that are either sent for the first time to the marketplace, migrated to a new marketplace, or resent offers that were once deleted from a channel. \n\n`Error`: when Sent Offers finds an error that prevents sending or updating an offer to a channel. Therefore this status requires manual correction. \n\n`Disabled`: when the offer is discarded by the connector, by being inactive or not included in the trade policy,'
    }).default('disabled')
}).register(z.globalRegistry, {
    description: 'Data related to an offer, that will be updated or sent for the first time during setup.'
});

/**
 * Errors
 *
 * When Sent Offers, or the connectors, find an error that prevents sending or updating an offer to a channel, they should open a `failure` log, and fill in its details through this `errors` attribute. From the information sent through this attribute, sellers can identify and fix errors on their offers. Connectors must identify all errors, and send them all in a single request. This means that connectors should go through every possible validation, and only after all errors are identified, create the failure log.
 */
export const zErrors = z.object({
    code: z.string().register(z.globalRegistry, {
        description: 'The Search Errors endpoint returns the updated list of error codes. It is the only source of truth about the codes and where they will be always updated. Fill in this field with the code corresponding to the error identified.'
    }).default('CTLG-001'),
    externalCode: z.string().register(z.globalRegistry, {
        description: 'Connectors must extend the Sent Offers\' codes by adding their own code IDs for mapping specific scenarios that apply to their own system. They can send those codes through a suffix ID added in an existing code. This way the Sent Offers knows which errors must be archived and which errors must be kept, being able to classify that given error and improve its solving action. These suffix IDs are totally managed by the connectors, which will require them a way to map each error inside their own code.'
    }).default('284692'),
    title: z.string().register(z.globalRegistry, {
        description: 'Short text summarizing the error identified. It will be the title that appears in the Sent Offers\' UI.'
    }).default('Description includes HTML'),
    description: z.string().register(z.globalRegistry, {
        description: 'Short text giving more context about the error identified. It will be the description of the error mentioned in the title, also appearing in the Sent Offers\' UI.'
    }).default('Netshoes does not allow HTML tags in an offer\'s description. Access the product in your Catalog to remove the HTML tag.'),
    closableOrigins: z.array(z.unknown()).register(z.globalRegistry, {
        description: 'Values allowed in this field are `catalog`, `price` and `inventory`.'
    }).default(['catalog', 'price'])
}).register(z.globalRegistry, {
    description: 'When Sent Offers, or the connectors, find an error that prevents sending or updating an offer to a channel, they should open a `failure` log, and fill in its details through this `errors` attribute. From the information sent through this attribute, sellers can identify and fix errors on their offers. Connectors must identify all errors, and send them all in a single request. This means that connectors should go through every possible validation, and only after all errors are identified, create the failure log.'
});

/**
 * CreateLogRequest
 */
export const zCreateLogRequest = z.object({
    description: z.string().register(z.globalRegistry, {
        description: 'In this field, connectors should describe relevant information about the log, so Sent Offers users can better understand the action taking place.'
    }).default('Insert your message'),
    date: z.string().register(z.globalRegistry, {
        description: 'Logs follow a chronological timeline, so make sure the date included corresponds to the correct order of logs.'
    }).default('2020-03-22'),
    type: z.string().register(z.globalRegistry, {
        description: 'Connectors are responsible for attributing the correct type for each log. Therefore, be mindful of their correct usage. \n\n`success`: only logs that conclude an interaction’s goal should be `“type”=”success”`. \n\n`information`: logs that expose the actions of an update process, to provide visibility and contribute with more technical investigations. Information logs may include internal processes of a system (`agent` attribute), or calls between two systems. \n\n`warning`: logs used in cases where the communication between two systems fails, and there are no actions that the user can take to fix it. They are usually cases where the connector should perform a retry, and provide visibility of what is being attempted again. \n\n`failure`: logs noticed by the connector as errors that prevent an offer from being correctly sent and synced to a channel.'
    }).default('information'),
    agent: z.string().register(z.globalRegistry, {
        description: 'Entity responsible for creating the entry.'
    }).default('broadcaster'),
    evidence: zEvidence,
    data: zData,
    errors: zErrors
});

export const zCreateChannelData = z.object({
    body: zCreateChannel,
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the seller\'s VTEX account. Used as query param.'
        }).default('accountName')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zListFeedsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the Seller\'s VTEX account. Used as query param.'
        }).default('{{accountName}}')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zCreateFeedData = z.object({
    body: zCreateFeedRequest,
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as query param.'
        }).default('{{accountName}}')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zDeleteFeedData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        feedId: z.string().register(z.globalRegistry, {
            description: 'The `feedId` attribute that identifies a feed between a seller and a channel, follows a standardized pattern that will be used by connectors when establishing the connection between the two. It follows the pattern `vendor.channel`.'
        }).default('vtex.amazon')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as query param.'
        }).default('{{accountName}}')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zRetrieveFeedData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        feedId: z.string().register(z.globalRegistry, {
            description: 'The `feedId` attribute that identifies a feed between a seller and a channel, follows a standardized pattern that will be used by connectors when establishing the connection between the two. It follows the pattern `vendor.channel`.'
        }).default('vtex.amazon')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as query param.'
        }).default('{{accountName}}')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zUpdateFeedData = z.object({
    body: zUpdateFeedRequest,
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        feedId: z.string().register(z.globalRegistry, {
            description: 'The `feedId` attribute that identifies a feed between a seller and a channel, follows a standardized pattern that will be used by connectors when establishing the connection between the two. It follows the pattern `vendor.channel`.'
        }).default('vtex.amazon')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as query param.'
        }).default('{{accountName}}')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zCreateInteractionData = z.object({
    body: zCreateInteractionRequest,
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        feedId: z.string().register(z.globalRegistry, {
            description: 'The `feedId` attribute that identifies a feed between a seller and a channel, follows a standardized pattern that will be used by connectors when establishing the connection between the two. It follows the pattern `vendor.channel`.'
        }).default('vtex.amazon'),
        skuId: z.string().register(z.globalRegistry, {
            description: 'This attribute is the SKU ID in the seller\'s perspective, registered in their VTEX Catalog.'
        }).default('1234')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as query param.'
        }).default('{{accountName}}')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zRetrieveInteractionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        feedId: z.string().register(z.globalRegistry, {
            description: 'The `feedId` attribute that identifies a feed between a seller and a channel, follows a standardized pattern that will be used by connectors when establishing the connection between the two. It follows the pattern `vendor.channel`.'
        }).default('vtex.amazon'),
        skuId: z.string().register(z.globalRegistry, {
            description: 'This attribute is the SKU ID in the seller\'s perspective, registered in their VTEX Catalog.'
        }).default('1234'),
        interactionId: z.string().register(z.globalRegistry, {
            description: 'This attribute is the code used to identify an existing interaction.'
        }).default('d3rdjjf094ma0do')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as query param.'
        }).default('{{accountName}}')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zCloseInteractionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        feedId: z.string().register(z.globalRegistry, {
            description: 'The `feedId` attribute that identifies a feed between a seller and a channel, follows a standardized pattern that will be used by connectors when establishing the connection between the two. It follows the pattern `vendor.channel`.'
        }).default('vtex.amazon'),
        skuId: z.string().register(z.globalRegistry, {
            description: 'This attribute is the SKU ID in the seller\'s perspective, registered in their VTEX Catalog.'
        }).default('1234'),
        interactionId: z.string().register(z.globalRegistry, {
            description: 'This attribute is the code used to identify an existing interaction.'
        }).default('d3rdjjf094ma0do')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as query param.'
        }).default('{{accountName}}')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zCreateLogData = z.object({
    body: zCreateLogRequest,
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        feedId: z.string().register(z.globalRegistry, {
            description: 'The `feedId` attribute that identifies a feed between a seller and a channel, follows a standardized pattern that will be used by connectors when establishing the connection between the two. It follows the pattern `vendor.channel`.'
        }).default('vtex.amazon'),
        skuId: z.string().register(z.globalRegistry, {
            description: 'This attribute is the SKU ID in the seller\'s perspective, registered in their VTEX Catalog.'
        }).default('1234'),
        interactionId: z.string().register(z.globalRegistry, {
            description: 'This attribute is the code used to identify an existing interaction.'
        }).default('d3rdjjf094ma0do')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as query param.'
        }).default('{{accountName}}')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zRetrieveLogData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        feedId: z.string().register(z.globalRegistry, {
            description: 'The `feedId` attribute that identifies a feed between a seller and a channel, follows a standardized pattern that will be used by connectors when establishing the connection between the two. It follows the pattern `vendor.channel`.'
        }).default('vtex.amazon'),
        skuId: z.string().register(z.globalRegistry, {
            description: 'This attribute is the SKU ID in the seller\'s perspective, registered in their VTEX Catalog.'
        }).default('1234'),
        interactionId: z.string().register(z.globalRegistry, {
            description: 'This attribute is the code used to identify an existing interaction.'
        }).default('d3rdjjf094ma0do'),
        logId: z.string().register(z.globalRegistry, {
            description: 'A log\'s identifying code. This attribute is obtained from the Open Log API, or from the response of a Search Interactions API.'
        }).default('123456')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as query param.'
        }).default('{{accountName}}')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zSearchInteractionsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as a query param.'
        }).default('{{accountName}}'),
        q: z.string().register(z.globalRegistry, {
            description: 'Customizable field for searching interactions.'
        }).default('{{query}}'),
        channels: z.optional(z.string().register(z.globalRegistry, {
            description: 'Search interactions, filtering by channel.'
        })).default('{{channelName}}'),
        brand: z.optional(z.string().register(z.globalRegistry, {
            description: 'Search interactions, filtering by brand.'
        })),
        category: z.optional(z.string().register(z.globalRegistry, {
            description: 'Search interactions, filtering by category.'
        })),
        scope: z.optional(z.string().register(z.globalRegistry, {
            description: 'Search interactions, filtering by scope.'
        })),
        result: z.optional(z.string().register(z.globalRegistry, {
            description: 'Search interactions, filtering by result. Results can have the following values: \n\nSuccess: When events close their lifecycle successfully, and generate updates on an offer in terms of price, inventory, or catalog. \n\nFailure: When the connector has detected processes that have failed to be made  due to an error. \n\nNotification: When there are processes with the connector that are worth mentioning, but there are no actual updates. Ex: discarded updates or sendings of an offer. \n\nProcessing:  When an open interaction has not been concluded, and should still receive more steps. This is a transitory state, considering that when an interaction is closed, it can only end with `success`, `failure` or `notification` as its result.'
        })).default('{{result}}'),
        sort: z.string().register(z.globalRegistry, {
            description: 'Search interactions filtering by sort.'
        }),
        from: z.string().register(z.globalRegistry, {
            description: 'Search interactions from a given point.'
        }),
        to: z.string().register(z.globalRegistry, {
            description: 'Search interactions until a given point.'
        }),
        fromDate: z.string().register(z.globalRegistry, {
            description: 'Search interactions from a specific date.'
        }),
        toDate: z.string().register(z.globalRegistry, {
            description: 'Search interactions until a given date.'
        })
    })
});

export const zSearchErrorsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable')
    }),
    query: z.object({
        an: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as query param.'
        }).default('{{accountName}}'),
        q: z.string().register(z.globalRegistry, {
            description: 'Customizable field for searching error codes.'
        }).default('{{query}}'),
        channels: z.string().register(z.globalRegistry, {
            description: 'Search errors filtering by channels.'
        }).default('{{channels}}'),
        brand: z.string().register(z.globalRegistry, {
            description: 'Search errors filtering by brand.'
        }).default('{{brand}}'),
        category: z.string().register(z.globalRegistry, {
            description: 'Search errors filtering by category.'
        }).default('{{category}}'),
        errorCategory: z.string().register(z.globalRegistry, {
            description: 'Search errors filtering by error category.'
        }).default('{{errorCategory}}'),
        sort: z.string().register(z.globalRegistry, {
            description: 'Pagination that returns a range of ordered error codes.'
        }).default('{{sort}}'),
        from: z.string().register(z.globalRegistry, {
            description: 'Pagination that returns error codes from a given point.'
        }).default('{{from}}'),
        to: z.string().register(z.globalRegistry, {
            description: 'Pagination that returns error codes until a given point.'
        }).default('{{to}}')
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

export const zRetrieveErrorCodeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        environment: z.string().register(z.globalRegistry, {
            description: 'Environment to use. Used as part of the URL.'
        }).default('vtexcommercestable'),
        errorCodeId: z.string().register(z.globalRegistry, {
            description: 'Id for the error code chosen.'
        }).default('errorId')
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.'
        }).default('application/json')
    })
});

// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.myvtex.com' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.myvtex.com' | (string & {});
};

/**
 * Request body for creating or updating a dimension.
 */
export type CreateUpdateDimensionRequestBody = {
    /**
     * Name of the dimension.
     */
    name: string;
    /**
     * When set as `true`, all listed rules must be accepted for the dimension to be approved. When set as `false`, the first matching rule that evaluates to `true` will be executed.
     */
    requireAllRulesAcceptance: boolean;
    /**
     * Identifier of the organization unit this dimension belongs to. Each unit can have one dimension. This field is required when using `appKey/appToken` authentication.
     */
    unitId?: string;
    /**
     * Dimension priority controls which organization unit's policies are evaluated in which order. Lower priority numbers are evaluated first. For hierarchical policies, assign descending priorities by hierarchy level (e.g., 9999 = top unit, 9998 = child units, 9997 = grandchild units) so lower-level org units are checked first. Sibling units share the same priority.
     */
    priority: number;
    /**
     * List of rules that define conditions and actions.
     */
    ruleCollection: Array<{
        /**
         * Name of the rule.
         */
        name: string;
        /**
         * Rule priority controls which policy type is checked first within the org unit. Lower numbers are evaluated first. You can have bypass rules and immediately approve orders by matching effect types with fixed priorities: `1` = bypass (effectType: 0), `2` = deny (effectType: 1), `3` = sequential workflow (effectType: 2).
         */
        priority: number;
        /**
         * Defines the condition and effect that trigger the rule.
         */
        trigger: {
            /**
             * Condition that must be met to trigger the rule.
             */
            condition: {
                /**
                 * Type of condition, which can be `0` (bypass), `1` (deny) or `2` (sequential workflow). Type `2` defines that the rule condition is set by an expression (see field `expression`).
                 */
                conditionType: 0 | 1 | 2;
                /**
                 * Description of the condition.
                 */
                description: string;
                /**
                 * JSONata expression that defines the condition logic. The expression is evaluated against the order payload, which includes fields like `orderId`, `items`, `value`, `budgetData`, `marketPlaceOrderId`, and other order properties. See [JSONata documentation](https://jsonata.org/) for expression syntax and available operators.
                 */
                expression: string;
            };
            /**
             * Effect to apply when the condition is met.
             */
            effect: {
                /**
                 * Description of the effect.
                 */
                description: string;
                /**
                 * Type of effect. Possible values are: `0` (approve), `1` (deny), or `2` (pending, which means it requires manual approval).
                 */
                effectType: 0 | 1 | 2;
            };
        };
        /**
         * Defines acceptance and denial thresholds used during manual authorization via the [Accept or deny rule](https://developers.vtex.com/docs/api-reference/buying-policies-api#post-/commercial-authorizations/-orderAuthId-/callback) endpoint.
         */
        scoreInterval: {
            /**
             * Minimum score required to accept the rule.
             */
            accept: number;
            /**
             * Maximum score to deny the rule.
             */
            deny: number;
        };
        /**
         * Defines required authorizers and whether all must approve. Only applicable for rules with `effectType: 2` (pending). Supports both `unit` and `user` authorizers.
         */
        authorizationData?: {
            /**
             * When set as `true`, all authorizers must approve. When set as `false`, approval from any single authorizer is sufficient.
             */
            requireAllApprovals?: boolean;
            /**
             * List of entities that can authorize the action.
             */
            authorizers?: Array<Authorizer>;
        };
    }>;
};

/**
 * Object for creating or updating rules.
 */
export type CreateUpdateRuleRequestBody = {
    /**
     * Name of the rule.
     */
    name: string;
    /**
     * Rule priority controls which policy type is checked first within the org unit. Lower numbers are evaluated first. You can have bypass rules and immediately approve orders by matching effect types with fixed priorities: `1` = bypass (effectType: 0), `2` = deny (effectType: 1), `3` = sequential workflow (effectType: 2).
     */
    priority: number;
    /**
     * Defines the condition and effect that trigger the rule.
     */
    trigger: {
        /**
         * Condition that must be met to trigger the rule.
         */
        condition: {
            /**
             * Type of condition, which can be `0` (bypass), `1` (deny) or `2` (sequential workflow). Type `2` defines that the rule condition is set by an expression (see field `expression`).
             */
            conditionType: 0 | 1 | 2;
            /**
             * Description of the condition being evaluated.
             */
            description: string;
            /**
             * JSONata expression that defines the condition logic. The expression is evaluated against the order payload, which includes fields like `orderId`, `items`, `value`, `budgetData`, `marketPlaceOrderId`, and other order properties. See [JSONata documentation](https://jsonata.org/) for expression syntax and available operators.
             */
            expression?: string;
        };
        /**
         * Effect to apply when the condition is met.
         */
        effect: {
            /**
             * Description of the effect to be applied if condition is met.
             */
            description: string;
            /**
             * Type of effect. Possible values are: `0` (approve), `1` (deny), or `2` (pending, which means it requires manual approval/denial).
             */
            effectType: 0 | 1 | 2;
        };
    };
    /**
     * Defines acceptance and denial thresholds used during manual authorization via the [Accept or deny rule](https://developers.vtex.com/docs/api-reference/buying-policies-api#post-/commercial-authorizations/-orderAuthId-/callback) endpoint.
     */
    scoreInterval: {
        /**
         * Minimum score required to accept the rule.
         */
        accept: number;
        /**
         * Maximum score to deny the rule.
         */
        deny: number;
    };
    /**
     * Defines required authorizers and whether all must approve. Only applicable for rules with `effectType: 2` (pending). Supports both `unit` and `user` authorizers.
     */
    authorizationData?: {
        /**
         * When set as `true`, all authorizers must approve. When set as `false`, approval from any single authorizer is sufficient.
         */
        requireAllApprovals?: boolean;
        /**
         * List of entities that can authorize the action.
         */
        authorizers?: Array<Authorizer>;
    };
};

/**
 * Error response object.
 */
export type ErrorResponse = {
    /**
     * Error message describing what went wrong.
     */
    message?: string;
};

/**
 * Entity that can authorize an action.
 */
export type Authorizer = {
    /**
     * Type of authorizer. For Organization Account, it's always `unit`.
     */
    type: string;
    /**
     * Unique identifier of the authorizer.
     */
    id: string;
};

/**
 * Response object for an authorization dimension.
 */
export type DimensionResponse = {
    /**
     * Unique identifier of the dimension.
     */
    id?: string;
    /**
     * Name of the authorization dimension.
     */
    name?: string;
    /**
     * Identifier of the business unit this dimension belongs to. If this field is not provided in the request body, the value will default to the business unit associated with the user token from the `VtexIdclientAutCookie`.
     */
    unitId?: string;
    /**
     * Current status of the dimension.
     */
    status?: null | 'accepted' | 'denied' | 'pending' | 'ignored';
    /**
     * Execution priority of the dimension. Lower numbers are evaluated first.
     */
    priority?: number;
    /**
     * Whether all listed rules must be accepted for the dimension to be approved.
     */
    requireAllRulesAcceptance?: boolean;
    /**
     * Collection of rules contained in this dimension.
     */
    ruleCollection?: Array<RuleResponse>;
    /**
     * Date and time of dimension creation in the format `YYYY-MM-DDThh:mm:ssZ`.
     */
    creationDate?: string;
    /**
     * Version of the system that created the dimension.
     */
    creationVersion?: string;
    /**
     * Environment where the dimension was created (e.g., `stable`, `beta`).
     */
    creationEnvironment?: string;
};

/**
 * Rule object in the response containing conditions and actions for authorization.
 */
export type RuleResponse = {
    /**
     * Unique identifier of the rule.
     */
    id?: string;
    /**
     * Name of the rule.
     */
    name?: string;
    /**
     * Current status of the rule.
     */
    status?: null | 'accepted' | 'denied' | 'pending';
    /**
     * Evaluation priority for the rule.
     */
    priority?: number;
    /**
     * Contains the trigger condition and effect logic.
     */
    trigger?: {
        /**
         * Condition that must be met to trigger the rule.
         */
        condition?: {
            /**
             * Type of condition, which can be `0` (bypass), `1` (deny) or `2` (sequential workflow). Type `2` defines that the rule condition is set by an expression (see field `expression`).
             */
            conditionType?: 0 | 1 | 2;
            /**
             * Description of the condition.
             */
            description?: string;
            /**
             * JSONata expression that defines the condition logic.
             */
            expression?: string;
        };
        /**
         * Effect to apply when the condition is met.
         */
        effect?: {
            /**
             * Description of the effect.
             */
            description?: string;
            /**
             * Type of effect: `0` (approve), `1` (deny), or `2` (pending).
             */
            effectType?: 0 | 1 | 2;
        };
    };
    /**
     * Score range for accepting or denying the rule.
     */
    scoreInterval?: {
        /**
         * Minimum score required to accept the rule.
         */
        accept?: number;
        /**
         * Maximum score to deny the rule.
         */
        deny?: number;
    };
    /**
     * Defines required authorizers and whether all must approve (only present for rules with `effectType: 2`).
     */
    authorizationData?: {
        /**
         * Whether all authorizers must approve.
         */
        requireAllApprovals?: boolean;
        /**
         * List of entities that can authorize the action.
         */
        authorizers?: Array<Authorizer>;
    };
};

/**
 * Type of the content being sent.
 */
export type ContentType = string;

/**
 * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
 */
export type Accept = string;

/**
 * Name of the VTEX account.
 */
export type AccountName = string;

/**
 * Unique identifier for the authorization dimension.
 */
export type DimensionId = string;

/**
 * Unique identifier for the dimension rule.
 */
export type RuleId = string;

/**
 * Unique identifier for the order authorization request.
 */
export type OrderAuthId = string;

export type GetByAccountNameAuthorizationDimensionsData = {
    body?: never;
    headers: {
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Name of the VTEX account.
         */
        accountName: string;
    };
    query?: {
        /**
         * Filters by dimension ID(s). Supports exact matching, case-insensitive. You can pass multiple values by repeating the parameter.
         */
        id?: Array<string>;
        /**
         * Filters by organizational unit ID(s). Supports exact matching, case-insensitive. You can pass multiple values by repeating the parameter.
         */
        unitId?: Array<string>;
        /**
         * Filters by dimension name(s). Supports exact matching, case-insensitive. You can pass multiple values by repeating the parameter.
         */
        name?: Array<string>;
    };
    url: '/{accountName}/authorization-dimensions';
};

export type GetByAccountNameAuthorizationDimensionsErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse;
};

export type GetByAccountNameAuthorizationDimensionsError = GetByAccountNameAuthorizationDimensionsErrors[keyof GetByAccountNameAuthorizationDimensionsErrors];

export type GetByAccountNameAuthorizationDimensionsResponses = {
    /**
     * OK
     */
    200: Array<{
        /**
         * Unique identifier of the dimension.
         */
        id?: string;
        /**
         * Name of the authorization dimension.
         */
        name?: string;
        /**
         * Identifier of the business unit this dimension belongs to.
         */
        unitId?: string;
        /**
         * Current status of the dimension.
         */
        status?: null | 'accepted' | 'denied' | 'pending' | 'ignored';
        /**
         * Execution priority of the dimension. Lower numbers are evaluated first.
         */
        priority?: number;
        /**
         * Whether all listed rules must be accepted for the dimension to be approved.
         */
        requireAllRulesAcceptance?: boolean;
        /**
         * Indicates if the rules should be simulated instead of enforced.
         */
        shouldSimulate?: boolean;
        /**
         * Collection of rules contained in this dimension.
         */
        ruleCollection?: Array<{
            /**
             * Unique identifier of the rule.
             */
            id?: string;
            /**
             * Name of the rule.
             */
            name?: string;
            /**
             * Current status of the rule.
             */
            status?: null | 'accepted' | 'denied' | 'pending';
            /**
             * Evaluation priority for the rule.
             */
            priority?: number;
            /**
             * Contains the trigger condition and effect logic.
             */
            trigger?: {
                /**
                 * Condition that must be met to trigger the rule.
                 */
                condition?: {
                    /**
                     * Type of condition, which can be `0` (bypass), `1` (deny) or `2` (sequential workflow). Type `2` defines that the rule condition is set by an expression (see field `expression`).
                     */
                    conditionType?: 0 | 1 | 2;
                    /**
                     * Description of the condition.
                     */
                    description?: string;
                    /**
                     * JSONata expression that defines the condition logic.
                     */
                    expression?: string;
                };
                /**
                 * Effect to apply when the condition is met.
                 */
                effect?: {
                    /**
                     * Description of the effect.
                     */
                    description?: string;
                    /**
                     * Type of effect: `0` (approve), `1` (deny), or `2` (pending).
                     */
                    effectType?: 0 | 1 | 2;
                };
            };
            /**
             * Time in milliseconds to wait for rule evaluation.
             */
            timeout?: number;
            /**
             * Whether a notification should be triggered (`true`) or not (`false`).
             */
            notification?: boolean;
            /**
             * Score range for accepting or denying the rule.
             */
            scoreInterval?: {
                /**
                 * Minimum score required to accept the rule.
                 */
                accept?: number;
                /**
                 * Maximum score to deny the rule.
                 */
                deny?: number;
            };
            /**
             * Defines required authorizers and whether all must approve (only present for rules with `effectType: 2`).
             */
            authorizationData?: {
                /**
                 * Whether all authorizers must approve (`true`) or not (`false`).
                 */
                requireAllApprovals?: boolean;
                /**
                 * List of entities that can authorize the action.
                 */
                authorizers?: Array<Authorizer>;
            };
        }>;
        /**
         * Date and time of dimension creation in the format `YYYY-MM-DDThh:mm:ssZ`.
         */
        creationDate?: string;
        /**
         * Version of the system that created the dimension.
         */
        creationVersion?: string;
        /**
         * Environment where the dimension was created (e.g., `stable`, `beta`).
         */
        creationEnvironment?: string;
    }>;
};

export type GetByAccountNameAuthorizationDimensionsResponse = GetByAccountNameAuthorizationDimensionsResponses[keyof GetByAccountNameAuthorizationDimensionsResponses];

export type PostByAccountNameAuthorizationDimensionsData = {
    body?: CreateUpdateDimensionRequestBody;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Name of the VTEX account.
         */
        accountName: string;
    };
    query?: never;
    url: '/{accountName}/authorization-dimensions';
};

export type PostByAccountNameAuthorizationDimensionsErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
};

export type PostByAccountNameAuthorizationDimensionsError = PostByAccountNameAuthorizationDimensionsErrors[keyof PostByAccountNameAuthorizationDimensionsErrors];

export type PostByAccountNameAuthorizationDimensionsResponses = {
    /**
     * OK
     */
    200: DimensionResponse;
};

export type PostByAccountNameAuthorizationDimensionsResponse = PostByAccountNameAuthorizationDimensionsResponses[keyof PostByAccountNameAuthorizationDimensionsResponses];

export type DeleteByAccountNameAuthorizationDimensionsByDimensionIdData = {
    body?: never;
    headers: {
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Name of the VTEX account.
         */
        accountName: string;
        /**
         * Unique identifier for the authorization dimension.
         */
        dimensionId: string;
    };
    query?: never;
    url: '/{accountName}/authorization-dimensions/{dimensionId}';
};

export type DeleteByAccountNameAuthorizationDimensionsByDimensionIdErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Not Found
     */
    404: ErrorResponse;
};

export type DeleteByAccountNameAuthorizationDimensionsByDimensionIdError = DeleteByAccountNameAuthorizationDimensionsByDimensionIdErrors[keyof DeleteByAccountNameAuthorizationDimensionsByDimensionIdErrors];

export type DeleteByAccountNameAuthorizationDimensionsByDimensionIdResponses = {
    /**
     * No Content
     *
     * Dimension successfully deleted.
     */
    204: void;
};

export type DeleteByAccountNameAuthorizationDimensionsByDimensionIdResponse = DeleteByAccountNameAuthorizationDimensionsByDimensionIdResponses[keyof DeleteByAccountNameAuthorizationDimensionsByDimensionIdResponses];

export type PutByAccountNameAuthorizationDimensionsByDimensionIdData = {
    body?: CreateUpdateDimensionRequestBody;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Name of the VTEX account.
         */
        accountName: string;
        /**
         * Unique identifier for the authorization dimension.
         */
        dimensionId: string;
    };
    query?: never;
    url: '/{accountName}/authorization-dimensions/{dimensionId}';
};

export type PutByAccountNameAuthorizationDimensionsByDimensionIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Not Found
     */
    404: ErrorResponse;
};

export type PutByAccountNameAuthorizationDimensionsByDimensionIdError = PutByAccountNameAuthorizationDimensionsByDimensionIdErrors[keyof PutByAccountNameAuthorizationDimensionsByDimensionIdErrors];

export type PutByAccountNameAuthorizationDimensionsByDimensionIdResponses = {
    /**
     * OK
     */
    200: DimensionResponse;
};

export type PutByAccountNameAuthorizationDimensionsByDimensionIdResponse = PutByAccountNameAuthorizationDimensionsByDimensionIdResponses[keyof PutByAccountNameAuthorizationDimensionsByDimensionIdResponses];

export type PostByAccountNameAuthorizationDimensionsByDimensionIdRulesData = {
    body?: CreateUpdateRuleRequestBody;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Name of the VTEX account.
         */
        accountName: string;
        /**
         * Unique identifier for the authorization dimension.
         */
        dimensionId: string;
    };
    query?: never;
    url: '/{accountName}/authorization-dimensions/{dimensionId}/rules';
};

export type PostByAccountNameAuthorizationDimensionsByDimensionIdRulesErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Not Found
     */
    404: ErrorResponse;
};

export type PostByAccountNameAuthorizationDimensionsByDimensionIdRulesError = PostByAccountNameAuthorizationDimensionsByDimensionIdRulesErrors[keyof PostByAccountNameAuthorizationDimensionsByDimensionIdRulesErrors];

export type PostByAccountNameAuthorizationDimensionsByDimensionIdRulesResponses = {
    /**
     * OK
     */
    200: RuleResponse;
};

export type PostByAccountNameAuthorizationDimensionsByDimensionIdRulesResponse = PostByAccountNameAuthorizationDimensionsByDimensionIdRulesResponses[keyof PostByAccountNameAuthorizationDimensionsByDimensionIdRulesResponses];

export type PutByAccountNameAuthorizationDimensionsByDimensionIdRulesData = {
    body?: Array<CreateUpdateRuleRequestBody>;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Name of the VTEX account.
         */
        accountName: string;
        /**
         * Unique identifier for the authorization dimension.
         */
        dimensionId: string;
    };
    query?: never;
    url: '/{accountName}/authorization-dimensions/{dimensionId}/rules';
};

export type PutByAccountNameAuthorizationDimensionsByDimensionIdRulesErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Not Found
     */
    404: ErrorResponse;
};

export type PutByAccountNameAuthorizationDimensionsByDimensionIdRulesError = PutByAccountNameAuthorizationDimensionsByDimensionIdRulesErrors[keyof PutByAccountNameAuthorizationDimensionsByDimensionIdRulesErrors];

export type PutByAccountNameAuthorizationDimensionsByDimensionIdRulesResponses = {
    /**
     * OK
     */
    200: Array<RuleResponse>;
};

export type PutByAccountNameAuthorizationDimensionsByDimensionIdRulesResponse = PutByAccountNameAuthorizationDimensionsByDimensionIdRulesResponses[keyof PutByAccountNameAuthorizationDimensionsByDimensionIdRulesResponses];

export type DeleteByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdData = {
    body?: never;
    headers: {
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Name of the VTEX account.
         */
        accountName: string;
        /**
         * Unique identifier for the authorization dimension.
         */
        dimensionId: string;
        /**
         * Unique identifier for the dimension rule.
         */
        ruleId: string;
    };
    query?: never;
    url: '/{accountName}/authorization-dimensions/{dimensionId}/rules/{ruleId}';
};

export type DeleteByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Not Found
     */
    404: ErrorResponse;
};

export type DeleteByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdError = DeleteByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdErrors[keyof DeleteByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdErrors];

export type DeleteByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdResponses = {
    /**
     * No Content
     *
     * Rule successfully deleted.
     */
    204: void;
};

export type DeleteByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdResponse = DeleteByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdResponses[keyof DeleteByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdResponses];

export type PutByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdData = {
    body?: CreateUpdateRuleRequestBody;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Name of the VTEX account.
         */
        accountName: string;
        /**
         * Unique identifier for the authorization dimension.
         */
        dimensionId: string;
        /**
         * Unique identifier for the dimension rule.
         */
        ruleId: string;
    };
    query?: never;
    url: '/{accountName}/authorization-dimensions/{dimensionId}/rules/{ruleId}';
};

export type PutByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Not Found
     */
    404: ErrorResponse;
};

export type PutByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdError = PutByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdErrors[keyof PutByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdErrors];

export type PutByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdResponses = {
    /**
     * OK
     */
    200: RuleResponse;
};

export type PutByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdResponse = PutByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdResponses[keyof PutByAccountNameAuthorizationDimensionsByDimensionIdRulesByRuleIdResponses];

export type PostCommercialAuthorizationsByOrderAuthIdCallbackData = {
    body?: {
        /**
         * Information to deny or accept a rule from a given dimension.
         */
        params: {
            /**
             * Score value to determine the authorization outcome. The score is compared against the rule's `scoreInterval` thresholds: scores ≥ `scoreInterval.accept` accept the rule, scores ≤ `scoreInterval.deny` deny it. For standard frontend values (`accept: 10`, `deny: 5`), use `10` to accept or `0` to deny a rule.
             */
            score: number;
            /**
             * Identifier of the dimension being evaluated.
             */
            dimensionId: string;
            /**
             * Identifier of the rule associated with the dimension.
             */
            ruleId: string;
        };
    };
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Unique identifier for the order authorization request.
         */
        orderAuthId: string;
    };
    query?: never;
    url: '/commercial-authorizations/{orderAuthId}/callback';
};

export type PostCommercialAuthorizationsByOrderAuthIdCallbackErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Not Found
     */
    404: ErrorResponse;
};

export type PostCommercialAuthorizationsByOrderAuthIdCallbackError = PostCommercialAuthorizationsByOrderAuthIdCallbackErrors[keyof PostCommercialAuthorizationsByOrderAuthIdCallbackErrors];

export type PostCommercialAuthorizationsByOrderAuthIdCallbackResponses = {
    /**
     * OK
     */
    200: {
        /**
         * Unique identifier of the approval request.
         */
        id?: string;
        /**
         * Identifier of the order linked to this approval process.
         */
        orderId?: string;
        /**
         * Identifier of the workflow instance.
         */
        workflowInstanceId?: string;
        /**
         * Current status of the authorization.
         */
        status?: null | 'accepted' | 'denied' | 'pending';
        /**
         * List of unit identifiers related to the approval request.
         */
        units?: Array<string>;
        /**
         * Callback URL for order authorization status updates.
         */
        callbackEndpoint?: string;
        /**
         * Total value of the order as expected by the seller.
         */
        totalOrderValueDesiredBySeller?: number;
        /**
         * Value of the order payment in the marketplace.
         */
        marketPlacePaymentValue?: number;
        /**
         * List of items in the order.
         */
        itemCollection?: Array<{
            /**
             * Unique identifier of the item in the approval process.
             */
            id?: string;
            /**
             * SKU identifier of the item.
             */
            sku?: string;
            /**
             * Item price.
             */
            price?: number;
            /**
             * Discount automatically applied by the system.
             */
            totalSystemDiscount?: number;
            /**
             * Discount manually applied.
             */
            totalManualDiscount?: number;
            /**
             * Quantity of the item.
             */
            quantity?: number;
            /**
             * Additional information about the item.
             */
            additionalInfo?: {
                /**
                 * Commercial condition identifier.
                 */
                commercialCondition?: string;
            };
        }>;
        /**
         * Extra information related to the request.
         */
        additionalInfo?: {
            /**
             * Identifier of the user profile linked to this approval request.
             */
            userProfileId?: string;
        };
        /**
         * Approval status details per dimension.
         */
        dimensionStatus?: Array<{
            /**
             * Unique identifier of the dimension status record.
             */
            id?: string;
            /**
             * Dimension name.
             */
            name?: string;
            /**
             * Unit identifier related to this dimension.
             */
            unitId?: string;
            /**
             * User profile identifier related to this dimension.
             */
            userProfileId?: string;
            /**
             * Current status of the dimension.
             */
            status?: null | 'accepted' | 'denied' | 'pending';
            /**
             * Score assigned to the dimension.
             */
            score?: number;
            /**
             * Priority of this dimension (lower = higher priority).
             */
            priority?: number;
            /**
             * Indicates if this dimension should be simulated before application.
             */
            shouldSimulate?: boolean;
            /**
             * Rules applied to this dimension.
             */
            ruleCollection?: Array<{
                /**
                 * Unique identifier of the rule.
                 */
                id?: string;
                /**
                 * Rule name.
                 */
                name?: string;
                /**
                 * Current status of the rule.
                 */
                status?: null | 'accepted' | 'denied' | 'pending';
                /**
                 * Optional decision object identifier.
                 */
                doId?: string | null;
                /**
                 * Score assigned to the rule.
                 */
                score?: number;
                /**
                 * Rule priority (lower = higher priority).
                 */
                priority?: number;
                /**
                 * Trigger condition and effect for the rule.
                 */
                trigger?: {
                    /**
                     * Condition that triggers the rule.
                     */
                    condition?: {
                        /**
                         * Type of condition, which can be `0` (bypass), `1` (deny) or `2` (sequential workflow). Type `2` defines that the rule condition is set by an expression (see field `expression`).
                         */
                        conditionType?: 0 | 1 | 2;
                        /**
                         * Human-readable description of the condition.
                         */
                        description?: string;
                        /**
                         * Expression used to evaluate the condition.
                         */
                        expression?: string;
                    };
                    /**
                     * Effect applied when the condition is met.
                     */
                    effect?: {
                        /**
                         * Description of the effect.
                         */
                        description?: string;
                        /**
                         * Type of effect: `0` (approve), `1` (deny), or `2` (pending).
                         */
                        effectType?: number;
                    };
                };
                /**
                 * Timeout (in ms) for rule evaluation.
                 */
                timeout?: number;
                /**
                 * Indicates if notifications are enabled for this rule (`true`) or disabled (`false`).
                 */
                notification?: boolean;
                /**
                 * Score thresholds for decision making.
                 */
                scoreInterval?: {
                    /**
                     * Minimum score for acceptance.
                     */
                    accept?: number;
                    /**
                     * Maximum score for denial.
                     */
                    deny?: number;
                };
                /**
                 * Data related to authorization requirements.
                 */
                authorizationData?: {
                    /**
                     * If `true`, all authorizers must approve.
                     */
                    requireAllApprovals?: boolean;
                    /**
                     * List of authorizers for the rule.
                     */
                    authorizers?: Array<{
                        /**
                         * Identifier of the authorizer.
                         */
                        id?: string;
                        /**
                         * Type of authorizer (e.g., `Unit`, `user`).
                         */
                        type?: string;
                        /**
                         * Date when authorization occurred in the format `YYYY-MM-DDThh:mm:ssZ`.
                         */
                        authorizationDate?: string;
                    }>;
                };
                /**
                 * Whether the current user is authorized.
                 */
                isUserAuthorized?: boolean;
                /**
                 * Whether the current user is the next required authorizer.
                 */
                isUserNextAuthorizer?: boolean;
            }>;
            /**
             * Timestamp of when the dimension status was created in the format `YYYY-MM-DDThh:mm:ssZ`.
             */
            creationDate?: string;
            /**
             * Version of the system at creation time.
             */
            creationVersion?: string;
            /**
             * Environment in which the record was created (e.g., `stable`).
             */
            creationEnvironment?: string;
            /**
             * If `true`, all rules must be accepted for approval.
             */
            requireAllRulesAcceptance?: boolean;
        }>;
        /**
         * Version of the system at creation time.
         */
        creationVersion?: string;
        /**
         * Environment in which the approval request was created (e.g., `stable`).
         */
        creationEnvironment?: string;
        /**
         * Identifier of the user profile that created the approval request.
         */
        userProfileId?: string;
    };
};

export type PostCommercialAuthorizationsByOrderAuthIdCallbackResponse = PostCommercialAuthorizationsByOrderAuthIdCallbackResponses[keyof PostCommercialAuthorizationsByOrderAuthIdCallbackResponses];

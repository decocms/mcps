// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://api.vtex.com/{accountName}' | 'https://api.vtex.com/{account}/pricing' | 'https://api.vtex.com/{account}/pricing' | 'https://api.vtex.com/{account}/pricing' | 'https://api.vtex.com/{account}/pricing' | 'https://api.vtex.com/{account}/pricing' | 'https://api.vtex.com/{account}/pricing' | (string & {});
};

/**
 * Fixed price request body information.
 */
export type FixedPrice = {
    /**
     * Trade Policy ID.
     */
    tradePolicyId: string;
    /**
     * Trade Policy Fixed Price Value.
     */
    value: number;
    /**
     * Trade Policy List Price Value.
     */
    listPrice: number | null;
    /**
     * Trade Policy Fixed Price Minimum Item Quantity.
     */
    minQuantity: number;
    dateRange?: DateRange;
};

/**
 * Trade Policy Fixed Price Validity Period Object.
 */
export type DateRange = {
    /**
     * Indicates the date and time when the fixed price will start to be valid.
     */
    from: string;
    /**
     * Indicates the date and time from which the fixed price will no longer be valid.
     */
    to: string;
};

/**
 * Price request body information.
 */
export type Getprice = {
    /**
     * SKU ID.
     */
    itemId: string;
    /**
     * Suggested retail price for the SKU.
     */
    listPrice: number;
    /**
     * SKU's cost price.
     */
    costPrice: number;
    /**
     * Desired profit margin with the SKU's sale.
     */
    markup: number;
    /**
     * SKU's reference price.
     */
    basePrice: number;
    /**
     * The fixed price is a price that overlaps all other existing price configurations of a price table.
     */
    fixedPrices: Array<FixedPrice>;
};

/**
 * Computed price request body information.
 */
export type Getcomputedprice = {
    /**
     * Trade Policy ID ou `priceTableId`.
     */
    tradePolicyId: string;
    /**
     * Trade Policy List Price, also known as "from" price.
     */
    listPrice: number;
    /**
     * Cost price.
     */
    costPrice?: number;
    /**
     * Computed Price before applying coupons, promotions and taxes. This price may change before reaching the shelf.
     */
    sellingPrice: number;
    /**
     * Date until when the computed price will be valid, due to price scheduling. If no price scheduling applies, this will be set a year from the current time.
     */
    priceValidUntil: string;
};

/**
 * Pricing configuration request body information.
 */
export type PricingConfiguration = {
    /**
     * Defines if the account has migrated to Pricing V2.
     */
    hasMigrated: boolean;
    /**
     * Pricing V2 migration status.
     */
    migrationStatus?: string;
    /**
     * Account default markup.
     */
    defaultMarkup: number;
    /**
     * Price Variation object.
     */
    priceVariation?: {
        /**
         * Upper variation limit.
         */
        upperLimit?: number | null;
        /**
         * Lower variation limit.
         */
        lowerLimit?: number | null;
    };
    /**
     * Account minimum markup.
     */
    minimumMarkups: {
        [key: string]: number;
    };
    /**
     * Trade Policy Configurations array.
     */
    tradePolicyConfigs?: Array<{
        /**
         * Trade Policy ID.
         */
        tradePolicyId?: string;
        /**
         * Trade Policy Minimum Markup.
         */
        minimumMarkup?: number;
        /**
         * Defines if the Price Rule should affect the list price too.
         */
        rulesShouldAffectListPrice?: boolean;
    }>;
    /**
     * Overrides prices from sellers.
     */
    sellersToOverride?: Array<string> | null;
    /**
     * Deprecated. Use the `priceInheritance` field instead.
     *
     * @deprecated
     */
    hasPriceInheritance?: boolean;
    /**
     * Condition of price inheritance from its parent account. This field can have three possible values: `never` if the store should never inherit prices, `nonexistent` if the store should only inherit prices in case of nonexistent prices for a given product, or `always` if the store should always inherit prices, regardless of its own prices.
     */
    priceInheritance?: string;
    /**
     * Defines if optional base price is allowed.
     */
    hasOptionalBasePrice?: boolean;
    /**
     * Defines if access to the Pricing APIs is blocked for external requests.
     */
    blockAccount?: boolean;
    /**
     * Array with all blocked routes.
     */
    blockedRoutes?: Array<string> | null;
    /**
     * The strategy used to get prices when there is more than one option. Possible values: `first`, `highest`, `lowest`. Default: `first`.
     */
    priceTableSelectionStrategy?: string;
    /**
     * Price Table Limit.
     */
    priceTableLimit?: number | null;
};

/**
 * Type of the content being sent.
 */
export type ContentType = string;

/**
 * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
 */
export type Accept = string;

export type DeletePriceData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * SKU ID.
         */
        itemId: number;
    };
    query?: never;
    url: '/pricing/prices/{itemId}';
};

export type DeletePriceResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetPriceData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * SKU ID.
         */
        itemId: number;
    };
    query?: never;
    url: '/pricing/prices/{itemId}';
};

export type GetPriceResponses = {
    /**
     * OK
     */
    200: Getprice;
};

export type GetPriceResponse = GetPriceResponses[keyof GetPriceResponses];

export type CreateUpdatePriceOrFixedPriceData = {
    body?: {
        /**
         * The profit percentage that is to be obtained from the sale of that SKU. If you decide to fill the `markup` item, you must also fill the `costPrice`. The `basePrice` will be automatically generated based on both values.
         */
        markup?: number;
        /**
         * SKU's suggested selling price.
         */
        listPrice?: number;
        /**
         * SKU selling base price. If you decide to fill only the `basePrice` item, the `markup` and `costPrice` will be automatically generated to adapt to the number inserted in `basePrice`.
         */
        basePrice?: number;
        /**
         * SKU selling cost price. If you decide to fill the `costPrice` item, you must also fill the `markup` and `basePrice` will be automatically generated based on both values.
         */
        costPrice?: number;
        /**
         * Information  about the SKU's fixed prices.
         */
        fixedPrices?: Array<{
            /**
             * The name or ID of the trade policy, or the name of the price table where the fixed price will be configured.
             */
            tradePolicyId: string;
            /**
             * Fixed price value.
             */
            value: number;
            /**
             * SKU List Fixed Price.
             */
            listPrice?: number;
            /**
             * Minimum quantity of the SKU for the fixed price to be applied.
             */
            minQuantity: number;
            /**
             * Period of time when the fixed price will be applied to the SKU.
             */
            dateRange?: {
                /**
                 * Start date of the price. This date follows the [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format, which includes the time zone. Ensure that `to` is after than `from`, identical values may cause an error.
                 */
                from: string;
                /**
                 * End date of the price. This date follows the [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format, which includes the time zone. Ensure that `to` is after than `from`, identical values may cause an error.
                 */
                to: string;
            };
        }>;
    };
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * SKU unique identifier number.
         */
        itemId: number;
    };
    query?: never;
    url: '/pricing/prices/{itemId}';
};

export type CreateUpdatePriceOrFixedPriceResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetFixedPricesData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * SKU ID.
         */
        itemId: number;
    };
    query?: never;
    url: '/pricing/prices/{itemId}/fixed';
};

export type GetFixedPricesResponses = {
    /**
     * OK
     */
    200: Array<FixedPrice>;
};

export type GetFixedPricesResponse = GetFixedPricesResponses[keyof GetFixedPricesResponses];

export type CreateUpdatePriceOrFixedPriceNoRemoveData = {
    /**
     * Information about the SKU's fixed prices.
     */
    body?: Array<{
        /**
         * The name or ID of the trade policy, or the price table name, where the fixed price will be configured.
         */
        tradePolicyId: string;
        /**
         * Selling price of the SKU for this fixed price entry.
         */
        value: number;
        /**
         * Original or reference price of the SKU for this fixed price.
         */
        listPrice?: number;
        /**
         * Minimum quantity required for the fixed price to apply.
         */
        minQuantity: number;
        /**
         * Period of time when the fixed price will be applied to the SKU. If not provided, the price is not restricted by a date range.
         */
        dateRange?: {
            /**
             * Start date of the price. This date follows the [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format, which includes the time zone.
             */
            from: string;
            /**
             * End date of the price. This date follows the [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format, which includes the time zone.
             */
            to: string;
        };
    }>;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * SKU unique identifier number.
         */
        itemId: number;
    };
    query?: never;
    url: '/pricing/prices/{itemId}/fixed';
};

export type CreateUpdatePriceOrFixedPriceNoRemoveResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type DeletefixedpricesonapricetableortradepolicyData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * SKU ID.
         */
        itemId: number;
        /**
         * Price Table or Trade Policy Name.
         */
        priceTableId: string;
    };
    query?: never;
    url: '/pricing/prices/{itemId}/fixed/{priceTableId}';
};

export type DeletefixedpricesonapricetableortradepolicyResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetFixedPricesonapricetableData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * SKU ID.
         */
        itemId: number;
        /**
         * Price Table Name
         */
        priceTableId: string;
    };
    query?: never;
    url: '/pricing/prices/{itemId}/fixed/{priceTableId}';
};

export type GetFixedPricesonapricetableResponses = {
    /**
     * OK
     */
    200: Array<FixedPrice>;
};

export type GetFixedPricesonapricetableResponse = GetFixedPricesonapricetableResponses[keyof GetFixedPricesonapricetableResponses];

export type CreateorupdatefixedpricesonpricetableortradepolicyData = {
    body?: Array<{
        /**
         * Fixed price value.
         */
        value: number;
        /**
         * SKU List Fixed Price.
         */
        listPrice?: number;
        /**
         * The minimum SKU quantity for the fixed price to be applied.
         */
        minQuantity: number;
        /**
         * Period of time when the fixed price will be applied to the SKU.
         */
        dateRange?: {
            /**
             * Start date of the price. This date follows the [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format, which includes the time zone.
             */
            from: string;
            /**
             * End date of the price. This date follows the [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format, which includes the time zone.
             */
            to: string;
        };
    }>;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * SKU ID.
         */
        itemId: number;
        /**
         * SKU **price table** name or **trade policy** ID.
         */
        priceTableId: string;
    };
    query?: never;
    url: '/pricing/prices/{itemId}/fixed/{priceTableId}';
};

export type CreateorupdatefixedpricesonpricetableortradepolicyResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetComputedPricebypricetableData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * SKU ID.
         */
        itemId: number;
        /**
         * SKU Price Table Name.
         */
        priceTableId: string;
    };
    query: {
        /**
         * Category ID.
         */
        categoryIds: number;
        /**
         * Brand ID.
         */
        brandId: number;
        /**
         * SKU quantity.
         */
        quantity: number;
    };
    url: '/pricing/prices/{itemId}/computed/{priceTableId}';
};

export type GetComputedPricebypricetableResponses = {
    /**
     * OK
     */
    200: Getcomputedprice;
};

export type GetComputedPricebypricetableResponse = GetComputedPricebypricetableResponses[keyof GetComputedPricebypricetableResponses];

export type GetPricingConfigData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path?: never;
    query?: never;
    url: '/pricing/config';
};

export type GetPricingConfigResponses = {
    /**
     * OK
     */
    200: PricingConfiguration;
};

export type GetPricingConfigResponse = GetPricingConfigResponses[keyof GetPricingConfigResponses];

export type GetPricingv2StatusData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path?: never;
    query?: never;
    url: '/pricing/migration';
};

export type GetPricingv2StatusResponses = {
    /**
     * OK
     */
    200: {
        /**
         * Defines if the account is active.
         */
        isActive?: boolean;
        /**
         * Defines if the account has migrated to Pricing V2.
         */
        hasMigrated?: boolean;
    };
};

export type GetPricingv2StatusResponse = GetPricingv2StatusResponses[keyof GetPricingv2StatusResponses];

export type GetrulesforapricetableData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Price Table Name.
         */
        priceTableId: string;
    };
    query?: never;
    url: '/pricing/pipeline/catalog/{priceTableId}';
};

export type GetrulesforapricetableErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Too many requests
     */
    429: unknown;
};

export type GetrulesforapricetableResponses = {
    /**
     * OK
     */
    200: {
        /**
         * Trade Policy ID (Price Table ID).
         */
        tradePolicyId?: string;
        /**
         * Array of rules for the price table.
         */
        rules?: Array<{
            /**
             * Rule ID.
             */
            id?: number;
            /**
             * Rule Context is a group of filters to be checked at an item level when applying the rule. If all those filters check out, the rule will be applied for that item, unless there is a fixed price for that item.
             */
            context?: {
                /**
                 * Categories that an item should have to be eligible for the rule. Format: key: `categoryId`, value: `categoryName`.
                 */
                categories?: {
                    [key: string]: string;
                };
                /**
                 * Brands that an item should have to be eligible for the rule. Format: key: `brandId`, value: `brandName`.
                 */
                brands?: {
                    [key: string]: string;
                };
                /**
                 * Stock statuses.
                 */
                stockStatuses?: {
                    [key: string]: unknown;
                } | null;
                /**
                 * Internal Categories.
                 */
                internalCategories?: {
                    [key: string]: unknown;
                } | null;
                /**
                 * For an item to be eligible to the rule, it's markup should be in this Markup Range.
                 */
                markupRange?: {
                    /**
                     * Item markup should be greater than or equal to this value.
                     */
                    from?: number;
                    /**
                     * Item markup should be less than or equal to this value.
                     */
                    to?: number;
                } | null;
                /**
                 * The rule will be active during this time range.
                 */
                dateRange?: {
                    /**
                     * Date when rule will be activated. Date format: `RFC3339`.
                     */
                    from?: string;
                    /**
                     * Date when the rule will be deactivated. Date format: `RFC3339`.
                     */
                    to?: string;
                } | null;
            };
        }>;
        /**
         * Percentual modifier.
         */
        percentualModifier?: number;
    };
};

export type GetrulesforapricetableResponse = GetrulesforapricetableResponses[keyof GetrulesforapricetableResponses];

export type PutPricingPipelineCatalogByPriceTableIdData = {
    body?: {
        /**
         * Array of rules for the price table.
         */
        rules: Array<{
            /**
             * Rule ID.
             */
            id: number;
            /**
             * Rule Context is a group of filters to be checked at an item level when applying the rule. If all those filters check out, the rule will be applied for that item, unless there is a fixed price for that item.
             */
            context: {
                /**
                 * Categories that an item should have to be eligible for the rule. Format: key: `categoryId`, value: `categoryName`.
                 */
                categories: {
                    [key: string]: string;
                };
                /**
                 * Brands that an item should have to be eligible for the rule. Format: key: `brandId`, value: `brandName`.
                 */
                brands: {
                    [key: string]: string;
                };
                /**
                 * Stock statuses.
                 */
                stockStatuses?: {
                    [key: string]: unknown;
                } | null;
                /**
                 * Internal Categories.
                 */
                internalCategories?: {
                    [key: string]: unknown;
                } | null;
                /**
                 * For an item to be eligible to the rule, it's markup should be in this Markup Range.
                 */
                markupRange: {
                    /**
                     * Item markup should be greater than or equal to this value.
                     */
                    from: number;
                    /**
                     * Item markup should be less than or equal to this value.
                     */
                    to: number;
                } | null;
                /**
                 * The rule will be active during this time range.
                 */
                dateRange: {
                    /**
                     * Date when rule will be activated. Date format: `RFC3339`.
                     */
                    from: string;
                    /**
                     * Date when the rule will be deactivated. Date format: `RFC3339`.
                     */
                    to: string;
                };
            };
            /**
             * Percentual modifier.
             */
            percentualModifier: number;
        }>;
    };
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Price Table Name.
         */
        priceTableId: string;
    };
    query?: never;
    url: '/pricing/pipeline/catalog/{priceTableId}';
};

export type PutPricingPipelineCatalogByPriceTableIdResponses = {
    /**
     * Created
     */
    201: unknown;
};

export type PutPricingTablesByPriceTableIdData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Price Table Name.
         */
        priceTableId: string;
    };
    query?: never;
    url: '/pricing/tables/{priceTableId}';
};

export type PutPricingTablesByPriceTableIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetallpricetablesandrulesData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path?: never;
    query?: never;
    url: '/pricing/pipeline/catalog';
};

export type GetallpricetablesandrulesResponses = {
    /**
     * OK
     */
    200: Array<{
        /**
         * Trade Policy ID (Price Table ID).
         */
        tradePolicyId?: string;
        /**
         * Array of rules for the price table.
         */
        rules?: Array<{
            /**
             * Rule ID.
             */
            id?: number;
            /**
             * Rule Context is a group of filters to be checked at an item level when applying the rule. If all those filters check out, the rule will be applied for that item, unless there is a fixed price for that item.
             */
            context?: {
                /**
                 * Categories that an item should have to be eligible for the rule. Format: key: `categoryId`, value: `categoryName`.
                 */
                categories?: {
                    [key: string]: string;
                };
                /**
                 * Brands that an item should have to be eligible for the rule. Format: key: `brandId`, value: `brandName`.
                 */
                brands?: {
                    [key: string]: string;
                };
                /**
                 * Stock statuses.
                 */
                stockStatuses?: {
                    [key: string]: unknown;
                } | null;
                /**
                 * Internal Categories.
                 */
                internalCategories?: {
                    [key: string]: unknown;
                } | null;
                /**
                 * For an item to be eligible to the rule, it's markup should be in this Markup Range.
                 */
                markupRange?: {
                    /**
                     * Item markup should be greater than or equal to this value.
                     */
                    from?: number;
                    /**
                     * Item markup should be less than or equal to this value.
                     */
                    to?: number;
                } | null;
                /**
                 * The rule will be active during this time range.
                 */
                dateRange?: {
                    /**
                     * Date when rule will be activated. Date format: `RFC3339`.
                     */
                    from?: string;
                    /**
                     * Date when the rule will be deactivated. Date format: `RFC3339`.
                     */
                    to?: string;
                } | null;
            };
        }>;
        /**
         * Percentual modifier.
         */
        percentualModifier?: number;
    }>;
};

export type GetallpricetablesandrulesResponse = GetallpricetablesandrulesResponses[keyof GetallpricetablesandrulesResponses];

export type ListpricetablesData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path?: never;
    query?: never;
    url: '/pricing/tables';
};

export type ListpricetablesResponses = {
    /**
     * Array of price tables.
     */
    200: Array<string>;
};

export type ListpricetablesResponse = ListpricetablesResponses[keyof ListpricetablesResponses];

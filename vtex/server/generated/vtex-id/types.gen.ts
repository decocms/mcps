// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com' | 'https://{storeDomain}' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{accountName}.{environment}.com.br' | 'https://{storeDomain}' | 'https://{accountName}.{environment}.com' | 'https://{storeDomain}' | 'https://{accountName}.{environment}.com' | 'https://{storeDomain}' | 'https://{accountName}.{environment}.com' | 'https://{storeDomain}' | 'https://{accountName}.{environment}.com' | (string & {});
};

/**
 * Credentials object, composed of API key and application token.
 */
export type Credentials = {
    /**
     * API key.
     */
    appkey: string;
    /**
     * Application token corresponding to the API key sent with it.
     */
    apptoken: string;
};

/**
 * Validate session response object.
 */
export type ValidateSessionResponse = {
    /**
     * Authentication status of the user, which can be:
     *
     * * `Success`: when authentication is completed successfully.
     * * `InvalidEmail`: When the email informed is not valid.
     * * `InvalidToken`: When the token is malformed, expired, or has an invalid signature.
     * * `WrongCredentials`: When the informed credentials are not valid.
     */
    authStatus?: 'Success' | 'InvalidEmail' | 'InvalidToken' | 'WrongCredentials';
    /**
     * Indicates whether multi-factor authentication is required.
     */
    promptMFA?: boolean;
    /**
     * Last authentication attempt available.
     */
    lastAttemptAvailable?: number | null;
    /**
     * Client token.
     */
    clientToken?: string | null;
    /**
     * Authentication cookie.
     */
    authCookie?: {
        /**
         * Name of the cookie.
         */
        Name?: string;
        /**
         * Value of the cookie.
         */
        Value?: string;
    } | null;
    /**
     * Cookie specific to account authentication.
     */
    accountAuthCookie?: {
        /**
         * Name of the cookie.
         */
        Name?: string;
        /**
         * Value of the cookie.
         */
        Value?: string;
    } | null;
    /**
     * Time in seconds until authentication expires.
     */
    expiresIn?: number;
    /**
     * Unique identifier for the authenticated user.
     */
    userId?: string | null;
    /**
     * User's phone number associated with the account.
     */
    phoneNumber?: string | null;
    /**
     * Authentication scope granted.
     */
    scope?: string | null;
};

/**
 * Type of the content being sent.
 */
export type ContentType = string;

/**
 * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
 */
export type Accept = string;

/**
 * Name of your VTEX account.
 */
export type An = string;

/**
 * Name of your VTEX account.
 */
export type AccountName = string;

/**
 * Environment to be used in the request.
 */
export type Environment = string;

/**
 * API Key name.
 */
export type ApiKey = string;

export type PostApiAuthenticatorStorefrontUsersData = {
    body?: {
        /**
         * Unique login key (username) for the user. Case-insensitive string (3-70 characters, accepts special characters and whitespace) used for login.
         */
        identifier: string;
        /**
         * Type of identifier. Only `username` is supported.
         */
        identifierType: 'username';
    };
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path?: never;
    query?: {
        /**
         * Defines whether the storefront user should recover their password via an external service (`true`) or define a new password on first login (`false`, default).
         */
        isLegacyPassword?: boolean;
    };
    url: '/api/authenticator/storefront/users';
};

export type PostApiAuthenticatorStorefrontUsersErrors = {
    /**
     * Bad Request - Invalid request or identifier type.
     */
    400: {
        error?: string;
    };
    /**
     * Unauthorized - Invalid access token.
     */
    401: unknown;
    /**
     * Forbidden - Insufficient permissions.
     */
    403: unknown;
    /**
     * Conflict - User already exists.
     */
    409: {
        /**
         * Error message.
         */
        error?: string;
    };
};

export type PostApiAuthenticatorStorefrontUsersError = PostApiAuthenticatorStorefrontUsersErrors[keyof PostApiAuthenticatorStorefrontUsersErrors];

export type PostApiAuthenticatorStorefrontUsersResponses = {
    /**
     * User created successfully.
     */
    201: {
        /**
         * Unique user identifier (GUID).
         */
        userId?: string;
    };
};

export type PostApiAuthenticatorStorefrontUsersResponse = PostApiAuthenticatorStorefrontUsersResponses[keyof PostApiAuthenticatorStorefrontUsersResponses];

export type GetApiVtexidPvtUserInfoData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path?: never;
    query: {
        /**
         * URL-encoded storefront user identifier (username or email).
         */
        user: string;
    };
    url: '/api/vtexid/pvt/user/info';
};

export type GetApiVtexidPvtUserInfoErrors = {
    /**
     * Unauthorized - Not authenticated.
     */
    401: unknown;
};

export type GetApiVtexidPvtUserInfoResponses = {
    /**
     * Storefront user information.
     */
    200: {
        /**
         * Storefront user unique identifier.
         */
        userId?: string;
        /**
         * Storefront user email.
         */
        user?: string;
        /**
         * Storefront user full name.
         */
        name?: string;
        /**
         * VTEX account ID.
         */
        accountId?: string;
        /**
         * VTEX VTEX account name.
         */
        accountName?: string;
    };
};

export type GetApiVtexidPvtUserInfoResponse = GetApiVtexidPvtUserInfoResponses[keyof GetApiVtexidPvtUserInfoResponses];

export type PostApiVtexidApptokenLoginData = {
    body?: Credentials;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path?: never;
    query?: {
        /**
         * Name of your VTEX account.
         */
        an?: string;
    };
    url: '/api/vtexid/apptoken/login';
};

export type PostApiVtexidApptokenLoginResponses = {
    /**
     * OK
     */
    200: {
        /**
         * Authentication status.
         */
        authStatus?: string;
        /**
         * Authentication token.
         */
        token?: string;
        /**
         * Token expiration Unix timestamp in seconds.
         */
        expires?: number;
    };
};

export type PostApiVtexidApptokenLoginResponse = PostApiVtexidApptokenLoginResponses[keyof PostApiVtexidApptokenLoginResponses];

export type PostApiVtexidAudienceWebstoreProviderOauthExchangeData = {
    body?: {
        /**
         * Name of the [OAuth provider](https://developers.vtex.com/docs/guides/login-integration-guide-webstore-oauth2) set up in your Admin panel.
         */
        providerId: string;
        /**
         * Access token obtained from your frontend via OAuth integration corresponding with the indicated `providerId`.
         */
        accessToken: string;
        /**
         * Duration of the token that will be returned, in minutes. The maximum value is `120`. The default is `60` when the duration isn't defined.
         */
        duration?: number;
    };
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Name of your VTEX account.
         */
        accountName: string;
        /**
         * Environment to be used in the request.
         */
        environment: string;
    };
    query?: never;
    url: '/api/vtexid/audience/webstore/provider/oauth/exchange';
};

export type PostApiVtexidAudienceWebstoreProviderOauthExchangeResponses = {
    /**
     * 200 - OK
     */
    200: {
        /**
         * Authentication token. Use this token to authenticate your requests to VTEX APIs.
         */
        authToken?: string;
    };
};

export type PostApiVtexidAudienceWebstoreProviderOauthExchangeResponse = PostApiVtexidAudienceWebstoreProviderOauthExchangeResponses[keyof PostApiVtexidAudienceWebstoreProviderOauthExchangeResponses];

export type PostApiVtexidCredentialValidateData = {
    /**
     * Request body object.
     */
    body?: {
        /**
         * Value of the `VtexIdclientAutCookie`, [user token](https://developers.vtex.com/docs/guides/api-authentication-using-user-tokens), valid for 24 hours.
         */
        token: string;
    };
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Environment to be used in the request.
         */
        environment: string;
    };
    query?: {
        /**
         * Name of your VTEX account.
         */
        an?: string;
    };
    url: '/api/vtexid/credential/validate';
};

export type PostApiVtexidCredentialValidateErrors = {
    /**
     * Response body object.
     */
    401: {
        /**
         * Authentication status.
         */
        authStatus?: string;
    };
};

export type PostApiVtexidCredentialValidateError = PostApiVtexidCredentialValidateErrors[keyof PostApiVtexidCredentialValidateErrors];

export type PostApiVtexidCredentialValidateResponses = {
    /**
     * OK
     */
    200: {
        /**
         * Authentication status.
         */
        authStatus?: string;
        /**
         * Unique identifier of the user within VTEX services.
         */
        id?: string;
        /**
         * User email.
         */
        user?: string;
        /**
         * VTEX account name.
         */
        account?: string;
        /**
         * Type of user.
         */
        audience?: string;
        /**
         * Type of token.
         */
        tokenType?: string;
    };
};

export type PostApiVtexidCredentialValidateResponse = PostApiVtexidCredentialValidateResponses[keyof PostApiVtexidCredentialValidateResponses];

export type PostApiVtexidPubProvidersSetupPasswordWebstorePasswordData = {
    body?: {
        /**
         * Defines if password access is active (`true`) or not (`false`).
         */
        isActive?: boolean;
        /**
         * Defines if passwords can be repeated (`true`) or not (`false`).
         */
        allowRepeated?: boolean;
    };
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Name of your VTEX account.
         */
        accountName: string;
    };
    query?: never;
    url: '/api/vtexid/pub/providers/setup/password/webstore/password';
};

export type PostApiVtexidPubProvidersSetupPasswordWebstorePasswordResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PostApiVtexidPasswordExpireData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path: {
        /**
         * Name of your VTEX account.
         */
        accountName: string;
        /**
         * Environment to be used in the request.
         */
        environment: string;
    };
    query: {
        /**
         * User email.
         */
        email: string;
    };
    url: '/api/vtexid/password/expire';
};

export type PostApiVtexidPasswordExpireResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PatchApiVtexidApikeyByApiKeyApitokenRenewData = {
    body?: never;
    path: {
        /**
         * API Key name.
         */
        apiKey: string;
    };
    query?: never;
    url: '/api/vtexid/apikey/{apiKey}/apitoken/renew';
};

export type PatchApiVtexidApikeyByApiKeyApitokenRenewErrors = {
    /**
     * Invalid API key or API key not owned by tenant
     */
    400: unknown;
    /**
     * Conflict - Already has a renewed token pending
     */
    409: unknown;
    /**
     * Unknown server error
     */
    500: unknown;
};

export type PatchApiVtexidApikeyByApiKeyApitokenRenewResponses = {
    /**
     * OK
     */
    200: {
        /**
         * Unique identifier of the API token.
         */
        id?: string;
        /**
         * Name assigned to the API key.
         */
        keyName?: string;
        /**
         * ISO 8601 timestamp indicating when the current token was created.
         */
        creationDateToken?: string;
        /**
         * ISO 8601 timestamp indicating when the new token was generated.
         */
        creationDateNewToken?: string;
        /**
         * Number of days the token remains valid before expiration.
         */
        expirationPeriod?: number;
        /**
         * New API token value.
         */
        newToken?: string;
    };
};

export type PatchApiVtexidApikeyByApiKeyApitokenRenewResponse = PatchApiVtexidApikeyByApiKeyApitokenRenewResponses[keyof PatchApiVtexidApikeyByApiKeyApitokenRenewResponses];

export type PatchApiVtexidApikeyByApiKeyApitokenFinishRenewalData = {
    body?: never;
    path: {
        /**
         * API Key name.
         */
        apiKey: string;
    };
    query?: never;
    url: '/api/vtexid/apikey/{apiKey}/apitoken/finish-renewal';
};

export type PatchApiVtexidApikeyByApiKeyApitokenFinishRenewalErrors = {
    /**
     * Invalid API key or API key not owned by tenant
     */
    400: unknown;
    /**
     * No renewed API token was found
     */
    404: unknown;
    /**
     * Unknown server error
     */
    500: unknown;
};

export type PatchApiVtexidApikeyByApiKeyApitokenFinishRenewalResponses = {
    /**
     * OK
     */
    200: {
        /**
         * Unique identifier of the API token.
         */
        id?: string;
        /**
         * ISO 8601 timestamp indicating when the current token was created.
         */
        creationDateToken?: string;
        /**
         * Creation date of the new token. Always `null` after the token creation process is completed.
         */
        creationDateNewToken?: string | null;
    };
};

export type PatchApiVtexidApikeyByApiKeyApitokenFinishRenewalResponse = PatchApiVtexidApikeyByApiKeyApitokenFinishRenewalResponses[keyof PatchApiVtexidApikeyByApiKeyApitokenFinishRenewalResponses];

export type GetApiVtexidPvtUserIdData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path?: never;
    query: {
        /**
         * URI-encoded user email.
         */
        usuario: string;
    };
    url: '/api/vtexid/pvt/user/id';
};

export type GetApiVtexidPvtUserIdErrors = {
    /**
     * Unauthorized. Invalid or missing VtexIdclientAutCookie.
     */
    401: unknown;
};

export type GetApiVtexidPvtUserIdResponses = {
    /**
     * User ID.
     */
    200: string | null;
};

export type GetApiVtexidPvtUserIdResponse = GetApiVtexidPvtUserIdResponses[keyof GetApiVtexidPvtUserIdResponses];

export type GetApiVtexidPubAuthenticationStartData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path?: never;
    query: {
        /**
         * Account name.
         */
        scope: string;
        /**
         * Optional device fingerprint for enhanced security. Generated client-side using JavaScript libraries that collect anonymized device and browser parameters to create a unique identifier. When submitted in this request, it must later be provided when making a request to [refresh token](https://developers.vtex.com/docs/api-reference/vtex-id-api#post-/api/vtexid/refreshtoken/webstore).
         */
        fingerprint?: string;
    };
    url: '/api/vtexid/pub/authentication/start';
};

export type GetApiVtexidPubAuthenticationStartResponses = {
    /**
     * OK
     */
    200: {
        /**
         * Authentication token provided to the user, valid for 24 hours.
         */
        authenticationToken?: string;
        /**
         * List of available OAuth providers.
         */
        oauthProviders?: Array<{
            /**
             * Name of the OAuth provider.
             */
            providerName?: string;
            /**
             * Class name associated with the provider.
             */
            className?: string;
            /**
             * Additional context expected by the provider.
             */
            expectedContext?: Array<string>;
        }>;
        /**
         * Indicates whether classic authentication is enabled (`true`) or not (`false`).
         */
        showClassicAuthentication?: boolean;
        /**
         * Indicates whether access key authentication is enabled (`true`) or not (`false`).
         */
        showAccessKeyAuthentication?: boolean;
        /**
         * Indicates whether passkey authentication is enabled (`true`) or not (`false`).
         */
        showPasskeyAuthentication?: boolean;
        /**
         * Authentication cookie if available.
         */
        authCookie?: string | null;
        /**
         * Indicates whether the user is authenticated.
         */
        isAuthenticated?: boolean;
        /**
         * Currently selected authentication provider, if any.
         */
        selectedProvider?: string | null;
        /**
         * List of available SAML providers.
         */
        samlProviders?: Array<string>;
    };
};

export type GetApiVtexidPubAuthenticationStartResponse = GetApiVtexidPubAuthenticationStartResponses[keyof GetApiVtexidPubAuthenticationStartResponses];

export type PostApiVtexidPubAuthenticationAccesskeySendData = {
    body?: never;
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path?: never;
    query: {
        /**
         * User email.
         */
        email: string;
    };
    url: '/api/vtexid/pub/authentication/accesskey/send';
};

export type PostApiVtexidPubAuthenticationAccesskeySendErrors = {
    /**
     * Bad request
     */
    400: {
        /**
         * Error message, which can be `InvalidEmail` (when the email informed is not valid) or `InvalidToken` (when the token is malformed, expired, or has an invalid signature).
         */
        authStatus?: string;
    };
};

export type PostApiVtexidPubAuthenticationAccesskeySendError = PostApiVtexidPubAuthenticationAccesskeySendErrors[keyof PostApiVtexidPubAuthenticationAccesskeySendErrors];

export type PostApiVtexidPubAuthenticationAccesskeySendResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PostApiVtexidPubAuthenticationAccesskeyValidateData = {
    body?: {
        /**
         * Access key sent to the user through the [Send access key](https://developers.vtex.com/docs/api-reference/vtex-id-api#post-/api/vtexid/pub/authentication/accesskey/send) endpoint.
         */
        accessKey?: string;
        /**
         * User email.
         */
        login?: string;
    };
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
    };
    path?: never;
    query?: never;
    url: '/api/vtexid/pub/authentication/accesskey/validate';
};

export type PostApiVtexidPubAuthenticationAccesskeyValidateErrors = {
    /**
     * Bad request
     */
    400: ValidateSessionResponse;
};

export type PostApiVtexidPubAuthenticationAccesskeyValidateError = PostApiVtexidPubAuthenticationAccesskeyValidateErrors[keyof PostApiVtexidPubAuthenticationAccesskeyValidateErrors];

export type PostApiVtexidPubAuthenticationAccesskeyValidateResponses = {
    /**
     * OK
     */
    200: ValidateSessionResponse;
};

export type PostApiVtexidPubAuthenticationAccesskeyValidateResponse = PostApiVtexidPubAuthenticationAccesskeyValidateResponses[keyof PostApiVtexidPubAuthenticationAccesskeyValidateResponses];

export type PostApiVtexidRefreshtokenWebstoreData = {
    body?: {
        /**
         * Optional device fingerprint for enhanced security. Generated client-side using JavaScript libraries that collect anonymized device and browser parameters to create a unique identifier. Must remain consistent with the fingerprint provided during [initial authentication](https://developers.vtex.com/docs/api-reference/vtex-id-api#get-/api/vtexid/pub/authentication/start), if previously submitted.
         */
        fingerprint?: string | null;
    };
    headers: {
        /**
         * Type of the content being sent.
         */
        'Content-Type': string;
        /**
         * HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand.
         */
        Accept: string;
        /**
         * Host address.
         */
        Host: string;
    };
    path?: never;
    query?: never;
    url: '/api/vtexid/refreshtoken/webstore';
};

export type PostApiVtexidRefreshtokenWebstoreResponses = {
    /**
     * Refresh token response object.
     */
    200: {
        /**
         * Status of the operation. Possible values:
         * - `Success`: Token refresh was successful.
         * - `InvalidSession`: The session is invalid or expired.
         * - `InvalidToken`: The token is invalid.
         * - `InvalidEmail`: The email associated with the token is invalid.
         * - `InvalidScope`: The scope is invalid.
         */
        status?: 'Success' | 'InvalidSession' | 'InvalidToken' | 'InvalidEmail' | 'InvalidScope';
        /**
         * Unique identifier assigned to the authenticated user.
         */
        userId?: string;
        /**
         * The timestamp indicating when the session should be refreshed, in ISO 8601 format (`YYYY-MM-DDTHH:mm:ssÂ±HH:MM`).
         */
        refreshAfter?: string;
    };
};

export type PostApiVtexidRefreshtokenWebstoreResponse = PostApiVtexidRefreshtokenWebstoreResponses[keyof PostApiVtexidRefreshtokenWebstoreResponses];

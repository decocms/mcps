// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod';

/**
 * Type of the content being sent.
 */
export const zContentType = z.string().register(z.globalRegistry, {
    description: 'Type of the content being sent.'
});

/**
 * HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.
 */
export const zAccept = z.string().register(z.globalRegistry, {
    description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
});

export const zPostProductBulkProductsData = z.object({
    body: z.optional(z.array(z.object({
        product_sku: z.string().register(z.globalRegistry, {
            description: 'Product ID to be inserted/updated.'
        }),
        parent_sku: z.optional(z.string().register(z.globalRegistry, {
            description: 'SKU of the parent product.'
        })),
        name: z.string().register(z.globalRegistry, {
            description: 'Product name.'
        }),
        url: z.string().register(z.globalRegistry, {
            description: 'URL of the product page.'
        }),
        image_url: z.optional(z.string().register(z.globalRegistry, {
            description: 'URL of the main product image.'
        })),
        categories: z.array(z.string().register(z.globalRegistry, {
            description: 'Product category.'
        })).register(z.globalRegistry, {
            description: 'List of product categories.'
        }),
        brand: z.optional(z.string().register(z.globalRegistry, {
            description: 'Product brand.'
        })),
        gtins: z.optional(z.array(z.string().register(z.globalRegistry, {
            description: 'Product GTIN.'
        })).register(z.globalRegistry, {
            description: 'Barcode. For Newtail Network, sending the GTIN is mandatory.'
        })),
        metadata: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
            description: 'Additional product information.'
        })),
        tags: z.optional(z.array(z.string().max(64).register(z.globalRegistry, {
            description: 'Product tag.'
        })).max(10).register(z.globalRegistry, {
            description: 'List of product tags to be used later during ad queries (`POST` [Get ads](https://developers.vtex.com/docs/api-reference/vtex-ads-api#post-/v1/rma/-publisher_id-)) to better contextualize the search. Maximum of 10 tags per SKU, maximum of 64 characters per tag. Only works for Product campaigns.'
        })),
        sellers: z.optional(z.array(z.string().max(64).register(z.globalRegistry, {
            description: 'Seller name.'
        })).register(z.globalRegistry, {
            description: 'List of sellers who sell that product. Maximum of 64 characters per seller.'
        }))
    }).register(z.globalRegistry, {
        description: 'Product object.'
    })).max(500)),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zPostProductBulkInventoriesData = z.object({
    body: z.optional(z.array(z.object({
        product_sku: z.string().register(z.globalRegistry, {
            description: 'Product ID to be inserted/updated.'
        }),
        store_id: z.optional(z.string().register(z.globalRegistry, {
            description: 'Store identifier. If store_id is not sent, it will be interpreted that this inventory information will be used for all stores.'
        })),
        price: z.number().register(z.globalRegistry, {
            description: 'Product price.'
        }),
        promotional_price: z.number().register(z.globalRegistry, {
            description: 'Promotional price of the product. Use 0 to remove the promotional price.'
        }),
        is_available: z.boolean().register(z.globalRegistry, {
            description: 'Indicates if the product is available for sale.'
        })
    }).register(z.globalRegistry, {
        description: 'Inventory object.'
    })).max(500).register(z.globalRegistry, {
        description: 'List of inventory objects.'
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zPostV1BeaconImpressionByAdIdData = z.object({
    body: z.optional(z.object({
        user_id: z.optional(z.string().register(z.globalRegistry, {
            description: 'Unique identifier for the user within your platform. It must remain consistent across all user touchpoints and sales channels.'
        })),
        session_id: z.string().register(z.globalRegistry, {
            description: 'The user\'s session identifier. It has a limited lifespan and helps determine when a user transitions from anonymous to identified state.'
        })
    })),
    path: z.object({
        ad_id: z.string().register(z.globalRegistry, {
            description: 'Unique identifier of the ad.'
        })
    }),
    query: z.optional(z.object({
        pos: z.optional(z.string().register(z.globalRegistry, {
            description: 'Position of the ad.'
        }))
    })),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zPostV1BeaconClickByAdIdData = z.object({
    body: z.optional(z.object({
        user_id: z.optional(z.string().register(z.globalRegistry, {
            description: 'Unique identifier for the user within your platform. It must remain consistent across all user touchpoints and sales channels.'
        })),
        session_id: z.string().register(z.globalRegistry, {
            description: 'The user\'s session identifier. It has a limited lifespan and helps determine when a user transitions from anonymous to identified state.'
        })
    })),
    path: z.object({
        ad_id: z.string().register(z.globalRegistry, {
            description: 'Unique identifier of the ad.'
        })
    }),
    query: z.optional(z.object({
        pos: z.optional(z.string().register(z.globalRegistry, {
            description: 'Position of the ad.'
        }))
    })),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zPostV1BeaconViewByAdIdData = z.object({
    body: z.optional(z.object({
        user_id: z.optional(z.string().register(z.globalRegistry, {
            description: 'Unique identifier for the user within your platform. It must remain consistent across all user touchpoints and sales channels.'
        })),
        session_id: z.string().register(z.globalRegistry, {
            description: 'The user\'s session identifier. It has a limited lifespan and helps determine when a user transitions from anonymous to identified state.'
        })
    })),
    path: z.object({
        ad_id: z.string().register(z.globalRegistry, {
            description: 'Unique identifier of the ad.'
        })
    }),
    query: z.optional(z.object({
        pos: z.optional(z.string().register(z.globalRegistry, {
            description: 'Position of the ad.'
        }))
    })),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zPostV1BeaconConversionData = z.object({
    body: z.optional(z.object({
        channel: z.optional(z.string().register(z.globalRegistry, {
            description: 'Identifies the conversion channel.'
        })),
        publisher_id: z.string().register(z.globalRegistry, {
            description: 'Publisher identification.'
        }),
        user_id: z.string().register(z.globalRegistry, {
            description: 'User identification.'
        }),
        session_id: z.string().register(z.globalRegistry, {
            description: 'Identification of the session in which the purchase was made, to help attribute the sale to ads.'
        }),
        order_id: z.string().register(z.globalRegistry, {
            description: 'Order identification.'
        }),
        email_hashed: z.string().register(z.globalRegistry, {
            description: 'Hashed user email identification.'
        }),
        items: z.array(z.object({
            sku: z.string().register(z.globalRegistry, {
                description: 'Product SKU identification.'
            }),
            quantity: z.number().register(z.globalRegistry, {
                description: 'Quantity of product purchased.'
            }),
            price: z.number().register(z.globalRegistry, {
                description: 'Product \'from\' price. Not multiplied by quantity.'
            }),
            promotional_price: z.number().register(z.globalRegistry, {
                description: 'Product \'for\' price (discounted price). Not multiplied by quantity.'
            }),
            seller_id: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            product_id: z.optional(z.string().register(z.globalRegistry, {
                description: 'Unique product identification that includes the SKU.'
            }))
        }).register(z.globalRegistry, {
            description: 'Order item information'
        })).register(z.globalRegistry, {
            description: 'List of items purchased in the order.'
        }),
        created_at: z.string().register(z.globalRegistry, {
            description: 'Order creation date in ISO 8601 format (UTC - no timezone).'
        }),
        is_company: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates if the sale was made to an individual or a company.'
        })).default(false),
        gender: z.optional(z.nullable(z.enum([
            'F',
            'M',
            'O'
        ])).register(z.globalRegistry, {
            description: 'Indicates customer\'s gender. F: female, M: male, O: other.'
        })),
        uf: z.optional(z.string().register(z.globalRegistry, {
            description: 'Indicates the state where the order was made.'
        })),
        city: z.optional(z.string().register(z.globalRegistry, {
            description: 'Indicates the name of the city where the customer bought.'
        })),
        phone_hashed: z.optional(z.string().register(z.globalRegistry, {
            description: 'Hashed user phone number identification.'
        })),
        social_id_hashed: z.optional(z.string().register(z.globalRegistry, {
            description: 'Hashed user identification document, such as social ID, CPF, or CNPJ.'
        })),
        first_name_hashed: z.optional(z.string().register(z.globalRegistry, {
            description: 'Hashed user first name identification.'
        })),
        last_name_hashed: z.optional(z.string().register(z.globalRegistry, {
            description: 'Hashed user last name identification.'
        }))
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        })
    })
});

export const zPostV1RmaByPublisherIdData = z.object({
    body: z.optional(z.object({
        session_id: z.string().register(z.globalRegistry, {
            description: 'Persistent visitor identifier (at least 14 days). Must contain only alphanumeric characters.'
        }),
        user_id: z.optional(z.string().register(z.globalRegistry, {
            description: 'Unique identifier for the user. Must contain only alphanumeric characters.'
        })),
        store_id: z.optional(z.string().register(z.globalRegistry, {
            description: 'Filters ads based on the store\'s inventory. If not provided, ads with any available inventory will be returned.'
        })),
        context: z.enum([
            'home',
            'category',
            'search',
            'product_page',
            'brand_page',
            'digital_signage'
        ]).register(z.globalRegistry, {
            description: 'Context where the ad will be displayed.'
        }),
        term: z.optional(z.string().register(z.globalRegistry, {
            description: 'Search terms used for product searches. Required only in search context.'
        })),
        category_name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Name of the category used for targeting. Always provide the full breadcrumb path of the current category. Required only in category context.'
        })),
        product_sku: z.optional(z.string().register(z.globalRegistry, {
            description: 'SKU ID used for targeting. Required only in product context.'
        })),
        brand_name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Name of the brand to filter products by. Required only in brand context.'
        })),
        placements: z.record(z.string(), z.object({
            quantity: z.int().register(z.globalRegistry, {
                description: 'Number of ads to be returned.'
            }),
            size: z.optional(z.string().register(z.globalRegistry, {
                description: 'Expected ad size. Important when a region has a predefined size and requires a media asset fitting that size. For images: `desktop` or `mobile`. For videos: `1080p`, `720p`, `480p`, `360p`, or `320p`. Required only when types include `banner` or `sponsored_brand`.'
            })),
            types: z.array(z.enum([
                'product',
                'banner',
                'sponsored_brand',
                'digital_signage'
            ]).register(z.globalRegistry, {
                description: 'Ad type.'
            })).register(z.globalRegistry, {
                description: 'Types of ads that can be returned in this request.'
            }),
            asset_types: z.optional(z.array(z.enum(['image', 'video']).register(z.globalRegistry, {
                description: 'Media type.'
            })).register(z.globalRegistry, {
                description: 'Accepted media types. Only valid for banner and sponsored_brand types.'
            })),
            allow_sku_duplications: z.optional(z.boolean().register(z.globalRegistry, {
                description: 'Allows the same SKU ads to appear multiple times in the same placement. Default=false.'
            }))
        }).register(z.globalRegistry, {
            description: 'Placement configuration.'
        })).register(z.globalRegistry, {
            description: 'Placements are used to query multiple ads for different site regions with their own configurations.'
        }),
        product_attributes: z.optional(z.object({
            category_name: z.optional(z.string().register(z.globalRegistry, {
                description: 'Product category.'
            })),
            brand_name: z.optional(z.string().register(z.globalRegistry, {
                description: 'Product brand.'
            }))
        }).register(z.globalRegistry, {
            description: 'Additional product information. Used when catalog data is incomplete and these details need to be sent during ad queries.'
        })),
        channel: z.enum([
            'site',
            'msite',
            'app'
        ]).register(z.globalRegistry, {
            description: 'Indicates the device type accessing the ad.'
        }),
        device_id: z.optional(z.string().register(z.globalRegistry, {
            description: 'Unique device ID (screen, totem). Required only in digital_signage context.'
        })),
        store_name: z.optional(z.string().register(z.globalRegistry, {
            description: 'Name of the store where the device is located. Required only in digital_signage context.'
        })),
        brand: z.optional(z.string().register(z.globalRegistry, {
            description: 'Publisher\'s site name. Required when the publisher has multiple sites.'
        })),
        userAgent: z.optional(z.string().register(z.globalRegistry, {
            description: 'Client environment identification (body field, not the HTTP User-Agent header). Provides meta-information about the client environment accessing the ad.'
        })),
        tags: z.optional(z.array(z.string().max(64).register(z.globalRegistry, {
            description: 'Tag name.'
        })).max(10).register(z.globalRegistry, {
            description: 'Tags to contextualize searches (primarily for search context). Filters ads that contain at least one of the requested tags. Max 10 per SKU, 64 chars per tag. Only works with product campaigns.'
        })),
        skus: z.optional(z.array(z.string().register(z.globalRegistry, {
            description: 'Product SKU.'
        })).register(z.globalRegistry, {
            description: 'SKU filter for querying sponsored products. Note: Only sponsored product campaigns respect this filter.'
        })),
        dedup_campaign_ads: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Specifies whether results should be deduplicated by campaign, so at most one ad per campaign is returned. Default=false.'
        })),
        dedup_ads: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Specifies whether results should deduplicate ads across multiple placements (use only when querying multiple placements simultaneously). Default=false.'
        })),
        segmentation: z.optional(z.array(z.object({
            key: z.enum([
                'AGE',
                'GENDER',
                'STATE',
                'CITY',
                'AUDIENCES',
                'NBO_CATEGORIES'
            ]).register(z.globalRegistry, {
                description: 'Type of segmentation.'
            }),
            values: z.array(z.string().register(z.globalRegistry, {
                description: 'Segmentation value.'
            })).min(1).register(z.globalRegistry, {
                description: 'One or more accepted values.'
            })
        }).register(z.globalRegistry, {
            description: 'Segmentation rule.'
        })).register(z.globalRegistry, {
            description: 'Allows campaign segmentation based on user information.'
        }))
    })),
    path: z.object({
        publisher_id: z.string().register(z.globalRegistry, {
            description: 'Publisher identifier provided by your account manager'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Type of the content being sent.'
        }),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.'
        })
    })
});

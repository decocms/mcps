// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod';

/**
 * Request object for configuring automatic approval settings for SKUs in an account.
 */
export const zSaveautoapproveforaccountRequest = z.object({
    Enabled: z.boolean().register(z.globalRegistry, {
        description: 'Insert `true` if you wish to activate the autoapprove rule for an entire marketplace account. Insert `false` if you wish to deactivate it. Be aware that once enabling the setting through this request, all received SKUs will be automatically approved on your store, regardless of the seller, or the Matcher Score.'
    })
}).register(z.globalRegistry, {
    description: 'Request object for configuring automatic approval settings for SKUs in an account.'
});

/**
 * Matcher rates received SKUs by comparing the data sent by sellers to existing fields in the marketplace. The calculation of these scores determines whether the product has been: `Approved` or `Denied`.
 */
export const zScore = z.object({
    Approve: z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'Insert in this field the desired minimum score to approve SKUs. If this field is set as 99, it means all approvals will be made manually.'
    }).default(80),
    Reject: z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'Insert in this field the desired maximum score to reject SKUs.'
    }).default(30)
}).register(z.globalRegistry, {
    description: 'Matcher rates received SKUs by comparing the data sent by sellers to existing fields in the marketplace. The calculation of these scores determines whether the product has been: `Approved` or `Denied`.'
});

/**
 * Represents a matcher configuration in the marketplace.
 */
export const zMatcher = z.object({
    MatcherId: z.string().register(z.globalRegistry, {
        description: 'Identifies the matching entity. It can be either VTEX\'s matcher, or an external matcher developed by partners, for example. The `matcherId`\'s value can be obtained through the [Get SKU Suggestion by ID](https://developers.vtex.com/vtex-rest-api/reference/getsuggestion) endpoint.'
    }).default('vtex-matcher'),
    'hook-base-address': z.string().register(z.globalRegistry, {
        description: 'The chosen Matcher\'s url. It is the endpoint that the Received SKUs module calls, to send new suggestions for the Matcher\'s review.'
    }),
    IsActive: z.boolean().register(z.globalRegistry, {
        description: 'Whether the matcher is active in the account (`true`), or not (`false`).'
    }),
    UpdatesNotificationEndpoint: z.union([
        z.string(),
        z.null()
    ]),
    Description: z.optional(z.union([
        z.string(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Represents a matcher configuration in the marketplace.'
});

/**
 * Request object for saving account configuration settings.
 */
export const zSaveaccountconfigRequest = z.object({
    Score: zScore,
    Matchers: z.array(zMatcher).register(z.globalRegistry, {
        description: 'Matchers for approving and rejecting SKUs received from sellers.'
    }),
    SpecificationsMapping: z.array(z.string().register(z.globalRegistry, {
        description: 'Each item in the array represents a specification that is mapped to either a product or SKU.'
    })).register(z.globalRegistry, {
        description: 'This attribute maps product and SKU specifications.'
    }),
    MatchFlux: z.string().register(z.globalRegistry, {
        description: 'This field determines the type of approval configuration applied to SKUs received  from a seller. The possible values include: \n\n- `default` where the Matcher reviews the SKU, and approves it based on its score \n\n- `manual` for manual approvals through the Received SKU UI or Match API \n\n- `autoApprove` for every SKU received from a given seller to be approved automatically, regardless of the Matcher Score.'
    }).default('autoApprove')
}).register(z.globalRegistry, {
    description: 'Request object for saving account configuration settings.'
});

/**
 * Response from Get Account's Matcher Settings endpoint with information about current matcher score setting, rules, spec mapping, and matchFlux.
 */
export const zResponseGetAccountsMatcherSettings = z.object({
    score: z.optional(z.object({
        approve: z.optional(z.int().register(z.globalRegistry, {
            description: 'Minimum approval score set by the marketplace.'
        })).default(80),
        pending: z.optional(z.int().register(z.globalRegistry, {
            description: 'Minimum value for the ad to be pending.'
        })).default(31),
        reject: z.optional(z.int().register(z.globalRegistry, {
            description: 'Bounce score set by marketplace.'
        })).default(30)
    }).register(z.globalRegistry, {
        description: '[Matcher](https://help.vtex.com/pt/tutorial/entendendo-a-pontuacao-do-vtex-matcher--tutorials_424) rates received SKUs by comparing the data sent by sellers to existing fields in the marketplace. The calculation of these scores determines whether the product has been: `Approved`, `Pending` or `Denied`.'
    })),
    matchers: z.optional(z.array(z.object({
        matcherId: z.optional(z.string().register(z.globalRegistry, {
            description: 'The Matcher Id.'
        })),
        'hook-base-address': z.optional(z.string().register(z.globalRegistry, {
            description: 'The base address of the Matcher hook.'
        })),
        isActive: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates if Matcher is active or not. `TRUE` = Matcher is active or `FALSE` = Matcher is inactive.'
        }))
    }).register(z.globalRegistry, {
        description: 'An object representing a single matcher configuration.'
    })).register(z.globalRegistry, {
        description: 'Array of objects that presents a list of matchers configured in the marketplace. If the marketplace has more than one matcher configured in the account, an array will be displayed for each matcher.\n\n By default, the VTEX Matcher is set up automatically in VTEX account.'
    })),
    rules: z.optional(z.object({
        item: z.optional(z.array(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
            description: 'A rule for items.'
        })).register(z.globalRegistry, {
            description: 'A list of rules for items.'
        })),
        product: z.optional(z.array(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
            description: 'A rule for products.'
        })).register(z.globalRegistry, {
            description: 'A list of rules for products.'
        }))
    }).register(z.globalRegistry, {
        description: 'Arrays object that contains the rules defined for product approval.'
    })),
    SpecificationsMapping: z.optional(z.array(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'A specification mapping entry.'
    })).register(z.globalRegistry, {
        description: 'List of product specifications and SKU attributes configured for mapping.'
    })),
    matchFlux: z.optional(z.string().register(z.globalRegistry, {
        description: 'This field shows what type of approval setting is being applied to SKUs received from a seller. \n\nPossible values include: \n\n-`default`: where Matcher reviews the SKU and approves it based on its score. \n\n-`manual`: for manual approvals via incoming SKU UI or mailing API. \n\n-`autoApprove`: so that every SKU received from a given seller is automatically approved, regardless of its Matcher Score.'
    }))
}).register(z.globalRegistry, {
    description: 'Response from Get Account\'s Matcher Settings endpoint with information about current matcher score setting, rules, spec mapping, and matchFlux.'
});

/**
 * Represents a request to enable or disable automatic approval for SKUs received from a specific seller account.
 */
export const zSaveautoapproveforaccountsellerRequest = z.object({
    Enabled: z.boolean().register(z.globalRegistry, {
        description: 'Insert `true` if you wish to activate the autoapprove rule for that specific seller account. Insert `false` if you wish to deactivate it. Be aware that once enabling the setting through this request, all SKUs received from this seller will be automatically approved on your store regardless of the Matcher Score.'
    }).default(true)
}).register(z.globalRegistry, {
    description: 'Represents a request to enable or disable automatic approval for SKUs received from a specific seller account.'
});

/**
 * Represents a request to update or configure the seller account settings in the system. This configuration ensures that the seller's account is properly set up for matching and approval processes.
 */
export const zPutselleraccountconfigRequest = z.object({
    sellerId: z.string().register(z.globalRegistry, {
        description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace.'
    }),
    mapping: z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ]),
    matchFlux: z.string().register(z.globalRegistry, {
        description: 'This field determines the type of approval configuration applied to SKUs received  from a seller. The possible values include: \n\n- `default` where the Matcher reviews the SKU, and approves it based on its score \n\n- `manual` for manual approvals through the Received SKU UI or Match API \n\n- `autoApprove` for every SKU received from a given seller to be approved automatically, regardless of the Matcher Score.'
    }).default('autoApprove')
}).register(z.globalRegistry, {
    description: 'Represents a request to update or configure the seller account settings in the system. This configuration ensures that the seller\'s account is properly set up for matching and approval processes.'
});

/**
 * Represents a specification detail for a SKU (Stock Keeping Unit).
 */
export const zSkuSpecification = z.object({
    fieldName: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the SKU specification field. Example: \'Color\'.'
    })),
    fieldValues: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Value of the SKU specification field.'
    })).register(z.globalRegistry, {
        description: 'Array with values of the SKU specification field.'
    }))
}).register(z.globalRegistry, {
    description: 'Represents a specification detail for a SKU (Stock Keeping Unit).'
});

/**
 * Represents a specification detail for a product. This object includes a `fieldName` which describes the type of specification (e.g., 'Fabric type') and `fieldValues` which lists the values associated with that specification (e.g., 'Cotton', 'Polyester'). This structure helps in providing detailed attributes about the product, enhancing product descriptions and searchability.
 */
export const zProductSpecification = z.object({
    fieldName: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of the product specification field.'
    })),
    fieldValues: z.optional(z.array(z.string().register(z.globalRegistry, {
        description: 'Value of the product specification field.'
    })).register(z.globalRegistry, {
        description: 'Value of the product specification field.'
    }))
}).register(z.globalRegistry, {
    description: 'Represents a specification detail for a product. This object includes a `fieldName` which describes the type of specification (e.g., \'Fabric type\') and `fieldValues` which lists the values associated with that specification (e.g., \'Cotton\', \'Polyester\'). This structure helps in providing detailed attributes about the product, enhancing product descriptions and searchability.'
});

/**
 * Represents an image associated with a product or SKU.
 */
export const zImage = z.object({
    imageName: z.string().register(z.globalRegistry, {
        description: 'Name of the SKU image.'
    }),
    imageUrl: z.string().register(z.globalRegistry, {
        description: 'URL of the SKU image. The image must be sent through `https` protocol, otherwise it will not be rendered in VTEX Admin.'
    })
}).register(z.globalRegistry, {
    description: 'Represents an image associated with a product or SKU.'
});

/**
 * Represents a request to save or update a product suggestion in the system. This object contains all necessary details about the product and SKU.
 */
export const zSaveSuggestionRequest = z.object({
    ProductName: z.string().register(z.globalRegistry, {
        description: 'Name of the suggested product. This field has a limit of 150 characters.'
    }),
    ProductId: z.string().register(z.globalRegistry, {
        description: 'Product ID in seller\'s account.'
    }),
    ProductDescription: z.string().register(z.globalRegistry, {
        description: 'Product description containing the main information about the product (not the SKU).'
    }),
    BrandName: z.string().register(z.globalRegistry, {
        description: 'Name of the brand to which this SKU belongs. It must match the brand created in the marketplace.'
    }),
    SkuName: z.string().register(z.globalRegistry, {
        description: 'Name of the suggested SKU.'
    }),
    SellerId: z.string().register(z.globalRegistry, {
        description: 'ID of the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
    }),
    Height: z.int().register(z.globalRegistry, {
        description: 'Height of the SKU.'
    }),
    Width: z.int().register(z.globalRegistry, {
        description: 'Width of the SKU.'
    }),
    Length: z.int().register(z.globalRegistry, {
        description: 'Length of the SKU.'
    }),
    Weight: z.int().register(z.globalRegistry, {
        description: 'Weight of the SKU in grams.'
    }),
    RefId: z.string().register(z.globalRegistry, {
        description: 'SKU reference code. Mandotory if the EAN is not informed.'
    }).default('REF10'),
    EAN: z.string().register(z.globalRegistry, {
        description: 'SKU reference code. Mandatory if the RefId is not informed.'
    }),
    SellerStockKeepingUnitId: z.optional(z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'ID of the SKU registered in the seller.'
    })),
    CategoryFullPath: z.string().register(z.globalRegistry, {
        description: 'Full path to the SKU\'s category. It should be written as {department}/{category}. For example: if the department is **Appliances** and the category is **Oven**, the full path should be \'Appliances/Oven\'.'
    }),
    SkuSpecifications: z.optional(z.array(zSkuSpecification).register(z.globalRegistry, {
        description: 'Array containing the names and values of the SKU specifications.'
    })),
    ProductSpecifications: z.optional(z.array(zProductSpecification).register(z.globalRegistry, {
        description: 'Array containing the names and values of the product specifications.'
    })),
    Images: z.array(zImage).register(z.globalRegistry, {
        description: 'Array containing the URLs and names the SKU images.'
    }),
    MeasurementUnit: z.optional(z.string().register(z.globalRegistry, {
        description: 'Measurement unit that should be used for this SKU. If this information doesn\'t apply, you should use the default value `un`.'
    })),
    UnitMultiplier: z.optional(z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'Unit multiplier for this SKU. If this information doesn\'t apply, you should use the default value `1`.'
    })),
    AvailableQuantity: z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'The number of items currently available for sales.'
    }),
    Pricing: z.object({
        Currency: z.optional(z.string().register(z.globalRegistry, {
            description: 'The currency code representing the currency in which the sales price is denominated. This code follows the ISO 4217 standard.'
        })),
        SalePrice: z.optional(z.int().register(z.globalRegistry, {
            description: 'The sales price of the item in the specified currency. This value represents the cost at which the item is sold and is expressed as an integer without decimal places.'
        })),
        CurrencySymbol: z.optional(z.string().register(z.globalRegistry, {
            description: 'The symbol representing the currency. This symbol is used in conjunction with the sales price to display the price in a readable format.'
        }))
    }).register(z.globalRegistry, {
        description: 'Object containing pricing details, including the currency, sales price, and currency symbol.'
    })
}).register(z.globalRegistry, {
    description: 'Represents a request to save or update a product suggestion in the system. This object contains all necessary details about the product and SKU.'
});

/**
 * Represents the product details in the catalog. The product object includes essential attributes such as the product's name, description, category, brand, and specifications. This information is used to define and manage the product within the marketplace, ensuring that it is properly categorized and described for users.
 */
export const zProduct = z.object({
    name: z.string().register(z.globalRegistry, {
        description: 'Name of the product that will be matched.'
    }),
    description: z.string().register(z.globalRegistry, {
        description: 'Product\'s description.'
    }),
    categoryId: z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'Marketplace\'s Category ID that the product belongs to, configured in the Catalog. It should be the category chosen for the received SKU to be matched with. The `categoryId` is already mapped through the [Get SKU Suggestion by ID](https://developers.vtex.com/vtex-rest-api/reference/getsuggestion). You can choose to keep the same suggested `categoryID`, or overwrite it with another value in this request. This field is nulled when the inserted value is 0.'
    }),
    brandId: z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'Marketplace\'s Brand ID that the product belongs to, configured in the Catalog. It should be the brand chosen for the received SKU to be matched with. The brandId is already mapped through the Get Suggestions API. This field is nulled when the inserted value is 0.'
    }),
    specifications: z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ])
}).register(z.globalRegistry, {
    description: 'Represents the product details in the catalog. The product object includes essential attributes such as the product\'s name, description, category, brand, and specifications. This information is used to define and manage the product within the marketplace, ensuring that it is properly categorized and described for users.'
});

/**
 * An object that represents a single SKU image with a filename as the key and the image URL as the value.
 */
export const zImages = z.object({
    'imagem1.jpg': z.optional(z.string().register(z.globalRegistry, {
        description: 'The URL of the SKU\'s image. Must be an `https` URL.'
    }))
}).register(z.globalRegistry, {
    description: 'An object that represents a single SKU image with a filename as the key and the image URL as the value.'
});

/**
 * Object representing the specifications of a product, including details related to its packaging and other relevant attributes.
 */
export const zSpecifications = z.object({
    Packaging: z.string().register(z.globalRegistry, {
        description: 'Packaging specifications. Should include package\'s weight.'
    })
}).register(z.globalRegistry, {
    description: 'Object representing the specifications of a product, including details related to its packaging and other relevant attributes.'
});

/**
 * Represents the SKU (Stock Keeping Unit) details for a product. The SKU is a unique identifier that contains specific attributes such as dimensions, weight, and other product specific information. This object is crucial for defining and managing the individual variations of a product in the catalog.
 */
export const zSku = z.object({
    name: z.string().register(z.globalRegistry, {
        description: 'The name or title of the SKU.'
    }),
    eans: z.union([
        z.array(z.string().register(z.globalRegistry, {
            description: 'A single EAN code for the SKU. This is a numeric string typically consisting of 13 digits.'
        })),
        z.null()
    ]),
    refId: z.union([
        z.string(),
        z.null()
    ]),
    height: z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'Height of the SKU.'
    }),
    width: z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'Width of the SKU.'
    }),
    length: z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'Length of the SKU.'
    }),
    weight: z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'Weight of the SKU.'
    }),
    images: zImages,
    unitMultiplier: z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
        description: 'Unit multiplier for this SKU. If this information doesn\'t apply, you should use the default value 1.'
    }).default(1),
    measurementUnit: z.union([
        z.string().default('un'),
        z.null()
    ]).default('un'),
    specifications: zSpecifications
}).register(z.globalRegistry, {
    description: 'Represents the SKU (Stock Keeping Unit) details for a product. The SKU is a unique identifier that contains specific attributes such as dimensions, weight, and other product specific information. This object is crucial for defining and managing the individual variations of a product in the catalog.'
});

/**
 * Represents a request for matching a SKU suggestion with existing products or SKUs. This object includes details such as the identifier of the matcher used, the score assigned to the suggestion, and the type of match action to be performed. The match type determines how the SKU should be handled, whether as a new product, an item match, or other specified actions.
 */
export const zMatchRequest = z.object({
    matcherId: z.string().register(z.globalRegistry, {
        description: 'Identifies the matching entity. It can be either VTEX\'s matcher, or an external matcher developed by partners, for example. The `matcherId`\'s value can be obtained through the [Get SKU Suggestion by ID](https://developers.vtex.com/vtex-rest-api/reference/getsuggestion) endpoint.'
    }).default('vtex-matcher'),
    matchType: z.string().register(z.globalRegistry, {
        description: 'Define the action you want to apply to each SKU. Values include: \n\n1. `newproduct`: match the SKU as a new product. \n\n2. `itemMatch`: associate the received SKU to an existing SKU. \n\n3. `productMatch`: associate the received SKU to an existing product. \n\n4. `deny`: deny the received SKU. \n\n5. `pending`: the received SKU requires attention. \n\n6. `incomplete`: the received SKU is lacking information to be matched. \n\n7. `insufficientScore`: the score given by the Matcher to this received SKU doesn\'t qualify it to be matched. \n\nNote that  if the autoApprove setting is enabled, the SKUs will be approved, regardless of the Score.'
    }),
    score: z.string().register(z.globalRegistry, {
        description: 'Matcher rates received SKUs by correlating the data sent by sellers, to existing fields in the marketplace. The calculation of these scores determines whether the product has been: \n\n`Approved`: score equal to or greater than 80 points. \n\n`Pending`: from 31 to 79 points.\n\n`Denied`: from 0 to 30 points. \n\nNote that  if the autoApprove setting is enabled, the SKUs will be approved, regardless of the Score.'
    }).default('80'),
    skuRef: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    productRef: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    product: z.optional(zProduct),
    sku: z.optional(zSku)
}).register(z.globalRegistry, {
    description: 'Represents a request for matching a SKU suggestion with existing products or SKUs. This object includes details such as the identifier of the matcher used, the score assigned to the suggestion, and the type of match action to be performed. The match type determines how the SKU should be handled, whether as a new product, an item match, or other specified actions.'
});

/**
 * An array containing multiple match operations, each represented as an object. This array allows for the processing of multiple SKU suggestions in a single request.
 */
export const zMatchMultiple = z.array(z.object({
    itemId: z.string().register(z.globalRegistry, {
        description: 'This field can be used to link any string that identifies that SKU. Its most common use is the seller\'s SKU ID.'
    }),
    versionId: z.string().register(z.globalRegistry, {
        description: 'Whenever an SKU Suggestion is updated or changed, a new version of the original one is created. All versions are logged, so you can search for previous our current states of SKU suggestions. This field is the `versionId` associated to the version you choose to search for. You can get this field\'s value through the [Get SKU Suggestion by ID](https://developers.vtex.com/vtex-rest-api/reference/getsuggestion). through the `latestVersionId` field.'
    }),
    matchId: z.string().register(z.globalRegistry, {
        description: 'Whenever an SKU suggestion is matched, it is associated to a unique ID. Fill in this field with the `matchId` you wish to filter by. The `matchId`\'s value can be obtained through the [Get SKU Suggestion by ID](https://developers.vtex.com/vtex-rest-api/reference/getsuggestion) endpoint.'
    }).default('vtex-matcher'),
    matcherId: z.string().register(z.globalRegistry, {
        description: 'Identifies the matching entity. It can be either VTEX\'s matcher, or an external matcher developed by partners, for example. The `matcherId`\'s value can be obtained through the [Get SKU Suggestion by ID](https://developers.vtex.com/vtex-rest-api/reference/getsuggestion) endpoint.'
    }).default('vtex-matcher'),
    categoryId: z.union([
        z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }),
        z.null()
    ]),
    brandId: z.optional(z.union([
        z.int().min(-2147483648, { error: 'Invalid value: Expected int32 to be >= -2147483648' }).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }),
        z.null()
    ])),
    skuRef: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    productRef: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    sellerId: z.string().register(z.globalRegistry, {
        description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
    })
}).register(z.globalRegistry, {
    description: 'Represents a single match operation for a SKU suggestion, including details such as item ID, version ID, match ID, category, and seller information.'
})).register(z.globalRegistry, {
    description: 'An array containing multiple match operations, each represented as an object. This array allows for the processing of multiple SKU suggestions in a single request.'
});

/**
 * An array containing the results of multiple match operations. Each object in the array represents the outcome of a single match attempt.
 */
export const zResponseMatchMultiple = z.array(z.object({
    matchId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Unique identifier for the match operation, which can be used for tracking and auditing purposes.'
    })),
    matcherId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Identifier for the matcher entity that performed the match. It can represent VTEX\'s internal matcher or an external matcher service.'
    })),
    sellerId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Unique identifier of the seller who owns the SKU being matched.'
    })),
    itemId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Unique identifier of the item (SKU) that was processed during the match operation.'
    })),
    isSuccess: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether the match operation was successful. A value of `true` means the operation succeeded, while `false` indicates a failure.'
    }))
}).register(z.globalRegistry, {
    description: 'Represents the result of a single match operation, including details such as match ID, matcher ID, seller ID, item ID, and whether the operation was successful.'
})).register(z.globalRegistry, {
    description: 'An array containing the results of multiple match operations. Each object in the array represents the outcome of a single match attempt.'
});

/**
 * Represents the approval settings configured for a specific seller within the marketplace. This object includes details about the seller, their account, and how SKUs are mapped and approved.
 */
export const zResponseGetSellersApprovalSettings = z.object({
    sellerId: z.optional(z.string().register(z.globalRegistry, {
        description: 'A string that identifies the seller in the marketplace.'
    })),
    accountId: z.optional(z.string().register(z.globalRegistry, {
        description: 'Marketplace’s account ID.'
    })),
    accountName: z.optional(z.string().register(z.globalRegistry, {
        description: 'Marketplace’s account name.'
    })),
    mapping: z.optional(z.object({
        defaultColor: z.optional(z.string().register(z.globalRegistry, {
            description: 'The field will indicate the default color predefined by the seller in cases where specific product colors are not defined. This field is neither mandatory nor default, it will depend on the architecture of the seller\'s catalog.'
        })),
        searchColor: z.optional(z.string().register(z.globalRegistry, {
            description: 'Field that provides the available colors to filter searches. This field is neither mandatory nor default, it will depend on the architecture of the seller\'s catalog.'
        })),
        color1: z.optional(z.string().register(z.globalRegistry, {
            description: '`color1` available for search filter. This field is neither mandatory nor default, it will depend on the architecture of the seller\'s catalog.'
        })),
        color2: z.optional(z.string().register(z.globalRegistry, {
            description: '`color2` available for search filter. This field is neither mandatory nor default, it will depend on the architecture of the seller\'s catalog.'
        })),
        color: z.optional(z.string().register(z.globalRegistry, {
            description: 'Indicates the predominant or main color of the product. This field is neither mandatory nor default, it will depend on the architecture of the seller\'s catalog.'
        })),
        size: z.optional(z.string().register(z.globalRegistry, {
            description: 'Indicates the size of the product. This field is neither mandatory nor default, it will depend on the architecture of the seller\'s catalog.'
        }))
    }).register(z.globalRegistry, {
        description: 'SKU mapping information and product [specifications](https://developers.vtex.com/docs/guides/catalog-overview#configuring-initial-settings-mandatory).\n\n The properties included within `mapping` can change according to the product type, the `color` specification and its variations described in this example are just one of the possibilities. The values received in this call\'s payload for those properties depend on the seller\'s catalog architecture, and are not default. \n\nSee some examples of specifications: \n\n- Voltage \n\n- Power \n\n- Size \n\n- Height \n\n- Width.'
    })).default({}),
    matchFlux: z.optional(z.string().register(z.globalRegistry, {
        description: 'This field determines the type of [approval configuration applied to SKUs received from a seller](https://developers.vtex.com/docs/api-reference/marketplace-apis-suggestions#put-/suggestions/configuration/seller/-sellerId-). \n\nThe possible values include:  \n\n-`default`, where the Matcher reviews the SKU, and approves it based on its score. \n\n-`manual`, for manual approvals through the Received SKU UI and Match API. \n\n-`autoApprove`, for every SKU received from a given seller to be approved automatically, regardless of the Matcher Score.'
    }))
}).register(z.globalRegistry, {
    description: 'Represents the approval settings configured for a specific seller within the marketplace. This object includes details about the seller, their account, and how SKUs are mapped and approved.'
});

/**
 * Response object for the Save Accounts Approval Settings endpoint.
 */
export const zResponseSaveAccountsApprovalSettings = z.object({
    Score: z.optional(z.object({
        Approve: z.optional(z.int().register(z.globalRegistry, {
            description: 'Score to approve SKUs sent by sellers.'
        })),
        Reject: z.optional(z.int().register(z.globalRegistry, {
            description: 'Score to reject SKUs sent by sellers.'
        }))
    }).register(z.globalRegistry, {
        description: '[Matcher\'s rates](https://help.vtex.com/en/tutorial/understanding-vtex-matcher-scoring) to approve or reject [received SKUs](https://help.vtex.com/en/tutorial/cataloging-received-skus--tutorials_396) sent by sellers.'
    })),
    Matchers: z.optional(z.array(z.object({
        MatcherId: z.optional(z.string().register(z.globalRegistry, {
            description: 'Identifies the matching entity. It can be either [VTEX\'s matcher](https://help.vtex.com/en/tutorial/understanding-vtex-matcher-scoring), or an external matcher.'
        })),
        'hook-base-address': z.optional(z.string().register(z.globalRegistry, {
            description: 'The given matcher\'s URL.'
        })),
        IsActive: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Whether the matcher is active in the account (`true`), or not (`false`).'
        })),
        UpdatesNotificationEndpoint: z.optional(z.string().register(z.globalRegistry, {
            description: 'The [received SKUs](https://help.vtex.com/en/tutorial/cataloging-received-skus--tutorials_396) module calls this endpoint for matcher\'s suggestions updates.'
        })),
        Description: z.optional(z.string().register(z.globalRegistry, {
            description: 'The note inserted on the request body.'
        }))
    }).register(z.globalRegistry, {
        description: 'Details of a matcher used for scoring and managing SKUs approvals and rejections.'
    })).register(z.globalRegistry, {
        description: '[Matchers](https://help.vtex.com/en/tutorial/understanding-vtex-matcher-scoring) configurations for approving and rejecting [received SKUs](https://help.vtex.com/en/tutorial/cataloging-received-skus--tutorials_396) sent by sellers.'
    })),
    Rules: z.optional(z.object({
        Item: z.optional(z.array(z.int().register(z.globalRegistry, {
            description: 'SKU ID.'
        })).register(z.globalRegistry, {
            description: 'SKUs\' ID.'
        })),
        Product: z.optional(z.array(z.string().register(z.globalRegistry, {
            description: 'Product name.'
        })).register(z.globalRegistry, {
            description: 'Product\'s name.'
        }))
    }).register(z.globalRegistry, {
        description: 'Items and products that belong to sellers.'
    })),
    SpecificationsMapping: z.optional(z.array(z.object({
        SellerId: z.optional(z.string().register(z.globalRegistry, {
            description: 'The seller ID.'
        })),
        Mapping: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
            description: 'The attributes and values mapped between the marketplace and the seller.'
        }))
    }).register(z.globalRegistry, {
        description: 'Object representing a single specification mapping between the marketplace and the seller.'
    })).register(z.globalRegistry, {
        description: 'This attribute maps product and SKU\'s specifications between the marketplace and the seller.'
    })),
    MatchFlux: z.optional(z.string().register(z.globalRegistry, {
        description: 'Type of approval configuration that apply to received SKUs sent by sellers. The possible values are: \n\n`default`: The matcher approves the SKU. \n\n`manual`: Manual SKU\'s approvals. \n\n`AutoApprove`: Automatic SKU\'s approvals.'
    }))
}).register(z.globalRegistry, {
    description: 'Response object for the Save Accounts Approval Settings endpoint.'
});

/**
 * HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand
 */
export const zAccept = z.string().register(z.globalRegistry, {
    description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
}).default('application/json');

/**
 * Describes the type of the content being sent.
 */
export const zContentType = z.string().register(z.globalRegistry, {
    description: 'Describes the type of the content being sent.'
}).default('application/json');

export const zGetautoApprovevaluefromconfigData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. All data extracted, and changes added will be posted into this account.'
        })
    }),
    query: z.object({
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace.'
        })
    }),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zSaveautoapproveforaccountData = z.object({
    body: zSaveautoapproveforaccountRequest,
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. All data extracted, and changes added will be posted into this account.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zGetaccountconfigData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. All data extracted, and changes added will be posted into this account.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zSaveaccountconfigData = z.object({
    body: zSaveaccountconfigRequest,
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. All data extracted, and changes added will be posted into this account.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zGetmatchconfigData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. All data extracted, and changes added will be posted into this account.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zGetselleraccountconfigData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. All data extracted, and changes added will be posted into this account.'
        }),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zPutselleraccountconfigData = z.object({
    body: zPutselleraccountconfigRequest,
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. All data extracted, and changes added will be posted into this account.'
        }),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zSaveautoapproveforaccountsellerData = z.object({
    body: zSaveautoapproveforaccountsellerRequest,
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account that belongs to the marketplace. All data extracted, and changes added will be posted into this account.'
        }),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zGetsuggestionsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as part of the URL'
        })
    }),
    query: z.optional(z.object({
        q: z.optional(z.string().register(z.globalRegistry, {
            description: 'This field allows you to customize your search. You can fill in this query param if you want to narrow down your search using the available filters on Received SKU modules.'
        })),
        type: z.optional(z.string().register(z.globalRegistry, {
            description: 'This field allows users to filter SKU suggestions, by searching only the new suggestions that were just sent, and suggestions that have already been sent, but were updated. Possible values for this field include `new` and `update`.'
        })),
        seller: z.optional(z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller so it can call this endpoint.'
        })),
        status: z.optional(z.string().register(z.globalRegistry, {
            description: 'Narrow down you search, filtering by status. Values allowed on this field include: `accepted`, `pending` and `denied.`'
        })),
        hasmapping: z.optional(z.string().register(z.globalRegistry, {
            description: 'This field allows you to filter SKUs that have mapping or not. Insert `true` to filter SKUs that have mapping, or `false` to retrieve SKUs that aren\'t mapped.'
        })),
        matcherid: z.optional(z.string().register(z.globalRegistry, {
            description: 'Identifies the matching entity. It can be either VTEX\'s matcher, or an external matcher developed by partners, for example. The `matcherId`\'s value can be obtained through the [Get SKU Suggestion by ID](https://developers.vtex.com/vtex-rest-api/reference/getsuggestion) endpoint.'
        })).default('vtex-matcher'),
        _from: z.optional(z.int().gte(1).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
            description: 'Define your pagination range, by adding the pagination starting value. Values should be bigger than 0, with a maximum of 50 records per page.'
        })),
        _to: z.optional(z.int().gte(1).max(2147483647, { error: 'Invalid value: Expected int32 to be <= 2147483647' }).register(z.globalRegistry, {
            description: 'Define your pagination range, by adding the pagination ending value. Values should be bigger than 0, with a maximum of 50 records per page.'
        }))
    })),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zDeleteSuggestionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as part of the URL.'
        }),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        }),
        sellerSkuId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the SKU in the marketplace. This is the ID that the marketplace will use for future references to this SKU, such as price and inventory notifications.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zGetSuggestionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as part of the URL'
        }),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        }),
        sellerSkuId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the SKU in the marketplace. This is the ID that the marketplace will use for future references to this SKU, such as price and inventory notifications.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zSaveSuggestionData = z.object({
    body: zSaveSuggestionRequest,
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account to which the seller wants to suggest a new SKU. It is used as part of the request URL.'
        }),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        }),
        sellerSkuId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the SKU in the seller. This is the ID that the marketplace will use for future references to this SKU, such as price and inventory notifications.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zGetVersionsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as part of the URL'
        }),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        }),
        sellerskuid: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the SKU in the marketplace. This is the ID that the marketplace will use for future references to this SKU, such as price and inventory notifications.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zGetSuggestionbyversionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as part of the URL'
        }),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        }),
        sellerskuid: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the SKU in the marketplace. This is the ID that the marketplace will use for future references to this SKU, such as price and inventory notifications.'
        }),
        version: z.string().register(z.globalRegistry, {
            description: 'Whenever an SKU Suggestion is updated or changed, a new version of the original one is created. All versions are logged, so you can search for previous our current states of SKU suggestions. This field is the `versionId` associated to the version you choose to search for. You can get this field\'s value through the [Get SKU Suggestion by ID](https://developers.vtex.com/vtex-rest-api/reference/getsuggestion). through the `latestVersionId` field.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zMatchData = z.object({
    body: zMatchRequest,
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as part of the URL'
        }),
        sellerId: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the seller in the marketplace. This ID must be created by the marketplace and informed to the seller before the integration is built.'
        }),
        sellerskuid: z.string().register(z.globalRegistry, {
            description: 'A string that identifies the SKU in the marketplace. This is the ID that the marketplace will use for future references to this SKU, such as price and inventory notifications.'
        }),
        version: z.string().register(z.globalRegistry, {
            description: 'Whenever an SKU Suggestion is updated or changed, a new version of the original one is created. All versions are logged, so you can search for previous our current states of SKU suggestions. This field is the versionId associated to the version you choose to search for. You can get this field\'s value through the[Get SKU Suggestion by ID](https://developers.vtex.com/vtex-rest-api/reference/getsuggestion). through the `latestVersionId` field.'
        }),
        matchid: z.string().register(z.globalRegistry, {
            description: 'Whenever an SKU suggestion is matched, it is associated to a unique ID. Fill in this field with the matchId you wish to filter by. The `matchId`\'s value can be obtained through the *[Get SKU Suggestion by ID](https://developers.vtex.com/vtex-rest-api/reference/getsuggestion) endpoint.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zMatchMultipleData = z.object({
    body: z.unknown().register(z.globalRegistry, {
        description: 'Array of objects representing multiple SKU or product match requests.'
    }),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as part of the URL'
        }),
        actionName: z.enum([
            'newproduct',
            'skuassociation',
            'productassociation',
            'deny'
        ]).register(z.globalRegistry, {
            description: 'Operation to apply to received SKUs. Possible values include: \n\n* `newproduct`: match the SKU as a new product. \n\n* `skuassociation`: associate the received SKU to an existing SKU. \n\n* `productassociation`: associate the received SKU to an existing product. \n\n* `deny`: deny the received SKU.'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

export const zPutSuggestionsConfigurationBySellerIdSpecificationsData = z.object({
    body: z.record(z.string(), z.string().register(z.globalRegistry, {
        description: 'An [attachment](https://help.vtex.com/en/tutorial/what-is-an-attachment--aGICk0RVbqKg6GYmQcWUm) is an optional, free customization of a product. It is used to add information to a SKU.'
    })).register(z.globalRegistry, {
        description: 'Key-value pairs where the key is the seller\'s specification name and the value is the equivalent specification in the marketplace.'
    }),
    path: z.object({
        accountName: z.string().register(z.globalRegistry, {
            description: 'Name of the VTEX account. Used as part of the URL'
        }),
        sellerID: z.string().register(z.globalRegistry, {
            description: 'Marketplace seller ID whose specifications will be mapped'
        })
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'Content-Type': z.string().register(z.globalRegistry, {
            description: 'Describes the type of the content being sent.'
        }).default('application/json'),
        Accept: z.string().register(z.globalRegistry, {
            description: 'HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand'
        }).default('application/json')
    })
});

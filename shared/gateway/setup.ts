#!/usr/bin/env bun
/**
 * MCP Gateway - Interactive Setup
 *
 * A fancy TUI to configure which MCPs to run through the gateway.
 * Saves configuration to .env for subsequent runs.
 */

import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { resolve, dirname } from "node:path";
import * as readline from "node:readline";

// ANSI colors and styles (green, gray, purple, golden orange)
const colors = {
  reset: "\x1b[0m",
  bold: "\x1b[1m",
  dim: "\x1b[2m",
  gray: "\x1b[90m",
  green: "\x1b[32m",
  brightGreen: "\x1b[92m",
  orange: "\x1b[38;5;214m", // Golden orange
  purple: "\x1b[38;5;141m", // Light purple
  magenta: "\x1b[35m",
  white: "\x1b[37m",
  bgGreen: "\x1b[42m",
  bgPurple: "\x1b[48;5;141m",
};

const c = colors;

interface MCPOption {
  id: string;
  name: string;
  description: string;
  port: number;
  path: string;
  requiresPath?: boolean;
  pathDescription?: string;
}

const AVAILABLE_MCPS: MCPOption[] = [
  {
    id: "local-fs",
    name: "Local FS",
    description: "Mount a local folder for file operations",
    port: 8001,
    path: "local-fs/server/http.ts",
    requiresPath: true,
    pathDescription: "Path to mount (e.g., /Users/you/my-project)",
  },
  {
    id: "blog",
    name: "Blog",
    description: "AI-powered blog writing with tone of voice guides",
    port: 8002,
    path: "blog/server/main.ts",
  },
  {
    id: "bookmarks",
    name: "Bookmarks",
    description: "Bookmark management with AI enrichment",
    port: 8003,
    path: "bookmarks/server/main.ts",
  },
  {
    id: "slides",
    name: "Slides",
    description: "Create beautiful presentations",
    port: 8004,
    path: "slides/server/main.ts",
  },
  {
    id: "brand",
    name: "Brand",
    description: "Brand asset and style management",
    port: 8005,
    path: "brand/server/main.ts",
  },
];

interface GatewayConfig {
  mcps: string[];
  localFsPath?: string;
  gatewayPort: number;
}

const CONFIG_FILE = resolve(
  import.meta.dirname || process.cwd(),
  ".gateway.env",
);

/**
 * Load existing config from .env file
 */
function loadConfig(): GatewayConfig | null {
  if (!existsSync(CONFIG_FILE)) {
    return null;
  }

  try {
    const content = readFileSync(CONFIG_FILE, "utf-8");
    const lines = content.split("\n");
    const config: GatewayConfig = {
      mcps: [],
      gatewayPort: 8000,
    };

    for (const line of lines) {
      const [key, ...valueParts] = line.split("=");
      const value = valueParts.join("=").trim();

      if (key === "MCPS") {
        config.mcps = value.split(",").filter(Boolean);
      } else if (key === "LOCAL_FS_PATH") {
        config.localFsPath = value.replace(/^["']|["']$/g, "");
      } else if (key === "GATEWAY_PORT") {
        config.gatewayPort = parseInt(value, 10) || 8000;
      }
    }

    return config.mcps.length > 0 ? config : null;
  } catch {
    return null;
  }
}

/**
 * Save config to .env file
 */
function saveConfig(config: GatewayConfig): void {
  const lines = [
    `# MCP Gateway Configuration`,
    `# Generated by: bun run gateway:setup`,
    ``,
    `MCPS=${config.mcps.join(",")}`,
    `GATEWAY_PORT=${config.gatewayPort}`,
  ];

  if (config.localFsPath) {
    lines.push(`LOCAL_FS_PATH="${config.localFsPath}"`);
  }

  writeFileSync(CONFIG_FILE, lines.join("\n") + "\n");
}

/**
 * Create readline interface
 */
function createRL(): readline.Interface {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
}

/**
 * Ask a question and return the answer
 */
function ask(rl: readline.Interface, question: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      resolve(answer.trim());
    });
  });
}

/**
 * Clear screen and show header
 */
function showHeader(): void {
  console.clear();
  console.log(`
${c.purple}${c.bold}  ╔══════════════════════════════════════════════════════════╗${c.reset}
${c.purple}${c.bold}  ║${c.reset}            ${c.brightGreen}${c.bold}MCP Gateway Setup${c.reset}                          ${c.purple}${c.bold}║${c.reset}
${c.purple}${c.bold}  ╚══════════════════════════════════════════════════════════╝${c.reset}

${c.gray}  Configure which MCPs to run through a single tunnel.${c.reset}
${c.gray}  Your selection will be saved for future runs.${c.reset}
`);
}

/**
 * Show MCP selection menu
 */
function showMCPMenu(selectedMcps: Set<string>): void {
  console.log(`  ${c.purple}${c.bold}Available MCPs:${c.reset}\n`);

  for (let i = 0; i < AVAILABLE_MCPS.length; i++) {
    const mcp = AVAILABLE_MCPS[i];
    const isSelected = selectedMcps.has(mcp.id);
    const checkbox = isSelected
      ? `${c.brightGreen}[✓]${c.reset}`
      : `${c.gray}[ ]${c.reset}`;
    const num = `${c.orange}${i + 1}${c.reset}`;
    const name = isSelected
      ? `${c.brightGreen}${c.bold}${mcp.name}${c.reset}`
      : `${c.white}${mcp.name}${c.reset}`;

    console.log(`  ${checkbox} ${num}. ${name}`);
    console.log(`      ${c.gray}${mcp.description}${c.reset}`);
    console.log();
  }
}

/**
 * Interactive MCP selection
 */
async function selectMCPs(
  rl: readline.Interface,
  existingConfig: GatewayConfig | null,
): Promise<Set<string>> {
  const selectedMcps = new Set<string>(existingConfig?.mcps || []);

  while (true) {
    showHeader();
    showMCPMenu(selectedMcps);

    console.log(`  ${c.gray}Commands:${c.reset}`);
    console.log(
      `    ${c.orange}1-${AVAILABLE_MCPS.length}${c.reset}  ${c.gray}Toggle MCP${c.reset}`,
    );
    console.log(`    ${c.orange}a${c.reset}    ${c.gray}Select all${c.reset}`);
    console.log(`    ${c.orange}n${c.reset}    ${c.gray}Select none${c.reset}`);
    console.log(`    ${c.orange}↵${c.reset}    ${c.gray}Continue${c.reset}\n`);

    const input = await ask(rl, `  ${c.purple}›${c.reset} `);

    if (input === "") {
      if (selectedMcps.size === 0) {
        console.log(`\n${c.orange}Please select at least one MCP.${c.reset}`);
        await ask(rl, `${c.gray}Press Enter to continue...${c.reset}`);
        continue;
      }
      break;
    }

    if (input.toLowerCase() === "a") {
      for (const mcp of AVAILABLE_MCPS) {
        selectedMcps.add(mcp.id);
      }
      continue;
    }

    if (input.toLowerCase() === "n") {
      selectedMcps.clear();
      continue;
    }

    const num = parseInt(input, 10);
    if (num >= 1 && num <= AVAILABLE_MCPS.length) {
      const mcp = AVAILABLE_MCPS[num - 1];
      if (selectedMcps.has(mcp.id)) {
        selectedMcps.delete(mcp.id);
      } else {
        selectedMcps.add(mcp.id);
      }
    }
  }

  return selectedMcps;
}

/**
 * Ask for local-fs path if needed
 */
async function getLocalFsPath(
  rl: readline.Interface,
  existingPath?: string,
): Promise<string> {
  showHeader();

  console.log(`  ${c.purple}${c.bold}Local FS Configuration${c.reset}\n`);
  console.log(
    `  ${c.gray}The Local FS MCP needs a folder path to mount.${c.reset}`,
  );
  console.log(
    `  ${c.gray}This is the root folder agents can access.${c.reset}\n`,
  );

  if (existingPath) {
    console.log(
      `  ${c.gray}Current path: ${c.white}${existingPath}${c.reset}\n`,
    );
  }

  while (true) {
    const defaultHint = existingPath
      ? ` ${c.gray}(${existingPath})${c.reset}`
      : "";
    const path = await ask(
      rl,
      `  ${c.purple}Enter folder path${defaultHint}: ${c.reset}`,
    );

    const finalPath = path || existingPath;

    if (!finalPath) {
      console.log(`\n  ${c.orange}Path is required.${c.reset}`);
      continue;
    }

    if (!existsSync(finalPath)) {
      console.log(`\n  ${c.orange}Path does not exist: ${finalPath}${c.reset}`);
      const retry = await ask(rl, `  ${c.gray}Try again? (Y/n): ${c.reset}`);
      if (retry.toLowerCase() === "n") {
        process.exit(1);
      }
      continue;
    }

    return finalPath;
  }
}

/**
 * Show final configuration
 */
function showFinalConfig(config: GatewayConfig): void {
  showHeader();

  console.log(`  ${c.brightGreen}${c.bold}✓ Configuration Saved${c.reset}\n`);
  console.log(`  ${c.gray}File: ${CONFIG_FILE}${c.reset}\n`);

  console.log(`  ${c.purple}${c.bold}Selected MCPs:${c.reset}`);
  for (const mcpId of config.mcps) {
    const mcp = AVAILABLE_MCPS.find((m) => m.id === mcpId);
    if (mcp) {
      console.log(
        `    ${c.brightGreen}✓${c.reset} ${mcp.name} ${c.gray}(port ${mcp.port})${c.reset}`,
      );
    }
  }

  if (config.localFsPath) {
    console.log(`\n  ${c.purple}${c.bold}Local FS Path:${c.reset}`);
    console.log(`    ${c.white}${config.localFsPath}${c.reset}`);
  }

  console.log(
    `\n  ${c.purple}${c.bold}Gateway Port:${c.reset} ${c.white}${config.gatewayPort}${c.reset}`,
  );

  console.log(`\n  ${c.gray}${"─".repeat(50)}${c.reset}`);
  console.log(`\n  ${c.bold}To start the gateway:${c.reset}`);
  console.log(`    ${c.orange}bun run gateway${c.reset}\n`);
}

/**
 * Main setup flow (exported for use from server.ts)
 */
export async function runSetup(): Promise<GatewayConfig | null> {
  const rl = createRL();
  const existingConfig = loadConfig();

  try {
    // Select MCPs
    const selectedMcps = await selectMCPs(rl, existingConfig);

    // Get local-fs path if selected
    let localFsPath: string | undefined;
    if (selectedMcps.has("local-fs")) {
      localFsPath = await getLocalFsPath(rl, existingConfig?.localFsPath);
    }

    // Build config
    const config: GatewayConfig = {
      mcps: Array.from(selectedMcps),
      localFsPath,
      gatewayPort: existingConfig?.gatewayPort || 8000,
    };

    // Save config
    saveConfig(config);

    // Show final config
    showFinalConfig(config);

    return config;
  } finally {
    rl.close();
  }
}

// Only run main if this is the entry point
const isMainModule =
  import.meta.url === `file://${process.argv[1]}` ||
  process.argv[1]?.endsWith("setup.ts");

if (isMainModule) {
  runSetup().catch((error) => {
    console.error("Setup failed:", error);
    process.exit(1);
  });
}

export { loadConfig, AVAILABLE_MCPS, type GatewayConfig, CONFIG_FILE };

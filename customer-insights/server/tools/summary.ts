/**
 * Tool: CUSTOMER_SUMMARY_GET (customer_summary_get)
 *
 * Returns a pre-computed executive summary snapshot for a customer.
 * If a snapshot exists (generated by customer_summary_generate), returns it
 * instantly. If no snapshot exists, falls back to generating one on the fly.
 *
 * For best performance, use customer_summary_generate first to pre-compute
 * the snapshot, then use this tool for fast retrieval.
 *
 * Also exports all shared analysis functions used by summary-generate.ts.
 */

import { createPrivateTool } from "@decocms/runtime/tools";
import { z } from "zod";
import type { Env } from "../main.ts";
import { query, getSnapshot, saveSnapshot } from "../db.ts";
import { resolveCustomer, type CustomerRow } from "./customer-resolver.ts";
import { sanitize, sanitizeRows } from "./sanitize.ts";
import { clean, daysBetween } from "./utils.ts";

export { clean };

type CustomerContact = CustomerRow;

export type EmailHistoryData = {
  customer: CustomerContact | null;
  total_messages: number;
  messages: Array<Record<string, unknown>>;
  _meta: Record<string, unknown>;
};

export type BillingOverview = {
  total_invoices: number;
  by_status: Record<string, number>;
};

export type SummaryFilters = {
  customer_id?: string;
  customer_name?: string;
  resolved_customer_id: number;
  resolved_customer_name: string;
  match_type: "id" | "exact" | "partial";
  billing_status?: "paid" | "pending" | "overdue" | "open";
  include_email_history: boolean;
  email_max_results: number;
};

export async function getBillingData(customerId: number, status?: string) {
  const where = [`id = ${customerId}`];
  if (status?.trim()) {
    const escaped = status.replace(/'/g, "''");
    where.push(`LOWER(status) = LOWER('${escaped}')`);
  }

  const rows = await query(
    `SELECT due_date, amount, status, reference_month, paid_date
     FROM v_billing
     WHERE ${where.join(" AND ")}
     ORDER BY due_date DESC`,
  );
  return sanitizeRows(rows as Record<string, unknown>[]);
}

export async function getUsageData(customerId: number) {
  const id = customerId;

  const [summary] = await query(
    `SELECT
      COALESCE(SUM(pageviews), 0) AS total_pageviews,
      COALESCE(SUM(requests), 0) AS total_requests,
      COALESCE(SUM(bandwidth), 0) AS total_bandwidth,
      COUNT(*) AS total_months
    FROM v_billing
    WHERE id = ${id}`,
  );

  const [trend] = await query(
    `WITH ranked AS (
      SELECT *, ROW_NUMBER() OVER (ORDER BY reference_month DESC) AS rn
      FROM v_billing
      WHERE id = ${id}
    )
    SELECT
      COALESCE(ROUND(AVG(CASE WHEN rn <= 3 THEN pageviews END)), 0) AS avg_recent_3m,
      COALESCE(ROUND(AVG(CASE WHEN rn > 3 AND rn <= 6 THEN pageviews END)), 0) AS avg_previous_3m,
      COALESCE(ROUND(AVG(CASE WHEN rn <= 3 THEN requests END)), 0) AS avg_requests_recent_3m,
      COALESCE(ROUND(AVG(CASE WHEN rn > 3 AND rn <= 6 THEN requests END)), 0) AS avg_requests_previous_3m,
      COALESCE(ROUND(AVG(CASE WHEN rn <= 3 THEN bandwidth END), 2), 0) AS avg_bandwidth_recent_3m,
      COALESCE(ROUND(AVG(CASE WHEN rn > 3 AND rn <= 6 THEN bandwidth END), 2), 0) AS avg_bandwidth_previous_3m
    FROM ranked
    WHERE rn <= 6`,
  );

  return {
    summary: sanitize(summary as Record<string, unknown>),
    trend: sanitize(trend as Record<string, unknown>),
  };
}

export async function getBillingOverview(customerId: number): Promise<BillingOverview> {
  const [totals] = await query(
    `SELECT COUNT(*) AS total_invoices
     FROM v_billing
     WHERE id = ${customerId}`,
  );

  const statusRows = await query(
    `SELECT status, COUNT(*) AS total
     FROM v_billing
     WHERE id = ${customerId}
     GROUP BY status
     ORDER BY status`,
  );

  const byStatus: Record<string, number> = {};
  for (const row of sanitizeRows(statusRows as Record<string, unknown>[])) {
    const key = String(row.status ?? "unknown").toLowerCase();
    const value = Number(row.total ?? 0);
    byStatus[key] = Number.isFinite(value) ? value : 0;
  }

  const sanitizedTotals = sanitize((totals ?? {}) as Record<string, unknown>);
  const totalInvoices = Number(sanitizedTotals.total_invoices ?? 0);

  return {
    total_invoices: Number.isFinite(totalInvoices) ? totalInvoices : 0,
    by_status: byStatus,
  };
}

function getGoogleAccessToken(env: Env): string {
  const authorization = (env as any)?.MESH_REQUEST_CONTEXT?.authorization;
  if (!authorization || typeof authorization !== "string") {
    throw new Error("Not authenticated. Please login with Google first.");
  }
  return authorization.replace(/^Bearer\s+/i, "");
}

function getHeader(
  headers: Array<{ name: string; value: string }> | undefined,
  key: string,
): string | null {
  if (!headers?.length) return null;
  const header = headers.find((item) => item.name.toLowerCase() === key.toLowerCase());
  return header?.value ?? null;
}

async function listGmailMessages(
  accessToken: string,
  fromEmail: string,
  maxResults: number,
): Promise<Array<Record<string, unknown>>> {
  const listUrl = new URL("https://gmail.googleapis.com/gmail/v1/users/me/messages");
  listUrl.searchParams.set("q", `from:${fromEmail}`);
  listUrl.searchParams.set("maxResults", String(maxResults));

  const listResponse = await fetch(listUrl, {
    headers: { Authorization: `Bearer ${accessToken}` },
  });
  if (!listResponse.ok) {
    const error = await listResponse.text();
    throw new Error(`Gmail list error (${listResponse.status}): ${error}`);
  }

  const listData = (await listResponse.json()) as {
    messages?: Array<{ id: string; threadId: string }>;
  };
  const messages = listData.messages ?? [];
  if (!messages.length) return [];

  return Promise.all(
    messages.map(async (msg) => {
      const detailUrl = new URL(
        `https://gmail.googleapis.com/gmail/v1/users/me/messages/${msg.id}`,
      );
      detailUrl.searchParams.set("format", "metadata");
      detailUrl.searchParams.set("metadataHeaders", "Subject");
      detailUrl.searchParams.append("metadataHeaders", "From");
      detailUrl.searchParams.append("metadataHeaders", "To");
      detailUrl.searchParams.append("metadataHeaders", "Date");

      const detailResponse = await fetch(detailUrl, {
        headers: { Authorization: `Bearer ${accessToken}` },
      });
      if (!detailResponse.ok) {
        const error = await detailResponse.text();
        throw new Error(`Gmail message error (${detailResponse.status}): ${error}`);
      }

      const data = (await detailResponse.json()) as {
        id: string;
        threadId: string;
        snippet?: string;
        internalDate?: string;
        payload?: {
          headers?: Array<{ name: string; value: string }>;
        };
      };
      const headers = data.payload?.headers;

      let internalDateIso: string | null = null;
      if (data.internalDate) {
        const parsed = Number(data.internalDate);
        if (Number.isFinite(parsed)) {
          internalDateIso = new Date(parsed).toISOString();
        }
      }

      return {
        id: data.id,
        thread_id: data.threadId,
        subject: getHeader(headers, "Subject"),
        from: getHeader(headers, "From"),
        to: getHeader(headers, "To"),
        date: getHeader(headers, "Date"),
        snippet: data.snippet ?? "",
        internal_date: internalDateIso,
      };
    }),
  );
}

export async function getEmailHistoryData(
  env: Env,
  customer: CustomerContact,
  maxResults = 5,
  includeEmails = true,
): Promise<EmailHistoryData> {
  try {
    if (!includeEmails) {
      return {
        customer,
        total_messages: 0,
        messages: [],
        _meta: {
          enabled: false,
          reason: "Email history disabled by include_email_history=false filter.",
        },
      };
    }

    let accessToken: string;
    try {
      accessToken = getGoogleAccessToken(env);
    } catch (err) {
      return {
        customer,
        total_messages: 0,
        messages: [],
        _meta: {
          enabled: false,
          reason: (err as Error).message,
          required_scopes: ["https://www.googleapis.com/auth/gmail.readonly"],
        },
      };
    }

    try {
      const messages = await listGmailMessages(accessToken, customer.email, maxResults);
      return {
        customer,
        total_messages: messages.length,
        messages,
        _meta: {
          enabled: true,
          gmail_query: `from:${customer.email}`,
        },
      };
    } catch (err) {
      return {
        customer,
        total_messages: 0,
        messages: [],
        _meta: {
          enabled: true,
          gmail_query: `from:${customer.email}`,
          error: (err as Error).message,
        },
      };
    }
  } catch (err) {
    return {
      customer: null,
      total_messages: 0,
      messages: [],
      _meta: {
        enabled: false,
        error: (err as Error).message,
      },
    };
  }
}

export function buildContext(
  customer: CustomerContact,
  filters: SummaryFilters,
  billing: Record<string, unknown>[],
  billingOverview: BillingOverview,
  usage: { summary: Record<string, unknown>; trend: Record<string, unknown> },
  emailHistory: EmailHistoryData,
  tiering?: TieringAnalysis | null,
): string {
  const emailCustomer = emailHistory.customer
    ? `${emailHistory.customer.name} <${emailHistory.customer.email}>`
    : "n/a";

  return `
=== FILTERS APPLIED ===
${JSON.stringify(filters, null, 2)}

=== INTERPRETATION CONTEXT ===
Resolved customer: ${customer.name} <${customer.email}>
Total invoices without status filter: ${billingOverview.total_invoices}
Distribution by status (unfiltered): ${JSON.stringify(billingOverview.by_status)}
Note: when billing_status is set, the billing list below represents ONLY that status.

=== BILLING DATA ===
Total invoices: ${billing.length}
Invoices (most recent first):
${JSON.stringify(billing, null, 2)}

=== USAGE DATA (aggregated over billing history) ===
Aggregated totals: ${JSON.stringify(usage.summary)}
Traffic trend: ${JSON.stringify(usage.trend)}

=== TIERING ANALYSIS ===
${tiering ? JSON.stringify(tiering, null, 2) : "Tiering data not available"}

=== EMAIL HISTORY (GMAIL) ===
Linked contact: ${emailCustomer}
Total emails retrieved: ${emailHistory.total_messages}
Meta: ${JSON.stringify(emailHistory._meta)}
Emails (most recent returned by API):
${JSON.stringify(emailHistory.messages, null, 2)}
  `.trim();
}

const SYSTEM_PROMPT = `You are a Financial Analyst. Provide TWO things in this exact format:

ANALYSIS: [2-3 sentences analyzing billing vs usage patterns, payment behavior, and customer health]
ACTION: [1-2 sentences with specific recommended action]

Be concise, specific, and actionable.`;

function isReasoningModel(model: string): boolean {
  return /^(gpt-5|o[1-9]|o\d+-)/i.test(model);
}

async function callOpenAI(
  apiKey: string,
  model: string,
  context: string,
  maxTokens: number,
): Promise<string> {
  const body: Record<string, unknown> = {
    model,
    messages: [
      { role: "system", content: SYSTEM_PROMPT },
      {
        role: "user",
        content: `Customer data:\n\n${context}`,
      },
    ],
  };

  if (isReasoningModel(model)) {
    body.max_completion_tokens = maxTokens;
  } else {
    body.temperature = 0.2;
    body.max_tokens = maxTokens;
  }

  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`OpenAI API error (${response.status}): ${error}`);
  }

  const data = (await response.json()) as {
    choices?: Array<{
      message?: {
        content?: string;
        reasoning_content?: string;
      };
    }>;
  };
  const choice = data?.choices?.[0];
  const msg = choice?.message;

  return msg?.content || msg?.reasoning_content || "";
}

async function callGemini(
  apiKey: string,
  model: string,
  context: string,
  maxTokens: number,
): Promise<string> {
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

  const response = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      systemInstruction: { parts: [{ text: SYSTEM_PROMPT }] },
      contents: [
        {
          parts: [
            {
              text: `Customer data:\n\n${context}`,
            },
          ],
        },
      ],
      generationConfig: {
        temperature: 0.2,
        maxOutputTokens: maxTokens,
      },
    }),
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Gemini API error (${response.status}): ${error}`);
  }

  const data = (await response.json()) as {
    candidates: Array<{ content: { parts: Array<{ text: string }> } }>;
  };
  return data.candidates[0].content.parts[0].text;
}

async function callOpenAICompatible(
  provider: string,
  apiKey: string,
  model: string,
  context: string,
  maxTokens: number,
): Promise<string> {
  const config: Record<string, { url: string; headers: Record<string, string> }> = {
    anthropic: {
      url: "https://api.anthropic.com/v1/messages",
      headers: {
        "x-api-key": apiKey,
        "anthropic-version": "2023-06-01",
      },
    },
    deepseek: {
      url: "https://api.deepseek.com/v1/chat/completions",
      headers: { Authorization: `Bearer ${apiKey}` },
    },
    groq: {
      url: "https://api.groq.com/openai/v1/chat/completions",
      headers: { Authorization: `Bearer ${apiKey}` },
    },
  };

  const providerConfig = config[provider];
  if (!providerConfig) {
    throw new Error(
      `Provider "${provider}" not supported. Use: openai, gemini, anthropic, deepseek, groq.`,
    );
  }

  if (provider === "anthropic") {
    const response = await fetch(providerConfig.url, {
      method: "POST",
      headers: { "Content-Type": "application/json", ...providerConfig.headers },
      body: JSON.stringify({
        model,
        max_tokens: maxTokens,
        system: SYSTEM_PROMPT,
        messages: [
          {
            role: "user",
            content: `Customer data:\n\n${context}`,
          },
        ],
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Anthropic API error (${response.status}): ${error}`);
    }

    const data = (await response.json()) as {
      content: Array<{ text: string }>;
    };
    return data.content[0].text;
  }

  const response = await fetch(providerConfig.url, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...providerConfig.headers },
    body: JSON.stringify({
      model,
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        {
          role: "user",
          content: `Customer data:\n\n${context}`,
        },
      ],
      temperature: 0.2,
      max_tokens: maxTokens,
    }),
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`${provider} API error (${response.status}): ${error}`);
  }

  const data = (await response.json()) as {
    choices: Array<{ message: { content: string } }>;
  };
  return data.choices[0].message.content;
}

type TieringProjection = {
  tier: string;
  label: string;
  avg_cost: number;
  saving_vs_current: number;
  saving_pct: number;
};

export type TieringAnalysis = {
  current_plan: string;
  avg_current_cost: number;
  projections: TieringProjection[];
  recommendation: {
    action: "upgrade" | "keep_current";
    best_tier: string | null;
    monthly_saving: number;
    annual_saving: number;
    reasoning: string;
  };
};

export async function getTieringData(customerId: number): Promise<TieringAnalysis | null> {
  const rows = await query(
    `SELECT
       plan,
       ROUND(AVG(amount), 2) AS avg_current,
       ROUND(AVG(tier_40_cost), 2) AS avg_tier_40,
       ROUND(AVG(tier_50_cost), 2) AS avg_tier_50,
       ROUND(AVG(tier_80_cost), 2) AS avg_tier_80,
       COUNT(*) AS months
     FROM v_billing
     WHERE id = ${customerId}
       AND amount IS NOT NULL
     GROUP BY plan`,
  );

  const sanitized = sanitizeRows(rows as Record<string, unknown>[]);
  if (!sanitized.length) return null;

  const row = sanitized[0];
  const currentPlan = String(row.plan ?? "unknown");
  const avgCurrent = Number(row.avg_current ?? 0);
  const avgTier40 = Number(row.avg_tier_40 ?? 0);
  const avgTier50 = Number(row.avg_tier_50 ?? 0);
  const avgTier80 = Number(row.avg_tier_80 ?? 0);

  if (avgTier40 === 0 && avgTier50 === 0 && avgTier80 === 0) return null;

  const projections: TieringProjection[] = [];

  if (avgTier40 > 0) {
    const saving = avgCurrent - avgTier40;
    projections.push({
      tier: "tier_40",
      label: "Standard R$40/10k pageviews",
      avg_cost: avgTier40,
      saving_vs_current: Math.round(saving * 100) / 100,
      saving_pct: avgCurrent > 0 ? Math.round((saving / avgCurrent) * 10000) / 100 : 0,
    });
  }

  if (avgTier50 > 0) {
    const saving = avgCurrent - avgTier50;
    projections.push({
      tier: "tier_50",
      label: "Standard R$50/10k pageviews",
      avg_cost: avgTier50,
      saving_vs_current: Math.round(saving * 100) / 100,
      saving_pct: avgCurrent > 0 ? Math.round((saving / avgCurrent) * 10000) / 100 : 0,
    });
  }

  if (avgTier80 > 0) {
    const saving = avgCurrent - avgTier80;
    projections.push({
      tier: "tier_80",
      label: "Standard R$80/10k pageviews",
      avg_cost: avgTier80,
      saving_vs_current: Math.round(saving * 100) / 100,
      saving_pct: avgCurrent > 0 ? Math.round((saving / avgCurrent) * 10000) / 100 : 0,
    });
  }

  const cheaperTiers = projections.filter((p) => p.saving_vs_current > 0);
  cheaperTiers.sort((a, b) => b.saving_vs_current - a.saving_vs_current);

  let recommendation: TieringAnalysis["recommendation"];

  if (cheaperTiers.length > 0) {
    const best = cheaperTiers[0];
    recommendation = {
      action: "upgrade",
      best_tier: best.tier,
      monthly_saving: best.saving_vs_current,
      annual_saving: Math.round(best.saving_vs_current * 12 * 100) / 100,
      reasoning: `Migrating to ${best.label} would save R$${best.saving_vs_current.toFixed(2)}/month (${best.saving_pct.toFixed(1)}%). Annual saving: R$${(best.saving_vs_current * 12).toFixed(2)}.`,
    };
  } else {
    recommendation = {
      action: "keep_current",
      best_tier: null,
      monthly_saving: 0,
      annual_saving: 0,
      reasoning: `Current plan (${currentPlan}) is already the most cost-effective option. All tiering simulations result in equal or higher costs.`,
    };
  }

  return {
    current_plan: currentPlan,
    avg_current_cost: avgCurrent,
    projections,
    recommendation,
  };
}

export function formatTieringSection(tiering: TieringAnalysis): string {
  const lines: string[] = [];
  lines.push(`- Current plan: ${tiering.current_plan} (avg R$${tiering.avg_current_cost.toFixed(2)}/month)`);

  for (const p of tiering.projections) {
    const savingSign = p.saving_vs_current > 0 ? "saves" : "costs more";
    const savingAbs = Math.abs(p.saving_vs_current).toFixed(2);
    lines.push(`- ${p.label}: R$${p.avg_cost.toFixed(2)}/month (${savingSign} R$${savingAbs})`);
  }

  if (tiering.recommendation.action === "upgrade") {
    lines.push(`- üí° Recommendation: Upgrade to ${tiering.recommendation.best_tier} ‚Äî saves R$${tiering.recommendation.monthly_saving.toFixed(2)}/month (R$${tiering.recommendation.annual_saving.toFixed(2)}/year)`);
  } else {
    lines.push(`- ‚úÖ Current plan is optimal`);
  }

  return lines.join("\n");
}

function formatLargeNumber(value: number): string {
  if (value >= 1_000_000) {
    return `${(value / 1_000_000).toFixed(1)}M`;
  }
  if (value >= 1_000) {
    return `${(value / 1_000).toFixed(1)}K`;
  }
  return value.toFixed(0);
}

export function determineStatus(
  billing: Record<string, unknown>[],
  emailHistory: EmailHistoryData,
): { emoji: string; text: string; severity: "critical" | "warning" | "healthy" } {
  const hasOverdue = billing.some((inv) => {
    const status = String(inv.status ?? "").toLowerCase();
    return status.includes("overdue") || status.includes("pending") || status.includes("registered");
  });

  const hasCriticalComplaint = emailHistory.messages.some((msg) => {
    const subject = String(msg.subject ?? "").toLowerCase();
    const snippet = String(msg.snippet ?? "").toLowerCase();
    const text = `${subject} ${snippet}`;
    return (
      text.includes("cancelamento") ||
      text.includes("processo") ||
      text.includes("procon") ||
      text.includes("advogado") ||
      text.includes("cancellation") ||
      text.includes("legal")
    );
  });

  const hasComplaint = emailHistory.messages.some((msg) => {
    const subject = String(msg.subject ?? "").toLowerCase();
    const snippet = String(msg.snippet ?? "").toLowerCase();
    const text = `${subject} ${snippet}`;
    return (
      text.includes("problema") ||
      text.includes("erro") ||
      text.includes("falha") ||
      text.includes("reclamacao") ||
      text.includes("problem") ||
      text.includes("error") ||
      text.includes("issue") ||
      text.includes("complaint")
    );
  });

  if (hasOverdue && hasCriticalComplaint) {
    return { emoji: "üî¥", text: "Critical - Immediate action required", severity: "critical" };
  }

  if (hasOverdue || hasComplaint) {
    return { emoji: "‚ö†Ô∏è", text: "Attention needed", severity: "warning" };
  }

  return { emoji: "‚úÖ", text: "Healthy", severity: "healthy" };
}

export function formatBillingSection(billing: Record<string, unknown>[]): {
  text: string;
  metrics: {
    totalInvoices: number;
    paid: number;
    overdue: number;
    overdueAmount: number;
    avgMonthly: number;
    lastPaymentDays: number | null;
  };
} {
  const totalInvoices = billing.length;
  let paidCount = 0;
  let overdueCount = 0;
  let overdueAmount = 0;
  let totalAmount = 0;
  let lastPaidDate: Date | null = null;

  for (const inv of billing) {
    const status = String(inv.status ?? "").toLowerCase();
    const amount = Number(inv.amount ?? 0);
    const paidDate = inv.paid_date ? new Date(String(inv.paid_date)) : null;

    totalAmount += amount;

    if (status.includes("paid")) {
      paidCount++;
      if (paidDate && (!lastPaidDate || paidDate > lastPaidDate)) {
        lastPaidDate = paidDate;
      }
    }

    if (
      status.includes("overdue") ||
      status.includes("pending") ||
      status.includes("registered")
    ) {
      overdueCount++;
      overdueAmount += amount;
    }
  }

  const avgMonthly = totalInvoices > 0 ? totalAmount / totalInvoices : 0;
  const lastPaymentDays = lastPaidDate ? daysBetween(lastPaidDate, new Date()) : null;

  const lines: string[] = [];

  if (overdueCount > 0) {
    lines.push(
      `- ${totalInvoices} invoices, ${paidCount} paid, ${overdueCount} overdue ($${overdueAmount.toFixed(2)})`,
    );
  } else {
    lines.push(`- ${totalInvoices} invoices, ${paidCount} paid, 0 overdue`);
  }

  lines.push(`- Average monthly: $${avgMonthly.toFixed(2)}`);

  if (lastPaymentDays !== null) {
    lines.push(`- Last payment: ${lastPaymentDays} days ago`);
  } else {
    lines.push(`- Last payment: No payments recorded`);
  }

  return {
    text: lines.join("\n"),
    metrics: {
      totalInvoices,
      paid: paidCount,
      overdue: overdueCount,
      overdueAmount,
      avgMonthly,
      lastPaymentDays,
    },
  };
}

export function formatUsageSection(usage: {
  summary: Record<string, unknown>;
  trend: Record<string, unknown>;
}): {
  text: string;
  metrics: {
    pageviews: number;
    requests: number;
    bandwidth: number;
    pageviewsChange: number;
    requestsChange: number;
    bandwidthChange: number;
  };
} {
  const summary = usage.summary;
  const trend = usage.trend;

  const totalPageviews = Number(summary.total_pageviews ?? 0);
  const totalRequests = Number(summary.total_requests ?? 0);
  const totalBandwidth = Number(summary.total_bandwidth ?? 0);

  const avgRecent = Number(trend.avg_recent_3m ?? 0);
  const avgPrevious = Number(trend.avg_previous_3m ?? 0);

  const pageviewsChange = avgPrevious > 0 ? ((avgRecent - avgPrevious) / avgPrevious) * 100 : 0;

  const avgRecentReq = Number(trend.avg_requests_recent_3m ?? 0);
  const avgPreviousReq = Number(trend.avg_requests_previous_3m ?? 0);
  const requestsChange =
    avgPreviousReq > 0 ? ((avgRecentReq - avgPreviousReq) / avgPreviousReq) * 100 : 0;

  const avgRecentBw = Number(trend.avg_bandwidth_recent_3m ?? 0);
  const avgPreviousBw = Number(trend.avg_bandwidth_previous_3m ?? 0);
  const bandwidthChange =
    avgPreviousBw > 0 ? ((avgRecentBw - avgPreviousBw) / avgPreviousBw) * 100 : 0;

  const lines: string[] = [];

  const pvChange = pageviewsChange >= 0 ? `+${pageviewsChange.toFixed(0)}%` : `${pageviewsChange.toFixed(0)}%`;
  lines.push(`- Pageviews: ${formatLargeNumber(totalPageviews)} (${pvChange} vs previous period)`);

  const reqChange = requestsChange >= 0 ? `+${requestsChange.toFixed(0)}%` : `${requestsChange.toFixed(0)}%`;
  lines.push(`- Requests: ${formatLargeNumber(totalRequests)} (${reqChange} vs previous period)`);

  const bwChange = bandwidthChange >= 0 ? `+${bandwidthChange.toFixed(0)}%` : `${bandwidthChange.toFixed(0)}%`;
  const bwFormatted = totalBandwidth >= 1000 ? `${(totalBandwidth / 1000).toFixed(1)}TB` : `${totalBandwidth.toFixed(0)}GB`;
  lines.push(`- Bandwidth: ${bwFormatted} (${bwChange} vs previous period)`);

  return {
    text: lines.join("\n"),
    metrics: {
      pageviews: totalPageviews,
      requests: totalRequests,
      bandwidth: totalBandwidth,
      pageviewsChange,
      requestsChange,
      bandwidthChange,
    },
  };
}

export function generateProgrammaticAnalysis(
  billingMetrics: ReturnType<typeof formatBillingSection>["metrics"],
  usageMetrics: ReturnType<typeof formatUsageSection>["metrics"],
  emailHistory: EmailHistoryData,
  tiering?: TieringAnalysis | null,
): string {
  const insights: string[] = [];

  if (usageMetrics.pageviewsChange > 15 && billingMetrics.overdue > 0) {
    insights.push(
      `Usage increased ${usageMetrics.pageviewsChange.toFixed(0)}% but customer has overdue invoices.`,
    );
    insights.push("Customer may be experiencing cash flow issues despite growth.");
  } else if (usageMetrics.pageviewsChange > 20) {
    insights.push(
      `Strong usage growth of ${usageMetrics.pageviewsChange.toFixed(0)}% indicates healthy engagement.`,
    );
  } else if (usageMetrics.pageviewsChange < -15) {
    insights.push(
      `Usage declined ${Math.abs(usageMetrics.pageviewsChange).toFixed(0)}%, possible churn risk.`,
    );
  }

  if (billingMetrics.overdue > 0 && billingMetrics.lastPaymentDays && billingMetrics.lastPaymentDays > 45) {
    insights.push(
      `Last payment was ${billingMetrics.lastPaymentDays} days ago and has ${billingMetrics.overdue} overdue invoice(s) - payment behavior degrading.`,
    );
  } else if (billingMetrics.lastPaymentDays && billingMetrics.lastPaymentDays > 60 && billingMetrics.overdue === 0) {
    insights.push(
      `No new invoices in ${billingMetrics.lastPaymentDays} days - customer may be inactive or on hold.`,
    );
  }

  if (tiering?.recommendation.action === "upgrade") {
    insights.push(
      `Tiering analysis: customer can save R$${tiering.recommendation.monthly_saving.toFixed(2)}/month (R$${tiering.recommendation.annual_saving.toFixed(2)}/year) by switching to ${tiering.recommendation.best_tier}.`,
    );
  }

  if (emailHistory.total_messages > 0) {
    insights.push(
      `Customer has sent ${emailHistory.total_messages} recent emails - active communication.`,
    );
  }

  if (insights.length === 0) {
    insights.push("Customer metrics are within normal ranges.");
  }

  return insights.join(" ");
}

export function generateProgrammaticAction(
  status: ReturnType<typeof determineStatus>,
  billingMetrics: ReturnType<typeof formatBillingSection>["metrics"],
  usageMetrics: ReturnType<typeof formatUsageSection>["metrics"],
): string {
  if (status.severity === "critical") {
    return "URGENT: Immediate CSM outreach required. Escalate to management if legal threat detected.";
  }

  if (status.severity === "warning") {
    if (billingMetrics.overdue > 0) {
      return `Contact customer about ${billingMetrics.overdue} overdue invoice(s) totaling $${billingMetrics.overdueAmount.toFixed(2)}. Offer payment plan if needed.`;
    }
    return "Review customer communication and address concerns proactively.";
  }

  if (usageMetrics.pageviewsChange > 30) {
    return "Customer is growing rapidly. Consider upsell conversation or proactive capacity planning.";
  }

  return "Continue monitoring. No immediate action required.";
}

export async function enrichWithLLM(
  llmConfig: any,
  baseAnalysis: string,
  baseAction: string,
  llmContext: string,
): Promise<{ analysis: string; action: string; error?: string }> {
  const provider = llmConfig.provider ?? "openai";
  const model = llmConfig.model ?? "gpt-4o-mini";
  const maxTokens = llmConfig.max_tokens ?? 800;

  try {
    let response: string;

    if (provider === "gemini") {
      response = await callGemini(llmConfig.api_key, model, llmContext, maxTokens);
    } else if (provider === "anthropic" || provider === "deepseek" || provider === "groq") {
      response = await callOpenAICompatible(
        provider,
        llmConfig.api_key,
        model,
        llmContext,
        maxTokens,
      );
    } else {
      response = await callOpenAI(llmConfig.api_key, model, llmContext, maxTokens);
    }

    const analysisMatch = response.match(/ANALYSIS:\s*(.+?)(?=ACTION:|$)/s);
    const actionMatch = response.match(/ACTION:\s*(.+)$/s);

    if (analysisMatch && actionMatch) {
      return {
        analysis: analysisMatch[1].trim(),
        action: actionMatch[1].trim(),
      };
    }

    return { analysis: baseAnalysis, action: baseAction, error: "Failed to parse LLM response" };
  } catch (err) {
    return { analysis: baseAnalysis, action: baseAction, error: (err as Error).message };
  }
}

export function buildFormattedSummary(
  customer: CustomerRow,
  status: ReturnType<typeof determineStatus>,
  billingSection: string,
  usageSection: string,
  analysis: string,
  recommendedAction: string,
  tieringSection?: string,
): string {
  let text = `Customer: ${customer.name} (customer_${customer.id})
Status: ${status.emoji} ${status.text}

Billing:
${billingSection}

Usage (aggregated over billing history):
${usageSection}`;

  if (tieringSection) {
    text += `\n\nTiering Analysis:\n${tieringSection}`;
  }

  text += `\n\nAnalysis:\n${analysis}

Recommended action:
${recommendedAction}`;

  return text;
}

export const createSummaryTool = (env: Env) =>
  createPrivateTool({
    id: "customer_summary_get",
    description:
      "Returns a pre-computed executive summary snapshot for the customer. " +
      "If a snapshot exists (from customer_summary_generate), returns it instantly. " +
      "If no snapshot exists, generates one on the fly and saves it. " +
      "For best performance, call customer_summary_generate first.",

    inputSchema: z.object({
      customer_id: z.string().optional().describe(
        "Numeric customer ID (recommended, unique). E.g.: 1108. Takes priority over customer_name if provided.",
      ),
      customer_name: z.string().optional().describe(
        "Customer name (exact and partial search). E.g.: Acme Corp. Warning: names are not unique ‚Äî prefer customer_id.",
      ),
      billing_status: z.string().optional().describe(
        "Status filter for billing in the summary. Options: paid | pending | overdue | open | registered",
      ),
      include_email_history: z.boolean().default(true).describe(
        "If false, does not attempt to fetch emails from Gmail. Default: true",
      ),
      email_max_results: z.number().int().min(1).max(50).default(5).describe(
        "Maximum number of emails considered in the summary (default: 5, max: 50).",
      ),
      force_refresh: z.boolean().default(false).describe(
        "If true, ignores any existing snapshot and regenerates the summary. Default: false",
      ),
    }),

    outputSchema: z.object({
      summary: z.string(),
      data_sources: z.any(),
      _meta: z.any(),
    }),

    execute: async ({ context }) => {
      const customerId = clean(context.customer_id);
      const customerName = clean(context.customer_name);
      const billingStatus = clean(context.billing_status);
      const forceRefresh = context.force_refresh ?? false;

      const resolved = await resolveCustomer({
        customer_id: customerId,
        customer_name: customerName,
      });

      // ‚îÄ‚îÄ Try to return snapshot instantly ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (!forceRefresh) {
        const snapshot = await getSnapshot(resolved.customer.id);
        if (snapshot) {
          let dataSources: Record<string, unknown>;
          let meta: Record<string, unknown>;
          try {
            dataSources = JSON.parse(snapshot.data_sources);
          } catch {
            dataSources = { raw: snapshot.data_sources };
          }
          try {
            meta = JSON.parse(snapshot.meta);
          } catch {
            meta = { raw: snapshot.meta };
          }

          return sanitize({
            summary: snapshot.summary_text,
            data_sources: dataSources,
            _meta: {
              ...meta,
              source: "snapshot",
              generated_at: snapshot.generated_at,
              hint: "This is a cached snapshot. Use customer_summary_generate to refresh, or pass force_refresh=true.",
            },
          });
        }
      }

      // ‚îÄ‚îÄ No snapshot found (or force_refresh) ‚Äî generate on the fly ‚îÄ‚îÄ‚îÄ
      const filtersApplied: SummaryFilters = {
        customer_id: customerId,
        customer_name: customerName,
        resolved_customer_id: resolved.customer.id,
        resolved_customer_name: resolved.customer.name,
        match_type: resolved.match_type,
        billing_status: context.billing_status,
        include_email_history: context.include_email_history,
        email_max_results: context.email_max_results,
      };

      const [billing, billing_overview, usage, email_history, tiering] = await Promise.all([
        getBillingData(resolved.customer.id, billingStatus),
        getBillingOverview(resolved.customer.id),
        getUsageData(resolved.customer.id),
        getEmailHistoryData(
          env,
          resolved.customer,
          context.email_max_results,
          context.include_email_history,
        ),
        getTieringData(resolved.customer.id),
      ]);

      const status = determineStatus(billing, email_history);
      const billingFormatted = formatBillingSection(billing);
      const usageFormatted = formatUsageSection(usage);
      const tieringSection = tiering ? formatTieringSection(tiering) : undefined;

      let analysis = generateProgrammaticAnalysis(
        billingFormatted.metrics,
        usageFormatted.metrics,
        email_history,
        tiering,
      );
      let recommendedAction = generateProgrammaticAction(
        status,
        billingFormatted.metrics,
        usageFormatted.metrics,
      );

      const state = (env as any)?.MESH_REQUEST_CONTEXT?.state ?? (env as any)?.state;
      const llmConfig = state?.LLM_CONFIG;
      let llmUsed = false;
      let llmError: string | undefined;

      if (llmConfig?.api_key) {
        const llmContext = buildContext(
          resolved.customer,
          filtersApplied,
          billing,
          billing_overview,
          usage,
          email_history,
          tiering,
        );

        const enriched = await enrichWithLLM(llmConfig, analysis, recommendedAction, llmContext);

        if (!enriched.error) {
          analysis = enriched.analysis;
          recommendedAction = enriched.action;
          llmUsed = true;
        } else {
          llmError = enriched.error;
        }
      }

      const summaryText = buildFormattedSummary(
        resolved.customer,
        status,
        billingFormatted.text,
        usageFormatted.text,
        analysis,
        recommendedAction,
        tieringSection,
      );

      const dataSources = {
        customer: resolved.customer,
        match_type: resolved.match_type,
        filters_applied: filtersApplied,
        billing_overview,
        billing,
        usage,
        email_history,
        tiering,
      };

      const meta = {
        llm_used: llmUsed,
        llm_error: llmError,
        status_severity: status.severity,
        ...(llmUsed && llmConfig
          ? { provider: llmConfig.provider ?? "openai", model: llmConfig.model ?? "gpt-4o-mini" }
          : {}),
      };

      // Save snapshot for future fast retrieval
      await saveSnapshot(resolved.customer.id, summaryText, dataSources, meta);

      return sanitize({
        summary: summaryText,
        data_sources: dataSources,
        _meta: {
          ...meta,
          source: "generated",
          generated_at: new Date().toISOString(),
          hint: "Snapshot saved. Next call will return instantly.",
        },
      });
    },
  });
